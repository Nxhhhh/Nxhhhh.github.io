<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【代码复现】ByteTrack_Demo</title>
    <url>/2024/03/11/ByteTrack-Demo/</url>
    <content><![CDATA[
记录一下重装系统后的第一个代码复现贴一下源代码的链接

环境配置1. 首先安装ByteTrack创建虚拟环境后执行下面语句：
git clone https://github.com/ifzhang/ByteTrack.gitcd ByteTrack
如果不使用国内的镜像源，在执行这一步的时候可能会有很多报错
pip install -r requirements.txt
因此我使用镜像源安装：
pip install whatever gdown -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com
然后执行：
python setup.py develop
如果在这一步报错，编辑setup.py，将：
with open(&quot;README.md&quot;, &quot;r&quot;) as f:
改为：
with open(&quot;README.md&quot;, &quot;r&quot;, encoding=&#x27;utf_8&#x27;) as f:
2.安装pycocotools.如果直接执行这一步会报错
pip3 install cython; pip3 install &#x27;git+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI&#x27;
需要换一种安装方式
这一部分参考https://blog.csdn.net/hhh590_hh/article/details/126916833
1）首先安装cython:
pip install cython gdown -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com
2）然后在https://github.com/pdollar/coco.git下载源码压缩包，解压后放在虚拟环境的site-packages文件下，
3）打开cocoapi-master\pythonAPI中的setup.py文件，删除下面的两个参数：
4）在anaconda prompt中cd到刚才的cocoapi-master\pythonAPI文件夹下，输入：
python setup.py build_ext --inplacepython setup.py build_ext install
如果第一步显示“已完成代码的生成”，第二步显示“Finished processing dependencies for pycocotools==2.0”则表示安装成功。
3.安装cython_bbox依旧是用国内镜像源：
pip install cython_bbox gdown -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com
运行Demo1.下载一个预训练模型，官网给出了很多个模型，在这里我使用的是：贴一下作者给的链接，提取码图上有。
将下载下来的文件放在pretrained文件夹下，如果没有这个文件夹就自己创建一个。
2.修改源码文件地址打开demo_track.py文件，修改第30行的输入文件地址，将其改为绝对地址：如果想跑自己下载的视频也可以在这里改为自己的视频文件：
3.跑通Democd到项目文件夹，输入：
python tools/demo_track.py video -f G:/pycharmprojects/pythonProject/ByteTrack-main/exps/example/mot/yolox_x_mix_det.py -c G:/pycharmprojects/pythonProject/ByteTrack-main/pretrained/bytetrack_x_mot17.pth.tar  --fuse --save_result
注意，我在这里输入的都是文件的绝对地址，并且对比作者给出的demo运行方法，我删除了fp16。
fp16虽然可以使运行速度加快，但是加上fp16可能会导致结果没有检测框，并且检测速度也并没有加快 。
等待运行结束后结果会保存在G:\pycharmprojects\pythonProject\ByteTrack-main\YOLOX_outputs\yolox_x_mix_det\track_vis下。
至此，demo就运行完成了

后续可能会继续记录训练的过程，也可能不会^ - ^。
]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】C++讲义[基础]</title>
    <url>/2024/03/05/C++/</url>
    <content><![CDATA[C++基础入门1 C++初识1.1  第一个C++程序编写一个C++程序总共分为4个步骤

创建项目
创建文件
编写代码
运行程序

1.1.1 创建项目​    Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开


1.1.2 创建文件右键源文件，选择添加-&gt;新建项

给C++文件起个名称，然后点击添加即可。

1.1.3 编写代码#include&lt;iostream&gt;using namespace std;int main() &#123;	cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
1.1.4 运行程序
1.2 注释作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码
两种格式

单行注释：// 描述信息 
通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明


多行注释： /* 描述信息 */
通常放在一段代码的上方，对该段代码做整体说明




提示：编译器在编译代码时，会忽略注释的内容

1.3 变量作用：给一段指定的内存空间起名，方便操作这段内存
语法：数据类型 变量名 = 初始值;
示例：
#include&lt;iostream&gt;using namespace std;int main() &#123;	//变量的定义	//语法：数据类型  变量名 = 初始值	int a = 10;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;		system(&quot;pause&quot;);	return 0;&#125;

注意：C++在创建变量时，必须给变量一个初始值，否则会报错

1.4  常量作用：用于记录程序中不可更改的数据
C++定义常量两种方式

#define 宏常量： #define 常量名 常量值
通常在文件上方定义，表示一个常量




const修饰的变量 const 数据类型 常量名 = 常量值
通常在变量定义前加关键字const，修饰该变量为常量，不可修改



示例：
//1、宏常量#define day 7int main() &#123;	cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl;	//day = 8;  //报错，宏常量不可以修改	//2、const修饰变量	const int month = 12;	cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl;	//month = 24; //报错，常量是不可以修改的			system(&quot;pause&quot;);	return 0;&#125;
1.5 关键字作用：关键字是C++中预先保留的单词（标识符）

在定义变量或者常量时候，不要用关键字

C++关键字如下：




asm
do
if
return
typedef




auto
double
inline
short
typeid


bool
dynamic_cast
int
signed
typename


break
else
long
sizeof
union


case
enum
mutable
static
unsigned


catch
explicit
namespace
static_cast
using


char
export
new
struct
virtual


class
extern
operator
switch
void


const
false
private
template
volatile


const_cast
float
protected
this
wchar_t


continue
for
public
throw
while


default
friend
register
true



delete
goto
reinterpret_cast
try




提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。
1.6 标识符命名规则作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则

标识符不能是关键字
标识符只能由字母、数字、下划线组成
第一个字符必须为字母或下划线
标识符中字母区分大小写


建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读

2 数据类型C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存
2.1 整型作用：整型变量表示的是整数类型的数据
C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：




数据类型
占用空间
取值范围




short(短整型)
2字节
(-2^15 ~ 2^15-1)


int(整型)
4字节
(-2^31 ~ 2^31-1)


long(长整形)
Windows为4字节，Linux为4字节(32位)，8字节(64位)
(-2^31 ~ 2^31-1)


long long(长长整形)
8字节
(-2^63 ~ 2^63-1)




2.2 sizeof关键字作用：利用sizeof关键字可以统计数据类型所占内存大小
语法： sizeof( 数据类型 / 变量)
示例：
int main() &#123;	cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;	cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;	cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;	cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

整型结论：short &lt; int &lt;= long &lt;= long long

2.3 实型（浮点型）作用：用于表示小数
浮点型变量分为两种：

单精度float 
双精度double

两者的区别在于表示的有效数字范围不同。




数据类型
占用空间
有效数字范围




float
4字节
7位有效数字


double
8字节
15～16位有效数字




示例：
int main() &#123;	float f1 = 3.14f;	double d1 = 3.14;	cout &lt;&lt; f1 &lt;&lt; endl;	cout &lt;&lt; d1&lt;&lt; endl;	cout &lt;&lt; &quot;float  sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl;	cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl;	//科学计数法	float f2 = 3e2; // 3 * 10 ^ 2 	cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl;	float f3 = 3e-2;  // 3 * 0.1 ^ 2	cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
2.4 字符型作用：字符型变量用于显示单个字符
语法：char ch = &#39;a&#39;;

注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号
注意2：单引号内只能有一个字符，不可以是字符串


C和C++中字符型变量只占用1个字节。
字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元

示例：
int main() &#123;		char ch = &#x27;a&#x27;;	cout &lt;&lt; ch &lt;&lt; endl;	cout &lt;&lt; sizeof(char) &lt;&lt; endl;	//ch = &quot;abcde&quot;; //错误，不可以用双引号	//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符	cout &lt;&lt; (int)ch &lt;&lt; endl;  //查看字符a对应的ASCII码	ch = 97; //可以直接用ASCII给字符型变量赋值	cout &lt;&lt; ch &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
ASCII码表格：




ASCII值
控制字符
ASCII值
字符
ASCII值
字符
ASCII值
字符




0
NUT
32
(space)
64
@
96
、


1
SOH
33
!
65
A
97
a


2
STX
34
“
66
B
98
b


3
ETX
35
#
67
C
99
c


4
EOT
36
$
68
D
100
d


5
ENQ
37
%
69
E
101
e


6
ACK
38
&amp;
70
F
102
f


7
BEL
39
,
71
G
103
g


8
BS
40
(
72
H
104
h


9
HT
41
)
73
I
105
i


10
LF
42
*
74
J
106
j


11
VT
43
+
75
K
107
k


12
FF
44
,
76
L
108
l


13
CR
45
-
77
M
109
m


14
SO
46
.
78
N
110
n


15
SI
47
/
79
O
111
o


16
DLE
48
0
80
P
112
p


17
DCI
49
1
81
Q
113
q


18
DC2
50
2
82
R
114
r


19
DC3
51
3
83
S
115
s


20
DC4
52
4
84
T
116
t


21
NAK
53
5
85
U
117
u


22
SYN
54
6
86
V
118
v


23
TB
55
7
87
W
119
w


24
CAN
56
8
88
X
120
x


25
EM
57
9
89
Y
121
y


26
SUB
58
:
90
Z
122
z


27
ESC
59
;
91
[
123
{


28
FS
60
&lt;
92
/
124
\



29
GS
61
=
93
]
125
}


30
RS
62
&gt;
94
^
126
`


31
US
63
?
95
_
127
DEL




ASCII 码大致由以下两部分组成：

ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。
ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。

2.5 转义字符作用：用于表示一些不能显示出来的ASCII字符
现阶段我们常用的转义字符有：\n  \\  \t




转义字符
含义
ASCII码值（十进制）




\a
警报
007


\b
退格(BS) ，将当前位置移到前一列
008


\f
换页(FF)，将当前位置移到下页开头
012


\n
换行(LF) ，将当前位置移到下一行开头
010


\r
回车(CR) ，将当前位置移到本行开头
013


\t
水平制表(HT)  （跳到下一个TAB位置）
009


\v
垂直制表(VT)
011


\\\\
代表一个反斜线字符”\”
092


\’
代表一个单引号（撇号）字符
039


\”
代表一个双引号字符
034


\?
代表一个问号
063


\0
数字0
000


\ddd
8进制转义字符，d范围0~7
3位8进制


\xhh
16进制转义字符，h范围0~9，a~f，A~F
3位16进制




示例：
int main() &#123;			cout &lt;&lt; &quot;\\&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;\tHello&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;\n&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
2.6 字符串型作用：用于表示一串字符
两种风格

C风格字符串： char 变量名[] = &quot;字符串值&quot;
示例：
int main() &#123;	char str1[] = &quot;hello world&quot;;	cout &lt;&lt; str1 &lt;&lt; endl;    	system(&quot;pause&quot;);	return 0;&#125;



注意：C风格的字符串要用双引号括起来


C++风格字符串：  string  变量名 = &quot;字符串值&quot;
示例：
int main() &#123;	string str = &quot;hello world&quot;;	cout &lt;&lt; str &lt;&lt; endl;		system(&quot;pause&quot;);	return 0;&#125;
​



注意：C++风格字符串，需要加入头文件#include\

2.7 布尔类型 bool作用：布尔数据类型代表真或假的值 
bool类型只有两个值：

true  —- 真（本质是1）
false —- 假（本质是0）

bool类型占1个字节大小
示例：
int main() &#123;	bool flag = true;	cout &lt;&lt; flag &lt;&lt; endl; // 1	flag = false;	cout &lt;&lt; flag &lt;&lt; endl; // 0	cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1		system(&quot;pause&quot;);	return 0;&#125;
2.8 数据的输入作用：用于从键盘获取数据
关键字：cin
语法： cin &gt;&gt; 变量
示例：
int main()&#123;	//整型输入	int a = 0;	cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl;	cin &gt;&gt; a;	cout &lt;&lt; a &lt;&lt; endl;	//浮点型输入	double d = 0;	cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl;	cin &gt;&gt; d;	cout &lt;&lt; d &lt;&lt; endl;	//字符型输入	char ch = 0;	cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl;	cin &gt;&gt; ch;	cout &lt;&lt; ch &lt;&lt; endl;	//字符串型输入	string str;	cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl;	cin &gt;&gt; str;	cout &lt;&lt; str &lt;&lt; endl;	//布尔类型输入	bool flag = true;	cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl;	cin &gt;&gt; flag;	cout &lt;&lt; flag &lt;&lt; endl;	system(&quot;pause&quot;);	return EXIT_SUCCESS;&#125;
3 运算符作用：用于执行代码的运算
本章我们主要讲解以下几类运算符：




运算符类型
作用




算术运算符
用于处理四则运算


赋值运算符
用于将表达式的值赋给变量


比较运算符
用于表达式的比较，并返回一个真值或假值


逻辑运算符
用于根据表达式的值返回真值或假值




3.1 算术运算符作用：用于处理四则运算 
算术运算符包括以下符号：




运算符
术语
示例
结果




+
正号
+3
3


-
负号
-3
-3


+
加
10 + 5
15


-
减
10 - 5
5


*
乘
10 * 5
50


/
除
10 / 5
2


%
取模(取余)
10 % 3
1


++
前置递增
a=2; b=++a;
a=3; b=3;


++
后置递增
a=2; b=a++;
a=3; b=2;


—
前置递减
a=2; b=—a;
a=1; b=1;


—
后置递减
a=2; b=a—;
a=1; b=2;




示例1：
//加减乘除int main() &#123;	int a1 = 10;	int b1 = 3;	cout &lt;&lt; a1 + b1 &lt;&lt; endl;	cout &lt;&lt; a1 - b1 &lt;&lt; endl;	cout &lt;&lt; a1 * b1 &lt;&lt; endl;	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  //两个整数相除结果依然是整数	int a2 = 10;	int b2 = 20;	cout &lt;&lt; a2 / b2 &lt;&lt; endl; 	int a3 = 10;	int b3 = 0;	//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0	//两个小数可以相除	double d1 = 0.5;	double d2 = 0.25;	cout &lt;&lt; d1 / d2 &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：在除法运算中，除数不能为0

示例2：
//取模int main() &#123;	int a1 = 10;	int b1 = 3;	cout &lt;&lt; 10 % 3 &lt;&lt; endl;	int a2 = 10;	int b2 = 20;	cout &lt;&lt; a2 % b2 &lt;&lt; endl;	int a3 = 10;	int b3 = 0;	//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0	//两个小数不可以取模	double d1 = 3.14;	double d2 = 1.1;	//cout &lt;&lt; d1 % d2 &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：只有整型变量可以进行取模运算

示例3：
//递增int main() &#123;	//后置递增	int a = 10;	a++; //等价于a = a + 1	cout &lt;&lt; a &lt;&lt; endl; // 11	//前置递增	int b = 10;	++b;	cout &lt;&lt; b &lt;&lt; endl; // 11	//区别	//前置递增先对变量进行++，再计算表达式	int a2 = 10;	int b2 = ++a2 * 10;	cout &lt;&lt; b2 &lt;&lt; endl;	//后置递增先计算表达式，后对变量进行++	int a3 = 10;	int b3 = a3++ * 10;	cout &lt;&lt; b3 &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：前置递增先对变量进行++，再计算表达式，后置递增相反

3.2 赋值运算符作用：用于将表达式的值赋给变量
赋值运算符包括以下几个符号：




运算符
术语
示例
结果




=
赋值
a=2; b=3;
a=2; b=3;


+=
加等于
a=0; a+=2;
a=2;


-=
减等于
a=5; a-=3;
a=2;


*=
乘等于
a=2; a*=2;
a=4;


/=
除等于
a=4; a/=2;
a=2;


%=
模等于
a=3; a%2;
a=1;




示例：
int main() &#123;	//赋值运算符	// =	int a = 10;	a = 100;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	// +=	a = 10;	a += 2; // a = a + 2;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	// -=	a = 10;	a -= 2; // a = a - 2	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	// *=	a = 10;	a *= 2; // a = a * 2	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	// /=	a = 10;	a /= 2;  // a = a / 2;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	// %=	a = 10;	a %= 2;  // a = a % 2;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
3.3 比较运算符作用：用于表达式的比较，并返回一个真值或假值
比较运算符有以下符号：




运算符
术语
示例
结果




==
相等于
4 == 3
0


!=
不等于
4 != 3
1


&lt;
小于
4 &lt; 3
0


>
大于
4 &gt; 3
1


&lt;=
小于等于
4 &lt;= 3
0


>=
大于等于
4 &gt;= 1
1




示例：
int main() &#123;	int a = 10;	int b = 20;	cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 	cout &lt;&lt; (a != b) &lt;&lt; endl; // 1	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1		system(&quot;pause&quot;);	return 0;&#125;

注意：C和C++ 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。 

3.4 逻辑运算符作用：用于根据表达式的值返回真值或假值
逻辑运算符有以下符号：




运算符
术语
示例
结果




!
非
!a
如果a为假，则!a为真；  如果a为真，则!a为假。


&amp;&amp;
与
a &amp;&amp; b
如果a和b都为真，则结果为真，否则为假。


\\\\
或
a \\\\ b
如果a和b有一个为真，则结果为真，二者都为假时，结果为假。




示例1：逻辑非
//逻辑运算符  --- 非int main() &#123;	int a = 10;	cout &lt;&lt; !a &lt;&lt; endl; // 0	cout &lt;&lt; !!a &lt;&lt; endl; // 1	system(&quot;pause&quot;);	return 0;&#125;

总结： 真变假，假变真

示例2：逻辑与
//逻辑运算符  --- 与int main() &#123;	int a = 10;	int b = 10;	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1	a = 10;	b = 0;	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 	a = 0;	b = 0;	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0	system(&quot;pause&quot;);	return 0;&#125;

总结：逻辑与运算符总结： 同真为真，其余为假

示例3：逻辑或
//逻辑运算符  --- 或int main() &#123;	int a = 10;	int b = 10;	cout &lt;&lt; (a || b) &lt;&lt; endl;// 1	a = 10;	b = 0;	cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 	a = 0;	b = 0;	cout &lt;&lt; (a || b) &lt;&lt; endl;// 0	system(&quot;pause&quot;);	return 0;&#125;

逻辑或运算符总结： 同假为假，其余为真

4 程序流程结构C/C++支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构

顺序结构：程序按顺序执行，不发生跳转
选择结构：依据条件是否满足，有选择的执行相应功能
循环结构：依据条件是否满足，循环多次执行某段代码

4.1 选择结构4.1.1 if语句作用：执行满足条件的语句
if语句的三种形式

单行格式if语句

多行格式if语句

多条件的if语句
​



单行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125;

示例：
int main() &#123;	//选择结构-单行if语句	//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印	int score = 0;	cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl;	cin &gt;&gt; score;	cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl;	//if语句	//注意事项，在if判断语句后面，不要加分号	if (score &gt; 600)	&#123;		cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
​



注意：if条件表达式后不要加分号


多行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;


​
示例：
int main() &#123;	int score = 0;	cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;	cin &gt;&gt; score;	if (score &gt; 600)	&#123;		cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	return 0;&#125;

多条件的if语句：if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;


​
​
​
示例：
	int main() &#123;	int score = 0;	cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;	cin &gt;&gt; score;	if (score &gt; 600)	&#123;		cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;	&#125;	else if (score &gt; 500)	&#123;		cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;	&#125;	else if (score &gt; 400)	&#123;		cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
​
嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断
案例需求：

提示用户输入一个高考考试分数，根据分数做如下判断
分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；
在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。

示例：
int main() &#123;	int score = 0;	cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;	cin &gt;&gt; score;	if (score &gt; 600)	&#123;		cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;		if (score &gt; 700)		&#123;			cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl;		&#125;		else if (score &gt; 650)		&#123;			cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl;		&#125;		else		&#123;			cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl;		&#125;			&#125;	else if (score &gt; 500)	&#123;		cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;	&#125;	else if (score &gt; 400)	&#123;		cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
练习案例： 三只小猪称体重
有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？
4.1.2 三目运算符作用： 通过三目运算符实现简单的判断
语法：表达式1 ? 表达式2 ：表达式3
解释：
如果表达式1的值为真，执行表达式2，并返回表达式2的结果；
如果表达式1的值为假，执行表达式3，并返回表达式3的结果。
示例：
int main() &#123;	int a = 10;	int b = 20;	int c = 0;	c = a &gt; b ? a : b;	cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;	//C++中三目运算符返回的是变量,可以继续赋值	(a &gt; b ? a : b) = 100;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;	cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰

4.1.3 switch语句作用：执行多条件分支语句
语法：
switch(表达式)&#123;	case 结果1：执行语句;break;	case 结果2：执行语句;break;	...	default:执行语句;break;&#125;
示例：
int main() &#123;	//请给电影评分 	//10 ~ 9   经典   	// 8 ~ 7   非常好	// 6 ~ 5   一般	// 5分以下 烂片	int score = 0;	cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl;	cin &gt;&gt; score;	switch (score)	&#123;	case 10:	case 9:		cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl;		break;	case 8:		cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl;		break;	case 7:	case 6:		cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl;		break;	default:		cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl;		break;	&#125;	system(&quot;pause&quot;);	return 0;&#125;

注意1：switch语句中表达式类型只能是整型或者字符型
注意2：case里如果没有break，那么程序会一直向下执行
总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间

4.2 循环结构4.2.1 while循环语句作用：满足循环条件，执行循环语句
语法：while(循环条件)&#123; 循环语句 &#125;
解释：只要循环条件的结果为真，就执行循环语句==

示例：
int main() &#123;	int num = 0;	while (num &lt; 10)	&#123;		cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;		num++;	&#125;		system(&quot;pause&quot;);	return 0;&#125;

注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环

while循环练习案例：猜数字
案例描述：系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。

4.2.2 do…while循环语句作用： 满足循环条件，执行循环语句
语法： do&#123; 循环语句 &#125; while(循环条件);
注意：与while的区别在于do…while会先执行一次循环语句，再判断循环条件

示例：
int main() &#123;	int num = 0;	do	&#123;		cout &lt;&lt; num &lt;&lt; endl;		num++;	&#125; while (num &lt; 10);			system(&quot;pause&quot;);	return 0;&#125;

总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件

练习案例：水仙花数
案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身
例如：1^3 + 5^3+ 3^3 = 153
请利用do…while语句，求出所有3位数中的水仙花数
4.2.3 for循环语句作用： 满足循环条件，执行循环语句
语法：for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;
示例：
int main() &#123;	for (int i = 0; i &lt; 10; i++)	&#123;		cout &lt;&lt; i &lt;&lt; endl;	&#125;		system(&quot;pause&quot;);	return 0;&#125;
详解：


注意：for循环中的表达式，要用分号进行分隔
总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用

练习案例：敲桌子
案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。

4.2.4 嵌套循环作用： 在循环体中再嵌套一层循环，解决一些实际问题
例如我们想在屏幕中打印如下图片，就需要利用嵌套循环

示例：
int main() &#123;	//外层循环执行1次，内层循环执行1轮	for (int i = 0; i &lt; 10; i++)	&#123;		for (int j = 0; j &lt; 10; j++)		&#123;			cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;		&#125;		cout &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
练习案例：乘法口诀表
案例描述：利用嵌套循环，实现九九乘法表

4.3 跳转语句4.3.1 break语句作用: 用于跳出选择结构或者循环结构
break使用的时机：

出现在switch条件语句中，作用是终止case并跳出switch
出现在循环语句中，作用是跳出当前的循环语句
出现在嵌套循环中，跳出最近的内层循环语句

示例1：
int main() &#123;	//1、在switch 语句中使用break	cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl;	int num = 0;	cin &gt;&gt; num;	switch (num)	&#123;	case 1:		cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl;		break;	case 2:		cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl;		break;	case 3:		cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl;		break;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
示例2：
int main() &#123;	//2、在循环语句中用break	for (int i = 0; i &lt; 10; i++)	&#123;		if (i == 5)		&#123;			break; //跳出循环语句		&#125;		cout &lt;&lt; i &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
示例3：
int main() &#123;	//在嵌套循环语句中使用break，退出内层循环	for (int i = 0; i &lt; 10; i++)	&#123;		for (int j = 0; j &lt; 10; j++)		&#123;			if (j == 5)			&#123;				break;			&#125;			cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;		&#125;		cout &lt;&lt; endl;	&#125;		system(&quot;pause&quot;);	return 0;&#125;
4.3.2 continue语句作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环
示例：
int main() &#123;	for (int i = 0; i &lt; 100; i++)	&#123;		if (i % 2 == 0)		&#123;			continue;		&#125;		cout &lt;&lt; i &lt;&lt; endl;	&#125;		system(&quot;pause&quot;);	return 0;&#125;

注意：continue并没有使整个循环终止，而break会跳出循环

4.3.3 goto语句作用：可以无条件跳转语句
语法： goto 标记;
解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置
示例：
int main() &#123;	cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;	goto FLAG;	cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;3&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;4&quot; &lt;&lt; endl;	FLAG:	cout &lt;&lt; &quot;5&quot; &lt;&lt; endl;		system(&quot;pause&quot;);	return 0;&#125;

注意：在程序中不建议使用goto语句，以免造成程序流程混乱

5 数组5.1 概述所谓数组，就是一个集合，里面存放了相同类型的数据元素
特点1：数组中的每个数据元素都是相同的数据类型
特点2：数组是由连续的内存位置组成的

5.2 一维数组5.2.1 一维数组定义方式一维数组定义的三种方式：

数据类型  数组名[ 数组长度 ];
数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;
数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;

示例
int main() &#123;	//定义方式1	//数据类型 数组名[元素个数];	int score[10];	//利用下标赋值	score[0] = 100;	score[1] = 99;	score[2] = 85;	//利用下标输出	cout &lt;&lt; score[0] &lt;&lt; endl;	cout &lt;&lt; score[1] &lt;&lt; endl;	cout &lt;&lt; score[2] &lt;&lt; endl;	//第二种定义方式	//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;	//如果&#123;&#125;内不足10个数据，剩余数据用0补全	int score2[10] = &#123; 100, 90,80,70,60,50,40,30,20,10 &#125;;		//逐个输出	//cout &lt;&lt; score2[0] &lt;&lt; endl;	//cout &lt;&lt; score2[1] &lt;&lt; endl;	//一个一个输出太麻烦，因此可以利用循环进行输出	for (int i = 0; i &lt; 10; i++)	&#123;		cout &lt;&lt; score2[i] &lt;&lt; endl;	&#125;	//定义方式3	//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;	int score3[] = &#123; 100,90,80,70,60,50,40,30,20,10 &#125;;	for (int i = 0; i &lt; 10; i++)	&#123;		cout &lt;&lt; score3[i] &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	return 0;&#125;

总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名
总结2：数组中下标是从0开始索引

5.2.2 一维数组数组名一维数组名称的用途：

可以统计整个数组在内存中的长度
可以获取数组在内存中的首地址

示例：
int main() &#123;	//数组名用途	//1、可以获取整个数组占用内存空间大小	int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;	cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;	cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;	cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;	//2、可以通过数组名获取到数组首地址	cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl;	cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;	cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;	//arr = 100; 错误，数组名是常量，因此不可以赋值	system(&quot;pause&quot;);	return 0;&#125;

注意：数组名是常量，不可以赋值
总结1：直接打印数组名，可以查看数组所占内存的首地址
总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小

练习案例1：五只小猪称体重
案例描述：
在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};
找出并打印最重的小猪体重。
练习案例2：数组元素逆置
案例描述：请声明一个5个元素的数组，并且将元素逆置.
(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);
5.2.3 冒泡排序作用： 最常用的排序算法，对数组内元素进行排序

比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。
重复以上的步骤，每次比较次数-1，直到不需要比较


示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序
int main() &#123;	int arr[9] = &#123; 4,2,8,0,5,7,1,3,9 &#125;;	for (int i = 0; i &lt; 9 - 1; i++)	&#123;		for (int j = 0; j &lt; 9 - 1 - i; j++)		&#123;			if (arr[j] &gt; arr[j + 1])			&#123;				int temp = arr[j];				arr[j] = arr[j + 1];				arr[j + 1] = temp;			&#125;		&#125;	&#125;	for (int i = 0; i &lt; 9; i++)	&#123;		cout &lt;&lt; arr[i] &lt;&lt; endl;	&#125;    	system(&quot;pause&quot;);	return 0;&#125;
5.3 二维数组二维数组就是在一维数组上，多加一个维度。

5.3.1 二维数组定义方式二维数组定义的四种方式：

数据类型  数组名[ 行数 ][ 列数 ];
数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;
数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;
数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;


建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性

示例：
int main() &#123;	//方式1  	//数组类型 数组名 [行数][列数]	int arr[2][3];	arr[0][0] = 1;	arr[0][1] = 2;	arr[0][2] = 3;	arr[1][0] = 4;	arr[1][1] = 5;	arr[1][2] = 6;	for (int i = 0; i &lt; 2; i++)	&#123;		for (int j = 0; j &lt; 3; j++)		&#123;			cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;;		&#125;		cout &lt;&lt; endl;	&#125;	//方式2 	//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;	int arr2[2][3] =	&#123;		&#123;1,2,3&#125;,		&#123;4,5,6&#125;	&#125;;	//方式3	//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;	int arr3[2][3] = &#123; 1,2,3,4,5,6 &#125;; 	//方式4 	//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;	int arr4[][3] = &#123; 1,2,3,4,5,6 &#125;;		system(&quot;pause&quot;);	return 0;&#125;

总结：在定义二维数组时，如果初始化了数据，可以省略行数

5.3.2 二维数组数组名
查看二维数组所占内存空间
获取二维数组首地址

示例：
int main() &#123;	//二维数组数组名	int arr[2][3] =	&#123;		&#123;1,2,3&#125;,		&#123;4,5,6&#125;	&#125;;	cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;	cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;	cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;	cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;	cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;	//地址	cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;	cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;	cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;	cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;	cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结1：二维数组名就是这个数组的首地址
总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小

5.3.3 二维数组应用案例考试成绩统计：
案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩





语文
数学
英语




张三
100
100
100


李四
90
50
100


王五
60
70
80




参考答案：
int main() &#123;	int scores[3][3] =	&#123;		&#123;100,100,100&#125;,		&#123;90,50,100&#125;,		&#123;60,70,80&#125;,	&#125;;	string names[3] = &#123; &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; &#125;;	for (int i = 0; i &lt; 3; i++)	&#123;		int sum = 0;		for (int j = 0; j &lt; 3; j++)		&#123;			sum += scores[i][j];		&#125;		cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
6 函数6.1 概述作用：将一段经常使用的代码封装起来，减少重复代码
一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。
6.2 函数的定义函数的定义一般主要有5个步骤：
1、返回值类型 
2、函数名
3、参数表列
4、函数体语句 
5、return 表达式
语法： 
返回值类型 函数名 （参数列表）&#123;       函数体语句       return表达式&#125;

返回值类型 ：一个函数可以返回一个值。在函数定义中
函数名：给函数起个名称
参数列表：使用该函数时，传入的数据
函数体语句：花括号内的代码，函数内需要执行的语句
return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据

示例：定义一个加法函数，实现两个数相加
//函数定义int add(int num1, int num2)&#123;	int sum = num1 + num2;	return sum;&#125;
6.3 函数的调用功能：使用定义好的函数
语法：函数名（参数）
示例：
//函数定义int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参&#123;	int sum = num1 + num2;	return sum;&#125;int main() &#123;	int a = 10;	int b = 10;	//调用add函数	int sum = add(a, b);//调用时的a，b称为实际参数，简称实参	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;	a = 100;	b = 100;	sum = add(a, b);	cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参

6.4 值传递
所谓值传递，就是函数调用时实参将数值传入给形参
值传递时，如果形参发生，并不会影响实参

示例：
void swap(int num1, int num2)&#123;	cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;	cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;	int temp = num1;	num1 = num2;	num2 = temp;	cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;	cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;	//return ; 当函数声明时候，不需要返回值，可以不写return&#125;int main() &#123;	int a = 10;	int b = 20;	swap(a, b);	cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl;	cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结： 值传递时，形参是修饰不了实参的

6.5 函数的常见样式常见的函数样式有4种

无参无返
有参无返
无参有返
有参有返

示例：
//函数常见样式//1、 无参无返void test01()&#123;	//void a = 10; //无类型不可以创建变量,原因无法分配内存	cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl;	//test01(); 函数调用&#125;//2、 有参无返void test02(int a)&#123;	cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;&#125;//3、无参有返int test03()&#123;	cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl;	return 10;&#125;//4、有参有返int test04(int a, int b)&#123;	cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl;	int sum = a + b;	return sum;&#125;
6.6 函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数的声明可以多次，但是函数的定义只能有一次

示例：
//声明可以多次，定义只能一次//声明int max(int a, int b);int max(int a, int b);//定义int max(int a, int b)&#123;	return a &gt; b ? a : b;&#125;int main() &#123;	int a = 100;	int b = 200;	cout &lt;&lt; max(a, b) &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
6.7 函数的分文件编写作用：让代码结构更加清晰
函数分文件编写一般有4个步骤

创建后缀名为.h的头文件  
创建后缀名为.cpp的源文件
在头文件中写函数的声明
在源文件中写函数的定义

示例：
//swap.h文件#include&lt;iostream&gt;using namespace std;//实现两个数字交换的函数声明void swap(int a, int b);
//swap.cpp文件#include &quot;swap.h&quot;void swap(int a, int b)&#123;	int temp = a;	a = b;	b = temp;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;
//main函数文件#include &quot;swap.h&quot;int main() &#123;	int a = 100;	int b = 200;	swap(a, b);	system(&quot;pause&quot;);	return 0;&#125;
7 指针7.1 指针的基本概念指针的作用： 可以通过指针间接访问内存

内存编号是从0开始记录的，一般用十六进制数字表示
可以利用指针变量保存地址
​


7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名；
示例：
int main() &#123;	//1、指针的定义	int a = 10; //定义整型变量a		//指针定义语法： 数据类型 * 变量名 ;	int * p;	//指针变量赋值	p = &amp;a; //指针指向变量a的地址	cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址	cout &lt;&lt; p &lt;&lt; endl;  //打印指针变量p	//2、指针的使用	//通过*操作指针变量指向的内存	cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
指针变量和普通变量的区别

普通变量存放的是数据,指针变量存放的是地址
指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用


总结1： 我们可以通过 &amp; 符号 获取变量的地址
总结2：利用指针可以记录地址
总结3：对指针变量解引用，可以操作指针指向的内存

7.3 指针所占内存空间提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？
示例：
int main() &#123;	int a = 10;	int * p;	p = &amp;a; //指针指向数据a的地址	cout &lt;&lt; *p &lt;&lt; endl; //* 解引用	cout &lt;&lt; sizeof(p) &lt;&lt; endl;	cout &lt;&lt; sizeof(char *) &lt;&lt; endl;	cout &lt;&lt; sizeof(float *) &lt;&lt; endl;	cout &lt;&lt; sizeof(double *) &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：所有指针类型在32位操作系统下是4个字节

7.4 空指针和野指针空指针：指针变量指向内存中编号为0的空间
用途：初始化指针变量
注意：空指针指向的内存是不可以访问的
示例1：空指针
int main() &#123;	//指针变量p指向内存地址编号为0的空间	int * p = NULL;	//访问空指针报错 	//内存编号0 ~255为系统占用内存，不允许用户访问	cout &lt;&lt; *p &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
野指针：指针变量指向非法的内存空间
示例2：野指针
int main() &#123;	//指针变量p指向内存地址编号为0x1100的空间	int * p = (int *)0x1100;	//访问野指针报错 	cout &lt;&lt; *p &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：空指针和野指针都不是我们申请的空间，因此不要访问。

7.5 const修饰指针const修饰指针有三种情况

const修饰指针   —- 常量指针
const修饰常量   —- 指针常量
const即修饰指针，又修饰常量

示例：
int main() &#123;	int a = 10;	int b = 10;	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改	const int * p1 = &amp;a; 	p1 = &amp;b; //正确	//*p1 = 100;  报错		//const修饰的是常量，指针指向不可以改，指针指向的值可以更改	int * const p2 = &amp;a;	//p2 = &amp;b; //错误	*p2 = 100; //正确    //const既修饰指针又修饰常量	const int * const p3 = &amp;a;	//p3 = &amp;b; //错误	//*p3 = 100; //错误	system(&quot;pause&quot;);	return 0;&#125;

技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量

7.6 指针和数组作用：利用指针访问数组中元素
示例：
int main() &#123;	int arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;	int * p = arr;  //指向数组的指针	cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl;	cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl;	for (int i = 0; i &lt; 10; i++)	&#123;		//利用指针遍历数组		cout &lt;&lt; *p &lt;&lt; endl;		p++;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
7.7 指针和函数作用：利用指针作函数参数，可以修改实参的值
示例：
//值传递void swap1(int a ,int b)&#123;	int temp = a;	a = b; 	b = temp;&#125;//地址传递void swap2(int * p1, int *p2)&#123;	int temp = *p1;	*p1 = *p2;	*p2 = temp;&#125;int main() &#123;	int a = 10;	int b = 20;	swap1(a, b); // 值传递不会改变实参	swap2(&amp;a, &amp;b); //地址传递会改变实参	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递

7.8 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序
例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
示例：
//冒泡排序函数void bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]&#123;	for (int i = 0; i &lt; len - 1; i++)	&#123;		for (int j = 0; j &lt; len - 1 - i; j++)		&#123;			if (arr[j] &gt; arr[j + 1])			&#123;				int temp = arr[j];				arr[j] = arr[j + 1];				arr[j + 1] = temp;			&#125;		&#125;	&#125;&#125;//打印数组函数void printArray(int arr[], int len)&#123;	for (int i = 0; i &lt; len; i++)	&#123;		cout &lt;&lt; arr[i] &lt;&lt; endl;	&#125;&#125;int main() &#123;	int arr[10] = &#123; 4,3,6,9,1,2,10,8,7,5 &#125;;	int len = sizeof(arr) / sizeof(int);	bubbleSort(arr, len);	printArray(arr, len);	system(&quot;pause&quot;);	return 0;&#125;

总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针

8 结构体8.1 结构体基本概念结构体属于用户自定义的数据类型，允许用户存储不同的数据类型
8.2 结构体定义和使用语法：struct 结构体名 &#123; 结构体成员列表 &#125;；
通过结构体创建变量的方式有三种：

struct 结构体名 变量名
struct 结构体名 变量名 = { 成员1值 ， 成员2值…}
定义结构体时顺便创建变量

示例：
//结构体定义struct student&#123;	//成员列表	string name;  //姓名	int age;      //年龄	int score;    //分数&#125;stu3; //结构体变量创建方式3 int main() &#123;	//结构体变量创建方式1	struct student stu1; //struct 关键字可以省略	stu1.name = &quot;张三&quot;;	stu1.age = 18;	stu1.score = 100;		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl;	//结构体变量创建方式2	struct student stu2 = &#123; &quot;李四&quot;,19,60 &#125;;	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl;	stu3.name = &quot;王五&quot;;	stu3.age = 18;	stu3.score = 80;		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结1：定义结构体时的关键字是struct，不可省略
总结2：创建结构体变量时，关键字struct可以省略
总结3：结构体变量利用操作符 ‘’.’’  访问成员

8.3 结构体数组作用：将自定义的结构体放入到数组中方便维护
语法：struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;
示例：
//结构体定义struct student&#123;	//成员列表	string name;  //姓名	int age;      //年龄	int score;    //分数&#125;int main() &#123;		//结构体数组	struct student arr[3]=	&#123;		&#123;&quot;张三&quot;,18,80 &#125;,		&#123;&quot;李四&quot;,19,60 &#125;,		&#123;&quot;王五&quot;,20,70 &#125;	&#125;;	for (int i = 0; i &lt; 3; i++)	&#123;		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
8.4 结构体指针作用：通过指针访问结构体中的成员

利用操作符 -&gt;可以通过结构体指针访问结构体属性

示例：
//结构体定义struct student&#123;	//成员列表	string name;  //姓名	int age;      //年龄	int score;    //分数&#125;;int main() &#123;		struct student stu = &#123; &quot;张三&quot;,18,100, &#125;;		struct student * p = &amp;stu;		p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;		system(&quot;pause&quot;);	return 0;&#125;

总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员

8.5 结构体嵌套结构体作用： 结构体中的成员可以是另一个结构体
例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体
示例：
//学生结构体定义struct student&#123;	//成员列表	string name;  //姓名	int age;      //年龄	int score;    //分数&#125;;//教师结构体定义struct teacher&#123;    //成员列表	int id; //职工编号	string name;  //教师姓名	int age;   //教师年龄	struct student stu; //子结构体 学生&#125;;int main() &#123;	struct teacher t1;	t1.id = 10000;	t1.name = &quot;老王&quot;;	t1.age = 40;	t1.stu.name = &quot;张三&quot;;	t1.stu.age = 18;	t1.stu.score = 100;	cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl;		cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题
8.6 结构体做函数参数作用：将结构体作为参数向函数中传递
传递方式有两种：

值传递
地址传递

示例：
//学生结构体定义struct student&#123;	//成员列表	string name;  //姓名	int age;      //年龄	int score;    //分数&#125;;//值传递void printStudent(student stu )&#123;	stu.age = 28;	cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;&#125;//地址传递void printStudent2(student *stu)&#123;	stu-&gt;age = 28;	cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123;	student stu = &#123; &quot;张三&quot;,18,100&#125;;	//值传递	printStudent(stu);	cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;	cout &lt;&lt; endl;	//地址传递	printStudent2(&amp;stu);	cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：如果不想修改主函数中的数据，用值传递，反之用地址传递

8.7 结构体中 const使用场景作用：用const来防止误操作
示例：
//学生结构体定义struct student&#123;	//成员列表	string name;  //姓名	int age;      //年龄	int score;    //分数&#125;;//const使用场景void printStudent(const student *stu) //加const防止函数体中的误操作&#123;	//stu-&gt;age = 100; //操作失败，因为加了const修饰	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123;	student stu = &#123; &quot;张三&quot;,18,100 &#125;;	printStudent(&amp;stu);	system(&quot;pause&quot;);	return 0;&#125;
8.8 结构体案例8.8.1 案例1案例描述：
学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下
设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员
学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值
最终打印出老师数据以及老师所带的学生数据。
示例：
struct Student&#123;	string name;	int score;&#125;;struct Teacher&#123;	string name;	Student sArray[5];&#125;;void allocateSpace(Teacher tArray[] , int len)&#123;	string tName = &quot;教师&quot;;	string sName = &quot;学生&quot;;	string nameSeed = &quot;ABCDE&quot;;	for (int i = 0; i &lt; len; i++)	&#123;		tArray[i].name = tName + nameSeed[i];				for (int j = 0; j &lt; 5; j++)		&#123;			tArray[i].sArray[j].name = sName + nameSeed[j];			tArray[i].sArray[j].score = rand() % 61 + 40;		&#125;	&#125;&#125;void printTeachers(Teacher tArray[], int len)&#123;	for (int i = 0; i &lt; len; i++)	&#123;		cout &lt;&lt; tArray[i].name &lt;&lt; endl;		for (int j = 0; j &lt; 5; j++)		&#123;			cout &lt;&lt; &quot;\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;		&#125;	&#125;&#125;int main() &#123;	srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt;	Teacher tArray[3]; //老师数组	int len = sizeof(tArray) / sizeof(Teacher);	allocateSpace(tArray, len); //创建数据	printTeachers(tArray, len); //打印数据		system(&quot;pause&quot;);	return 0;&#125;
8.8.2 案例2案例描述：
设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。
通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。
五名英雄信息如下：
&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;,
示例：
//英雄结构体struct hero&#123;	string name;	int age;	string sex;&#125;;//冒泡排序void bubbleSort(hero arr[] , int len)&#123;	for (int i = 0; i &lt; len - 1; i++)	&#123;		for (int j = 0; j &lt; len - 1 - i; j++)		&#123;			if (arr[j].age &gt; arr[j + 1].age)			&#123;				hero temp = arr[j];				arr[j] = arr[j + 1];				arr[j + 1] = temp;			&#125;		&#125;	&#125;&#125;//打印数组void printHeros(hero arr[], int len)&#123;	for (int i = 0; i &lt; len; i++)	&#123;		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl;	&#125;&#125;int main() &#123;	struct hero arr[5] =	&#123;		&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,		&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,		&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,		&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,		&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;,	&#125;;	int len = sizeof(arr) / sizeof(hero); //获取数组元素个数	bubbleSort(arr, len); //排序	printHeros(arr, len); //打印	system(&quot;pause&quot;);	return 0;&#125;
基础实战通讯录管理系统1、系统需求通讯录是一个可以记录亲人、好友信息的工具。
本教程主要利用C++来实现一个通讯录管理系统
系统中需要实现的功能如下：

添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多记录1000人
显示联系人：显示通讯录中所有联系人信息
删除联系人：按照姓名进行删除指定联系人
查找联系人：按照姓名查看指定联系人信息
修改联系人：按照姓名重新修改指定联系人
清空联系人：清空通讯录中所有信息
退出通讯录：退出当前使用的通讯录

2、创建项目创建项目步骤如下：

创建新项目
添加文件

2.1 创建项目打开vs2017后，点击创建新项目，创建新的C++项目

填写项目名称，选择项目路径

2.2添加文件

添加成功后，效果如图：

至此，项目已创建完毕
3、菜单功能功能描述： 用户选择功能的界面
菜单界面效果如下图：

步骤：

封装函数显示该界面  如 void showMenu()
在main函数中调用封装好的函数

代码：
#include&lt;iostream&gt;using namespace std;//菜单界面void showMenu()&#123;	cout &lt;&lt; &quot;***************************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*****  1、添加联系人  *****&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*****  2、显示联系人  *****&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*****  3、删除联系人  *****&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*****  4、查找联系人  *****&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*****  5、修改联系人  *****&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*****  6、清空联系人  *****&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*****  0、退出通讯录  *****&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;***************************&quot; &lt;&lt; endl;&#125;int main() &#123;	showMenu();	system(&quot;pause&quot;);	return 0;&#125;
4、退出功能功能描述：退出通讯录系统
思路：根据用户不同的选择，进入不同的功能，可以选择switch分支结构，将整个架构进行搭建
当用户选择0时候，执行退出，选择其他先不做操作，也不会退出程序
代码：
int main() &#123;	int select = 0;	while (true)	&#123;		showMenu();		cin &gt;&gt; select;				switch (select)		&#123;		case 1:  //添加联系人			break;		case 2:  //显示联系人			break;		case 3:  //删除联系人			break;		case 4:  //查找联系人			break;		case 5:  //修改联系人			break;		case 6:  //清空联系人			break;		case 0:  //退出通讯录			cout &lt;&lt; &quot;欢迎下次使用&quot; &lt;&lt; endl;			system(&quot;pause&quot;);			return 0;			break;		default:			break;		&#125;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
效果图：

5、添加联系人功能描述：
实现添加联系人功能，联系人上限为1000人，联系人信息包括（姓名、性别、年龄、联系电话、家庭住址）
添加联系人实现步骤：

设计联系人结构体
设计通讯录结构体
main函数中创建通讯录
封装添加联系人函数
测试添加联系人功能

5.1 设计联系人结构体联系人信息包括：姓名、性别、年龄、联系电话、家庭住址
设计如下：
#include &lt;string&gt;  //string头文件//联系人结构体struct Person&#123;	string m_Name; //姓名	int m_Sex; //性别：1男 2女	int m_Age; //年龄	string m_Phone; //电话	string m_Addr; //住址&#125;;
5.2 设计通讯录结构体设计时候可以在通讯录结构体中，维护一个容量为1000的存放联系人的数组，并记录当前通讯录中联系人数量
设计如下
#define MAX 1000 //最大人数//通讯录结构体struct Addressbooks&#123;	struct Person personArray[MAX]; //通讯录中保存的联系人数组	int m_Size; //通讯录中人员个数&#125;;
5.3 main函数中创建通讯录添加联系人函数封装好后，在main函数中创建一个通讯录变量，这个就是我们需要一直维护的通讯录
mian函数起始位置添加：	//创建通讯录	Addressbooks abs;	//初始化通讯录中人数	abs.m_Size = 0;
5.4 封装添加联系人函数思路：添加联系人前先判断通讯录是否已满，如果满了就不再添加，未满情况将新联系人信息逐个加入到通讯录
添加联系人代码：
//1、添加联系人信息void addPerson(Addressbooks *abs)&#123;	//判断电话本是否满了	if (abs-&gt;m_Size == MAX)	&#123;		cout &lt;&lt; &quot;通讯录已满，无法添加&quot; &lt;&lt; endl;		return;	&#125;	else	&#123;		//姓名		string name;		cout &lt;&lt; &quot;请输入姓名：&quot; &lt;&lt; endl;		cin &gt;&gt; name;		abs-&gt;personArray[abs-&gt;m_Size].m_Name = name;		cout &lt;&lt; &quot;请输入性别：&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;1 -- 男&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;2 -- 女&quot; &lt;&lt; endl;		//性别		int sex = 0;		while (true)		&#123;			cin &gt;&gt; sex;			if (sex == 1 || sex == 2)			&#123;				abs-&gt;personArray[abs-&gt;m_Size].m_Sex = sex;				break;			&#125;			cout &lt;&lt; &quot;输入有误，请重新输入&quot;;		&#125;		//年龄		cout &lt;&lt; &quot;请输入年龄：&quot; &lt;&lt; endl;		int age = 0;		cin &gt;&gt; age;		abs-&gt;personArray[abs-&gt;m_Size].m_Age = age;		//联系电话		cout &lt;&lt; &quot;请输入联系电话：&quot; &lt;&lt; endl;		string phone = &quot;&quot;;		cin &gt;&gt; phone;		abs-&gt;personArray[abs-&gt;m_Size].m_Phone = phone;		//家庭住址		cout &lt;&lt; &quot;请输入家庭住址：&quot; &lt;&lt; endl;		string address;		cin &gt;&gt; address;		abs-&gt;personArray[abs-&gt;m_Size].m_Addr = address;		//更新通讯录人数		abs-&gt;m_Size++;		cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; endl;		system(&quot;pause&quot;);		system(&quot;cls&quot;);	&#125;&#125;
5.5 测试添加联系人功能选择界面中，如果玩家选择了1，代表添加联系人，我们可以测试下该功能
在switch case 语句中，case1里添加：
case 1:  //添加联系人	addPerson(&amp;abs);	break;
测试效果如图：

6、显示联系人功能描述：显示通讯录中已有的联系人信息
显示联系人实现步骤：

封装显示联系人函数
测试显示联系人功能

6.1 封装显示联系人函数思路：判断如果当前通讯录中没有人员，就提示记录为空，人数大于0，显示通讯录中信息
显示联系人代码：
//2、显示所有联系人信息void showPerson(Addressbooks * abs)&#123;	if (abs-&gt;m_Size == 0)	&#123;		cout &lt;&lt; &quot;当前记录为空&quot; &lt;&lt; endl;	&#125;	else	&#123;		for (int i = 0; i &lt; abs-&gt;m_Size; i++)		&#123;			cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; abs-&gt;personArray[i].m_Name &lt;&lt; &quot;\t&quot;;			cout &lt;&lt; &quot;性别：&quot; &lt;&lt; (abs-&gt;personArray[i].m_Sex == 1 ? &quot;男&quot; : &quot;女&quot;) &lt;&lt; &quot;\t&quot;;			cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; abs-&gt;personArray[i].m_Age &lt;&lt; &quot;\t&quot;;			cout &lt;&lt; &quot;电话：&quot; &lt;&lt; abs-&gt;personArray[i].m_Phone &lt;&lt; &quot;\t&quot;;			cout &lt;&lt; &quot;住址：&quot; &lt;&lt; abs-&gt;personArray[i].m_Addr &lt;&lt; endl;		&#125;	&#125;		system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
6.2 测试显示联系人功能在switch case语句中，case 2 里添加
case 2:  //显示联系人	showPerson(&amp;abs);	break;
测试效果如图：

7、删除联系人功能描述：按照姓名进行删除指定联系人
删除联系人实现步骤：

封装检测联系人是否存在
封装删除联系人函数
测试删除联系人功能

7.1  封装检测联系人是否存在设计思路：
删除联系人前，我们需要先判断用户输入的联系人是否存在，如果存在删除，不存在提示用户没有要删除的联系人
因此我们可以把检测联系人是否存在封装成一个函数中，如果存在，返回联系人在通讯录中的位置，不存在返回-1
检测联系人是否存在代码：
//判断是否存在查询的人员，存在返回在数组中索引位置，不存在返回-1int isExist(Addressbooks * abs, string name)&#123;	for (int i = 0; i &lt; abs-&gt;m_Size; i++)	&#123;		if (abs-&gt;personArray[i].m_Name == name)		&#123;			return i;		&#125;	&#125;	return -1;&#125;
7.2 封装删除联系人函数根据用户输入的联系人判断该通讯录中是否有此人
查找到进行删除，并提示删除成功
查不到提示查无此人。
//3、删除指定联系人信息void deletePerson(Addressbooks * abs)&#123;	cout &lt;&lt; &quot;请输入您要删除的联系人&quot; &lt;&lt; endl;	string name;	cin &gt;&gt; name;	int ret = isExist(abs, name);	if (ret != -1)	&#123;		for (int i = ret; i &lt; abs-&gt;m_Size; i++)		&#123;			abs-&gt;personArray[i] = abs-&gt;personArray[i + 1];		&#125;         abs-&gt;m_Size--;		cout &lt;&lt; &quot;删除成功&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
7.3 测试删除联系人功能在switch case 语句中，case3里添加：
case 3:  //删除联系人	deletePerson(&amp;abs);	break;
测试效果如图：
存在情况：

不存在情况：

8、查找联系人功能描述：按照姓名查看指定联系人信息
查找联系人实现步骤

封装查找联系人函数
测试查找指定联系人

8.1 封装查找联系人函数实现思路：判断用户指定的联系人是否存在，如果存在显示信息，不存在则提示查无此人。
查找联系人代码：
//4、查找指定联系人信息void findPerson(Addressbooks * abs)&#123;	cout &lt;&lt; &quot;请输入您要查找的联系人&quot; &lt;&lt; endl;	string name;	cin &gt;&gt; name;	int ret = isExist(abs, name);	if (ret != -1)	&#123;		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Name &lt;&lt; &quot;\t&quot;;		cout &lt;&lt; &quot;性别：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Sex &lt;&lt; &quot;\t&quot;;		cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Age &lt;&lt; &quot;\t&quot;;		cout &lt;&lt; &quot;电话：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Phone &lt;&lt; &quot;\t&quot;;		cout &lt;&lt; &quot;住址：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Addr &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
8.2 测试查找指定联系人在switch case 语句中，case4里添加：
case 4:  //查找联系人	findPerson(&amp;abs);	break;
测试效果如图
存在情况：

不存在情况：

9、修改联系人功能描述：按照姓名重新修改指定联系人
修改联系人实现步骤

封装修改联系人函数
测试修改联系人功能

9.1 封装修改联系人函数实现思路：查找用户输入的联系人，如果查找成功进行修改操作，查找失败提示查无此人
修改联系人代码：
//5、修改指定联系人信息void modifyPerson(Addressbooks * abs)&#123;	cout &lt;&lt; &quot;请输入您要修改的联系人&quot; &lt;&lt; endl;	string name;	cin &gt;&gt; name;	int ret = isExist(abs, name);	if (ret != -1)	&#123;		//姓名		string name;		cout &lt;&lt; &quot;请输入姓名：&quot; &lt;&lt; endl;		cin &gt;&gt; name;		abs-&gt;personArray[ret].m_Name = name;		cout &lt;&lt; &quot;请输入性别：&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;1 -- 男&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;2 -- 女&quot; &lt;&lt; endl;		//性别		int sex = 0;		while (true)		&#123;			cin &gt;&gt; sex;			if (sex == 1 || sex == 2)			&#123;				abs-&gt;personArray[ret].m_Sex = sex;				break;			&#125;			cout &lt;&lt; &quot;输入有误，请重新输入&quot;;		&#125;		//年龄		cout &lt;&lt; &quot;请输入年龄：&quot; &lt;&lt; endl;		int age = 0;		cin &gt;&gt; age;		abs-&gt;personArray[ret].m_Age = age;		//联系电话		cout &lt;&lt; &quot;请输入联系电话：&quot; &lt;&lt; endl;		string phone = &quot;&quot;;		cin &gt;&gt; phone;		abs-&gt;personArray[ret].m_Phone = phone;		//家庭住址		cout &lt;&lt; &quot;请输入家庭住址：&quot; &lt;&lt; endl;		string address;		cin &gt;&gt; address;		abs-&gt;personArray[ret].m_Addr = address;		cout &lt;&lt; &quot;修改成功&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
9.2 测试修改联系人功能在switch case 语句中，case 5里添加：
case 5:  //修改联系人	modifyPerson(&amp;abs);	break;
测试效果如图：
查不到指定联系人情况：

查找到联系人，并修改成功：

再次查看通讯录，确认修改完毕

10、清空联系人功能描述：清空通讯录中所有信息
清空联系人实现步骤

封装清空联系人函数
测试清空联系人

10.1 封装清空联系人函数实现思路： 将通讯录所有联系人信息清除掉，只要将通讯录记录的联系人数量置为0，做逻辑清空即可。
清空联系人代码：
//6、清空所有联系人void cleanPerson(Addressbooks * abs)&#123;	abs-&gt;m_Size = 0;	cout &lt;&lt; &quot;通讯录已清空&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
10.2  测试清空联系人在switch case 语句中，case 6 里添加：
case 6:  //清空联系人	cleanPerson(&amp;abs);	break;
测试效果如图：
清空通讯录

再次查看信息，显示记录为空

至此，通讯录管理系统完成！
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++静态库和动态库的区别</title>
    <url>/2025/02/20/C-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[什么是库库是写好的，现有的，成熟的，可以复用的代码。本质上来说，库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。所谓静态、动态是指链接。
库文件是事先编译好的方法的合集。
静态库与动态库的区别1、静态库的扩展名一般为“.a”或“.lib”（C/C++）；动态库的扩展名一般为“.so”或“.dll”（C/C++）。
2、静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行；动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。
静态库和动态库最本质的区别就是：该库是否被编译进目标（程序）内部。
静态（函数）库一般扩展名为（.a或.lib）,这类的函数库通常扩展名为libxxx.a或xxx.lib 。
这类库在编译的时候会直接整合到目标程序中，所以利用静态函数库编译成的文件会比较大，这类函数库最大的优点就是编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容；但是从升级难易度来看明显没有优势，如果函数库更新，需要重新编译。
动态（函数）库动态函数库的扩展名一般为（.so或.dll），这类函数库通常名为libxxx.so或xxx.dll 。
与静态函数库被整个捕捉到程序中不同，动态函数库在编译的时候，在程序里只有一个“指向”的位置而已，也就是说当可执行文件需要使用到函数库的机制时，程序才会去读取函数库来使用；也就是说可执行文件无法单独运行。这样从产品功能升级角度方便升级，只要替换对应动态库即可，不必重新编译整个可执行文件。
静态库与动态库优缺点静态库优点：
①静态库被打包到应用程序中加载速度快②发布程序无需提供静态库，移植方便
缺点：
①相同的库文件数据可能在内存中被加载多份，消耗系统资源，浪费内存②库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间。
动态库优点：
①可实现不同进程间的资源共享②动态库升级简单，只需要替换库文件，无需重新编译应用程序③可以控制何时加载动态库，不调用库函数动态库不会被加载                                                       
缺点：
①加载速度比静态库慢②发布程序需要提供依赖的动态库
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】C++讲义[核心]</title>
    <url>/2024/08/27/C-2/</url>
    <content><![CDATA[C++核心编程本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓。
1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域

代码区：存放函数体的二进制代码，由操作系统进行管理的
全局区：存放全局变量和静态变量以及常量
栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

内存四区意义：
不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程
1.1 程序运行前​    在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域
​    代码区：
​        存放 CPU 执行的机器指令
​        代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
​        代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令
​    全局区：
​        全局变量和静态变量存放在此.
​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.
​        该区域的数据在程序结束后由操作系统释放.
示例：
//全局变量int g_a = 10;int g_b = 10;//全局常量const int c_g_a = 10;const int c_g_b = 10;int main() &#123;	//局部变量	int a = 10;	int b = 10;	//打印地址	cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;	cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;	cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;	cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;	//静态变量	static int s_a = 10;	static int s_b = 10;	cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;	cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;	cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;	cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;	const int c_l_a = 10;	const int c_l_b = 10;	cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;	cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
打印结果：

总结：

C++中在程序运行前分为全局区和代码区
代码区特点是共享和只读
全局区中存放全局变量、静态变量、常量
常量区中存放 const修饰的全局常量  和 字符串常量

1.2 程序运行后​    栈区：
​        由编译器自动分配释放, 存放函数的参数值,局部变量等
​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放
示例：
int * func()&#123;	int a = 10;	return &amp;a;&#125;int main() &#123;	int *p = func();	cout &lt;&lt; *p &lt;&lt; endl;	cout &lt;&lt; *p &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
​    堆区：
​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收
​        在C++中主要利用new在堆区开辟内存
示例：
int* func()&#123;	int* a = new int(10);	return a;&#125;int main() &#123;	int *p = func();	cout &lt;&lt; *p &lt;&lt; endl;	cout &lt;&lt; *p &lt;&lt; endl;    	system(&quot;pause&quot;);	return 0;&#125;
总结：
堆区数据由程序员管理开辟和释放
堆区数据利用new关键字进行开辟内存
1.3 new操作符​    C++中利用new操作符在堆区开辟数据
​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete
​    语法：new 数据类型
​    利用new创建的数据，会返回该数据对应的类型的指针
示例1： 基本语法
int* func()&#123;	int* a = new int(10);	return a;&#125;int main() &#123;	int *p = func();	cout &lt;&lt; *p &lt;&lt; endl;	cout &lt;&lt; *p &lt;&lt; endl;	//利用delete释放堆区数据	delete p;	//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问	system(&quot;pause&quot;);	return 0;&#125;
示例2：开辟数组
//堆区开辟数组int main() &#123;	int* arr = new int[10];	for (int i = 0; i &lt; 10; i++)	&#123;		arr[i] = i + 100;	&#125;	for (int i = 0; i &lt; 10; i++)	&#123;		cout &lt;&lt; arr[i] &lt;&lt; endl;	&#125;	//释放数组 delete 后加 []	delete[] arr;	system(&quot;pause&quot;);	return 0;&#125;
2 引用2.1 引用的基本使用作用： 给变量起别名
语法： 数据类型 &amp;别名 = 原名
示例：
int main() &#123;	int a = 10;	int &amp;b = a;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;	b = 100;	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
2.2 引用注意事项
引用必须初始化
引用在初始化后，不可以改变

示例：
int main() &#123;	int a = 10;	int b = 20;	//int &amp;c; //错误，引用必须初始化	int &amp;c = a; //一旦初始化后，就不可以更改	c = b; //这是赋值操作，不是更改引用	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;	cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参
优点：可以简化指针修改实参
示例：
//1. 值传递void mySwap01(int a, int b) &#123;	int temp = a;	a = b;	b = temp;&#125;//2. 地址传递void mySwap02(int* a, int* b) &#123;	int temp = *a;	*a = *b;	*b = temp;&#125;//3. 引用传递void mySwap03(int&amp; a, int&amp; b) &#123;	int temp = a;	a = b;	b = temp;&#125;int main() &#123;	int a = 10;	int b = 20;	mySwap01(a, b);	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;	mySwap02(&amp;a, &amp;b);	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;	mySwap03(a, b);	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;

总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单

2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的
注意：不要返回局部变量引用
用法：函数调用作为左值
示例：
//返回局部变量引用int&amp; test01() &#123;	int a = 10; //局部变量	return a;&#125;//返回静态变量引用int&amp; test02() &#123;	static int a = 20;	return a;&#125;int main() &#123;	//不能返回局部变量的引用	int&amp; ref = test01();	cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;	cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;	//如果函数做左值，那么必须返回引用	int&amp; ref2 = test02();	cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;	cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;	test02() = 1000;	cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;	cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
​    
2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量.
讲解示例：
//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref)&#123;	ref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123;	int a = 10;        //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改	int&amp; ref = a; 	ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;    	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;	cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;    	func(a);	return 0;&#125;
结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了
2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作
在函数形参列表中，可以加const修饰形参，防止形参改变实参
示例：
//引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) &#123;	//v += 10;	cout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123;	//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误	//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;	const int&amp; ref = 10;	//ref = 100;  //加入const后不可以修改变量	cout &lt;&lt; ref &lt;&lt; endl;	//函数中利用常量引用防止误操作修改实参	int a = 10;	showValue(a);	system(&quot;pause&quot;);	return 0;&#125;
3 函数提高3.1 函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。
语法：返回值类型  函数名 （参数= 默认值）&#123;&#125;
示例：
int func(int a, int b = 10, int c = 10) &#123;	return a + b + c;&#125;//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a = 10, int b = 10);int func2(int a, int b) &#123;	return a + b;&#125;int main() &#123;	cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;	cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
3.2 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置
语法： 返回值类型 函数名 (数据类型)&#123;&#125;
在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术
示例：
//函数占位参数 ，占位参数也可以有默认参数void func(int a, int) &#123;	cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;&#125;int main() &#123;	func(10,10); //占位参数必须填补	system(&quot;pause&quot;);	return 0;&#125;
3.3 函数重载3.3.1 函数重载概述作用：函数名可以相同，提高复用性
函数重载满足条件：

同一个作用域下
函数名称相同
函数参数类型不同  或者 个数不同 或者 顺序不同

注意:  函数的返回值不可以作为函数重载的条件
示例：
//函数重载需要函数都在同一个作用域下void func()&#123;	cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;&#125;void func(int a)&#123;	cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a)&#123;	cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;&#125;void func(int a ,double b)&#123;	cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a ,int b)&#123;	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;&#125;//函数返回值不可以作为函数重载条件//int func(double a, int b)//&#123;//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;//&#125;int main() &#123;	func();	func(10);	func(3.14);	func(10,3.14);	func(3.14 , 10);		system(&quot;pause&quot;);	return 0;&#125;
3.3.2 函数重载注意事项
引用作为重载条件
函数重载碰到函数默认参数

示例：
//函数重载注意事项//1、引用作为重载条件void func(int &amp;a)&#123;	cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;void func(const int &amp;a)&#123;	cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;//2、函数重载碰到函数默认参数void func2(int a, int b = 10)&#123;	cout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl;&#125;void func2(int a)&#123;	cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;&#125;int main() &#123;		int a = 10;	func(a); //调用无const	func(10);//调用有const	//func2(10); //碰到默认参数产生歧义，需要避免	system(&quot;pause&quot;);	return 0;&#125;
4 类和对象C++面向对象的三大特性为：封装、继承、多态
C++认为万事万物都皆为对象，对象上有其属性和行为
例如：
​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…
​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…
​    具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类
4.1 封装4.1.1  封装的意义封装是C++面向对象三大特性之一
封装的意义：

将属性和行为作为一个整体，表现生活中的事物
将属性和行为加以权限控制

封装意义一：
​    在设计类的时候，属性和行为写在一起，表现事物
语法： class 类名&#123;   访问权限： 属性  / 行为  &#125;;
示例1：设计一个圆类，求圆的周长
示例代码：
//圆周率const double PI = 3.14;//1、封装的意义//将属性和行为作为一个整体，用来表现生活中的事物//封装一个圆类，求圆的周长//class代表设计一个类，后面跟着的是类名class Circle&#123;public:  //访问权限  公共的权限	//属性	int m_r;//半径	//行为	//获取到圆的周长	double calculateZC()	&#123;		//2 * pi  * r		//获取圆的周长		return  2 * PI * m_r;	&#125;&#125;;int main() &#123;	//通过圆类，创建圆的对象	// c1就是一个具体的圆	Circle c1;	c1.m_r = 10; //给圆对象的半径 进行赋值操作	//2 * pi * 10 = = 62.8	cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号
示例2代码：
//学生类class Student &#123;public:	void setName(string name) &#123;		m_name = name;	&#125;	void setID(int id) &#123;		m_id = id;	&#125;	void showStudent() &#123;		cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;	&#125;public:	string m_name;	int m_id;&#125;;int main() &#123;	Student stu;	stu.setName(&quot;德玛西亚&quot;);	stu.setID(250);	stu.showStudent();	system(&quot;pause&quot;);	return 0;&#125;
封装意义二：
类在设计时，可以把属性和行为放在不同的权限下，加以控制
访问权限有三种：

public        公共权限  
protected 保护权限  子类可以访问父类中的保护内容 
private      私有权限  子类不可以访问父类中的私有内容 

示例：
//三种权限//公共权限  public     类内可以访问  类外可以访问//保护权限  protected  类内可以访问  类外不可以访问//私有权限  private    类内可以访问  类外不可以访问class Person&#123;	//姓名  公共权限public:	string m_Name;	//汽车  保护权限protected:	string m_Car;	//银行卡密码  私有权限private:	int m_Password;public:	void func()	&#123;		m_Name = &quot;张三&quot;;		m_Car = &quot;拖拉机&quot;;		m_Password = 123456;	&#125;&#125;;int main() &#123;	Person p;	p.m_Name = &quot;李四&quot;;	//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到	//p.m_Password = 123; //私有权限类外访问不到	system(&quot;pause&quot;);	return 0;&#125;
4.1.2 struct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同
区别：

struct 默认权限为公共
class   默认权限为私有

class C1&#123;	int  m_A; //默认是私有权限&#125;;struct C2&#123;	int m_A;  //默认是公共权限&#125;;int main() &#123;	C1 c1;	c1.m_A = 10; //错误，访问权限是私有	C2 c2;	c2.m_A = 10; //正确，访问权限是公共	system(&quot;pause&quot;);	return 0;&#125;
4.1.3 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限
优点2：对于写权限，我们可以检测数据的有效性
示例：
class Person &#123;public:	//姓名设置可读可写	void setName(string name) &#123;		m_Name = name;	&#125;	string getName()	&#123;		return m_Name;	&#125;	//获取年龄 	int getAge() &#123;		return m_Age;	&#125;	//设置年龄	void setAge(int age) &#123;		if (age &lt; 0 || age &gt; 150) &#123;			cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;			return;		&#125;		m_Age = age;	&#125;	//情人设置为只写	void setLover(string lover) &#123;		m_Lover = lover;	&#125;private:	string m_Name; //可读可写  姓名		int m_Age; //只读  年龄	string m_Lover; //只写  情人&#125;;int main() &#123;	Person p;	//姓名设置	p.setName(&quot;张三&quot;);	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;	//年龄设置	p.setAge(50);	cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;	//情人设置	p.setLover(&quot;苍井&quot;);	//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取	system(&quot;pause&quot;);	return 0;&#125;
练习案例1：设计立方体类
设计立方体类(Cube)
求出立方体的面积和体积
分别用全局函数和成员函数判断两个立方体是否相等。

练习案例2：点和圆的关系
设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。

4.2 对象的初始化和清理
生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全
C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。

4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题
​    一个对象或者变量没有初始状态，对其使用后果是未知
​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题
c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。
对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供
编译器提供的构造函数和析构函数是空实现。

构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。

构造函数语法：类名()&#123;&#125;

构造函数，没有返回值也不写void
函数名称与类名相同
构造函数可以有参数，因此可以发生重载
程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

析构函数语法： ~类名()&#123;&#125;

析构函数，没有返回值也不写void
函数名称与类名相同,在名称前加上符号  ~
析构函数不可以有参数，因此不可以发生重载
程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

class Person&#123;public:	//构造函数	Person()	&#123;		cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;	&#125;	//析构函数	~Person()	&#123;		cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;	&#125;&#125;;void test01()&#123;	Person p;&#125;int main() &#123;		test01();	system(&quot;pause&quot;);	return 0;&#125;
4.2.2 构造函数的分类及调用两种分类方式：
​    按参数分为： 有参构造和无参构造
​    按类型分为： 普通构造和拷贝构造
三种调用方式：
​    括号法
​    显示法
​    隐式转换法
示例：
//1、构造函数分类// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person &#123;public:	//无参（默认）构造函数	Person() &#123;		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;	&#125;	//有参构造函数	Person(int a) &#123;		age = a;		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;	&#125;	//拷贝构造函数	Person(const Person&amp; p) &#123;		age = p.age;		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;	&#125;	//析构函数	~Person() &#123;		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;	&#125;public:	int age;&#125;;//2、构造函数的调用//调用无参构造函数void test01() &#123;	Person p; //调用无参构造函数&#125;//调用有参的构造函数void test02() &#123;	//2.1  括号法，常用	Person p1(10);	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明	//Person p2();	//2.2 显式法	Person p2 = Person(10); 	Person p3 = Person(p2);	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构	//2.3 隐式转换法	Person p4 = 10; // Person p4 = Person(10); 	Person p5 = p4; // Person p5 = Person(p4); 	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明	//Person p5(p4);&#125;int main() &#123;	test01();	//test02();	system(&quot;pause&quot;);	return 0;&#125;
4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况

使用一个已经创建完毕的对象来初始化一个新对象
值传递的方式给函数参数传值
以值方式返回局部对象

示例：
class Person &#123;public:	Person() &#123;		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;		mAge = 0;	&#125;	Person(int age) &#123;		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;		mAge = age;	&#125;	Person(const Person&amp; p) &#123;		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;		mAge = p.mAge;	&#125;	//析构函数在释放内存之前调用	~Person() &#123;		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;	&#125;public:	int mAge;&#125;;//1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() &#123;	Person man(100); //p对象已经创建完毕	Person newman(man); //调用拷贝构造函数	Person newman2 = man; //拷贝构造	//Person newman3;	//newman3 = man; //不是调用拷贝构造函数，赋值操作&#125;//2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) &#123;&#125;void test02() &#123;	Person p; //无参构造函数	doWork(p);&#125;//3. 以值方式返回局部对象Person doWork2()&#123;	Person p1;	cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;	return p1;&#125;void test03()&#123;	Person p = doWork2();	cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;&#125;int main() &#123;	//test01();	//test02();	test03();	system(&quot;pause&quot;);	return 0;&#125;
4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数
1．默认构造函数(无参，函数体为空)
2．默认析构函数(无参，函数体为空)
3．默认拷贝构造函数，对属性进行值拷贝
构造函数调用规则如下：

如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造


如果用户定义拷贝构造函数，c++不会再提供其他构造函数

示例：
class Person &#123;public:	//无参（默认）构造函数	Person() &#123;		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;	&#125;	//有参构造函数	Person(int a) &#123;		age = a;		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;	&#125;	//拷贝构造函数	Person(const Person&amp; p) &#123;		age = p.age;		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;	&#125;	//析构函数	~Person() &#123;		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;	&#125;public:	int age;&#125;;void test01()&#123;	Person p1(18);	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作	Person p2(p1);	cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;void test02()&#123;	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造	Person p1; //此时如果用户自己没有提供默认构造，会出错	Person p2(10); //用户提供的有参	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供	//如果用户提供拷贝构造，编译器不会提供其他构造函数	Person p4; //此时如果用户自己没有提供默认构造，会出错	Person p5(10); //此时如果用户自己没有提供有参，会出错	Person p6(p5); //用户自己提供拷贝构造&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑
浅拷贝：简单的赋值拷贝操作
深拷贝：在堆区重新申请空间，进行拷贝操作
示例：
class Person &#123;public:	//无参（默认）构造函数	Person() &#123;		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;	&#125;	//有参构造函数	Person(int age ,int height) &#123;				cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;		m_age = age;		m_height = new int(height);			&#125;	//拷贝构造函数  	Person(const Person&amp; p) &#123;		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题		m_age = p.m_age;		m_height = new int(*p.m_height);			&#125;	//析构函数	~Person() &#123;		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;		if (m_height != NULL)		&#123;			delete m_height;		&#125;	&#125;public:	int m_age;	int* m_height;&#125;;void test01()&#123;	Person p1(18, 180);	Person p2(p1);	cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;	cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;

总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

4.2.6 初始化列表作用：
C++提供了初始化列表语法，用来初始化属性
语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125;
示例：
class Person &#123;public:	////传统方式初始化	//Person(int a, int b, int c) &#123;	//	m_A = a;	//	m_B = b;	//	m_C = c;	//&#125;	//初始化列表方式初始化	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;	void PrintPerson() &#123;		cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;		cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;		cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;	&#125;private:	int m_A;	int m_B;	int m_C;&#125;;int main() &#123;	Person p(1, 2, 3);	p.PrintPerson();	system(&quot;pause&quot;);	return 0;&#125;
4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员
例如：
class A &#123;&#125;class B&#123;    A a；&#125;
B类中有对象A作为成员，A为对象成员
那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？
示例：
class Phone&#123;public:	Phone(string name)	&#123;		m_PhoneName = name;		cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;	&#125;	~Phone()	&#123;		cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;	&#125;	string m_PhoneName;&#125;;class Person&#123;public:	//初始化列表可以告诉编译器调用哪一个构造函数	Person(string name, string pName) :m_Name(name), m_Phone(pName)	&#123;		cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;	&#125;	~Person()	&#123;		cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;	&#125;	void playGame()	&#123;		cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;	&#125;	string m_Name;	Phone m_Phone;&#125;;void test01()&#123;	//当类中成员是其他类对象时，我们称该成员为 对象成员	//构造的顺序是 ：先调用对象成员的构造，再调用本类构造	//析构顺序与构造相反	Person p(&quot;张三&quot; , &quot;苹果X&quot;);	p.playGame();&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员
静态成员分为：

静态成员变量
所有对象共享同一份数据
在编译阶段分配内存
类内声明，类外初始化


静态成员函数
所有对象共享同一个函数
静态成员函数只能访问静态成员变量



示例1 ：静态成员变量
class Person&#123;	public:	static int m_A; //静态成员变量	//静态成员变量特点：	//1 在编译阶段分配内存	//2 类内声明，类外初始化	//3 所有对象共享同一份数据private:	static int m_B; //静态成员变量也是有访问权限的&#125;;int Person::m_A = 10;int Person::m_B = 10;void test01()&#123;	//静态成员变量两种访问方式	//1、通过对象	Person p1;	p1.m_A = 100;	cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;	Person p2;	p2.m_A = 200;	cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据	cout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;	//2、通过类名	cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;	//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
示例2：静态成员函数
class Person&#123;public:	//静态成员函数特点：	//1 程序共享一个函数	//2 静态成员函数只能访问静态成员变量		static void func()	&#123;		cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;		m_A = 100;		//m_B = 100; //错误，不可以访问非静态成员变量	&#125;	static int m_A; //静态成员变量	int m_B; // private:	//静态成员函数也是有访问权限的	static void func2()	&#123;		cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;	&#125;&#125;;int Person::m_A = 10;void test01()&#123;	//静态成员变量两种访问方式	//1、通过对象	Person p1;	p1.func();	//2、通过类名	Person::func();	//Person::func2(); //私有权限访问不到&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储
只有非静态成员变量才属于类的对象上
class Person &#123;public:	Person() &#123;		mA = 0;	&#125;	//非静态成员变量占对象空间	int mA;	//静态成员变量不占对象空间	static int mB; 	//函数也不占对象空间，所有函数共享一个函数实例	void func() &#123;		cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;	&#125;	//静态成员函数也不占对象空间	static void sfunc() &#123;	&#125;&#125;;int main() &#123;	cout &lt;&lt; sizeof(Person) &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的
每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码
那么问题是：这一块代码是如何区分那个对象调用自己的呢？
c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象
this指针是隐含每一个非静态成员函数内的一种指针
this指针不需要定义，直接使用即可
this指针的用途：

当形参和成员变量同名时，可用this指针来区分
在类的非静态成员函数中返回对象本身，可使用return *this

class Person&#123;public:	Person(int age)	&#123;		//1、当形参和成员变量同名时，可用this指针来区分		this-&gt;age = age;	&#125;	Person&amp; PersonAddPerson(Person p)	&#123;		this-&gt;age += p.age;		//返回对象本身		return *this;	&#125;	int age;&#125;;void test01()&#123;	Person p1(10);	cout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl;	Person p2(10);	p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);	cout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.3.3 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针
如果用到this指针，需要加以判断保证代码的健壮性
示例：
//空指针访问成员函数class Person &#123;public:	void ShowClassName() &#123;		cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;	&#125;	void ShowPerson() &#123;		if (this == NULL) &#123;			return;		&#125;		cout &lt;&lt; mAge &lt;&lt; endl;	&#125;public:	int mAge;&#125;;void test01()&#123;	Person * p = NULL;	p-&gt;ShowClassName(); //空指针，可以调用成员函数	p-&gt;ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.3.4 const修饰成员函数常函数：

成员函数后加const后我们称为这个函数为常函数
常函数内不可以修改成员属性
成员属性声明时加关键字mutable后，在常函数中依然可以修改

常对象：

声明对象前加const称该对象为常对象
常对象只能调用常函数

示例：
class Person &#123;public:	Person() &#123;		m_A = 0;		m_B = 0;	&#125;	//this指针的本质是一个指针常量，指针的指向不可修改	//如果想让指针指向的值也不可以修改，需要声明常函数	void ShowPerson() const &#123;		//const Type* const pointer;		//this = NULL; //不能修改指针的指向 Person* const this;		//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量		this-&gt;m_B = 100;	&#125;	void MyFunc() const &#123;		//mA = 10000;	&#125;public:	int m_A;	mutable int m_B; //可修改 可变的&#125;;//const修饰对象  常对象void test01() &#123;	const Person person; //常量对象  	cout &lt;&lt; person.m_A &lt;&lt; endl;	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量	//常对象访问成员函数	person.MyFunc(); //常对象不能调用const的函数&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private)
客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去
但是呢，你也可以允许你的好闺蜜好基友进去。
在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术
友元的目的就是让一个函数或者类 访问另一个类中私有成员
友元的关键字为  friend
友元的三种实现

全局函数做友元
类做友元
成员函数做友元

4.4.1 全局函数做友元class Building&#123;	//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容	friend void goodGay(Building * building);public:	Building()	&#123;		this-&gt;m_SittingRoom = &quot;客厅&quot;;		this-&gt;m_BedRoom = &quot;卧室&quot;;	&#125;public:	string m_SittingRoom; //客厅private:	string m_BedRoom; //卧室&#125;;void goodGay(Building * building)&#123;	cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;	cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;	Building b;	goodGay(&amp;b);&#125;int main()&#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.4.2 类做友元class Building;class goodGay&#123;public:	goodGay();	void visit();private:	Building *building;&#125;;class Building&#123;	//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容	friend class goodGay;public:	Building();public:	string m_SittingRoom; //客厅private:	string m_BedRoom;//卧室&#125;;Building::Building()&#123;	this-&gt;m_SittingRoom = &quot;客厅&quot;;	this-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;	building = new Building;&#125;void goodGay::visit()&#123;	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;	goodGay gg;	gg.visit();&#125;int main()&#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.4.3 成员函数做友元class Building;class goodGay&#123;public:	goodGay();	void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容	void visit2(); private:	Building *building;&#125;;class Building&#123;	//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容	friend void goodGay::visit();public:	Building();public:	string m_SittingRoom; //客厅private:	string m_BedRoom;//卧室&#125;;Building::Building()&#123;	this-&gt;m_SittingRoom = &quot;客厅&quot;;	this-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;	building = new Building;&#125;void goodGay::visit()&#123;	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void goodGay::visit2()&#123;	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;	//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;	goodGay  gg;	gg.visit();&#125;int main()&#123;    	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型
4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算
class Person &#123;public:	Person() &#123;&#125;;	Person(int a, int b)	&#123;		this-&gt;m_A = a;		this-&gt;m_B = b;	&#125;	//成员函数实现 + 号运算符重载	Person operator+(const Person&amp; p) &#123;		Person temp;		temp.m_A = this-&gt;m_A + p.m_A;		temp.m_B = this-&gt;m_B + p.m_B;		return temp;	&#125;public:	int m_A;	int m_B;&#125;;//全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;//	Person temp(0, 0);//	temp.m_A = p1.m_A + p2.m_A;//	temp.m_B = p1.m_B + p2.m_B;//	return temp;//&#125;//运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val)  &#123;	Person temp;	temp.m_A = p2.m_A + val;	temp.m_B = p2.m_B + val;	return temp;&#125;void test() &#123;	Person p1(10, 10);	Person p2(20, 20);	//成员函数方式	Person p3 = p2 + p1;  //相当于 p2.operaor+(p1)	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;	Person p4 = p3 + 10; //相当于 operator+(p3,10)	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;int main() &#123;	test();	system(&quot;pause&quot;);	return 0;&#125;

总结1：对于内置的数据类型的表达式的的运算符是不可能改变的
总结2：不要滥用运算符重载

4.5.2 左移运算符重载作用：可以输出自定义数据类型
class Person &#123;	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public:	Person(int a, int b)	&#123;		this-&gt;m_A = a;		this-&gt;m_B = b;	&#125;	//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果	//void operator&lt;&lt;(Person&amp; p)&#123;	//&#125;private:	int m_A;	int m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;	out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;	return out;&#125;void test() &#123;	Person p1(10, 20);	cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程&#125;int main() &#123;	test();	system(&quot;pause&quot;);	return 0;&#125;

总结：重载左移运算符配合友元可以实现输出自定义数据类型

4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据
class MyInteger &#123;	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);public:	MyInteger() &#123;		m_Num = 0;	&#125;	//前置++	MyInteger&amp; operator++() &#123;		//先++		m_Num++;		//再返回		return *this;	&#125;	//后置++	MyInteger operator++(int) &#123;		//先返回		MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；		m_Num++;		return temp;	&#125;private:	int m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;	out &lt;&lt; myint.m_Num;	return out;&#125;//前置++ 先++ 再返回void test01() &#123;	MyInteger myInt;	cout &lt;&lt; ++myInt &lt;&lt; endl;	cout &lt;&lt; myInt &lt;&lt; endl;&#125;//后置++ 先返回 再++void test02() &#123;	MyInteger myInt;	cout &lt;&lt; myInt++ &lt;&lt; endl;	cout &lt;&lt; myInt &lt;&lt; endl;&#125;int main() &#123;	test01();	//test02();	system(&quot;pause&quot;);	return 0;&#125;

总结： 前置递增返回引用，后置递增返回值

4.5.4 赋值运算符重载c++编译器至少给一个类添加4个函数

默认构造函数(无参，函数体为空)
默认析构函数(无参，函数体为空)
默认拷贝构造函数，对属性进行值拷贝
赋值运算符 operator=, 对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题
示例：
class Person&#123;public:	Person(int age)	&#123;		//将年龄数据开辟到堆区		m_Age = new int(age);	&#125;	//重载赋值运算符 	Person&amp; operator=(Person &amp;p)	&#123;		if (m_Age != NULL)		&#123;			delete m_Age;			m_Age = NULL;		&#125;		//编译器提供的代码是浅拷贝		//m_Age = p.m_Age;		//提供深拷贝 解决浅拷贝的问题		m_Age = new int(*p.m_Age);		//返回自身		return *this;	&#125;	~Person()	&#123;		if (m_Age != NULL)		&#123;			delete m_Age;			m_Age = NULL;		&#125;	&#125;	//年龄的指针	int *m_Age;&#125;;void test01()&#123;	Person p1(18);	Person p2(20);	Person p3(30);	p3 = p2 = p1; //赋值操作	cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;	cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;	cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123;	test01();	//int a = 10;	//int b = 20;	//int c = 30;	//c = b = a;	//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;	//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;	system(&quot;pause&quot;);	return 0;&#125;
4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作
示例：
class Person&#123;public:	Person(string name, int age)	&#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;;	bool operator==(Person &amp; p)	&#123;		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)		&#123;			return true;		&#125;		else		&#123;			return false;		&#125;	&#125;	bool operator!=(Person &amp; p)	&#123;		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)		&#123;			return false;		&#125;		else		&#123;			return true;		&#125;	&#125;	string m_Name;	int m_Age;&#125;;void test01()&#123;	//int a = 0;	//int b = 0;	Person a(&quot;孙悟空&quot;, 18);	Person b(&quot;孙悟空&quot;, 18);	if (a == b)	&#123;		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;	&#125;	if (a != b)	&#123;		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.5.6 函数调用运算符重载
函数调用运算符 ()  也可以重载
由于重载后使用的方式非常像函数的调用，因此称为仿函数
仿函数没有固定写法，非常灵活

示例：
class MyPrint&#123;public:	void operator()(string text)	&#123;		cout &lt;&lt; text &lt;&lt; endl;	&#125;&#125;;void test01()&#123;	//重载的（）操作符 也称为仿函数	MyPrint myFunc;	myFunc(&quot;hello world&quot;);&#125;class MyAdd&#123;public:	int operator()(int v1, int v2)	&#123;		return v1 + v2;	&#125;&#125;;void test02()&#123;	MyAdd add;	int ret = add(10, 10);	cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;	//匿名对象调用  	cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main() &#123;	test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
4.6  继承继承是面向对象三大特性之一
有些类与类之间存在特殊的关系，例如下图中：

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。
这个时候我们就可以考虑利用继承的技术，减少重复代码
4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同
接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处
普通实现：
//Java页面class Java &#123;public:	void header()	&#123;		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;	&#125;	void footer()	&#123;		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;	&#125;	void left()	&#123;		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;	&#125;	void content()	&#123;		cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;	&#125;&#125;;//Python页面class Python&#123;public:	void header()	&#123;		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;	&#125;	void footer()	&#123;		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;	&#125;	void left()	&#123;		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;	&#125;	void content()	&#123;		cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;	&#125;&#125;;//C++页面class CPP &#123;public:	void header()	&#123;		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;	&#125;	void footer()	&#123;		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;	&#125;	void left()	&#123;		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;	&#125;	void content()	&#123;		cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;	&#125;&#125;;void test01()&#123;	//Java页面	cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;	Java ja;	ja.header();	ja.footer();	ja.left();	ja.content();	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;	//Python页面	cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;	Python py;	py.header();	py.footer();	py.left();	py.content();	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;	//C++页面	cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;	CPP cp;	cp.header();	cp.footer();	cp.left();	cp.content();&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
继承实现：
//公共页面class BasePage&#123;public:	void header()	&#123;		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;	&#125;	void footer()	&#123;		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;	&#125;	void left()	&#123;		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;	&#125;&#125;;//Java页面class Java : public BasePage&#123;public:	void content()	&#123;		cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;	&#125;&#125;;//Python页面class Python : public BasePage&#123;public:	void content()	&#123;		cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;	&#125;&#125;;//C++页面class CPP : public BasePage&#123;public:	void content()	&#123;		cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;	&#125;&#125;;void test01()&#123;	//Java页面	cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;	Java ja;	ja.header();	ja.footer();	ja.left();	ja.content();	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;	//Python页面	cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;	Python py;	py.header();	py.footer();	py.left();	py.content();	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;	//C++页面	cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;	CPP cp;	cp.header();	cp.footer();	cp.left();	cp.content();&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：
继承的好处：可以减少重复的代码
class A : public B; 
A 类称为子类 或 派生类
B 类称为父类 或 基类
派生类中的成员，包含两大部分：
一类是从基类继承过来的，一类是自己增加的成员。
从基类继承过过来的表现其共性，而新增的成员体现了其个性。
4.6.2 继承方式继承的语法：class 子类 : 继承方式  父类
继承方式一共有三种：

公共继承
保护继承
私有继承


示例：
class Base1&#123;public: 	int m_A;protected:	int m_B;private:	int m_C;&#125;;//公共继承class Son1 :public Base1&#123;public:	void func()	&#123;		m_A; //可访问 public权限		m_B; //可访问 protected权限		//m_C; //不可访问	&#125;&#125;;void myClass()&#123;	Son1 s1;	s1.m_A; //其他类只能访问到公共权限&#125;//保护继承class Base2&#123;public:	int m_A;protected:	int m_B;private:	int m_C;&#125;;class Son2:protected Base2&#123;public:	void func()	&#123;		m_A; //可访问 protected权限		m_B; //可访问 protected权限		//m_C; //不可访问	&#125;&#125;;void myClass2()&#123;	Son2 s;	//s.m_A; //不可访问&#125;//私有继承class Base3&#123;public:	int m_A;protected:	int m_B;private:	int m_C;&#125;;class Son3:private Base3&#123;public:	void func()	&#123;		m_A; //可访问 private权限		m_B; //可访问 private权限		//m_C; //不可访问	&#125;&#125;;class GrandSon3 :public Son3&#123;public:	void func()	&#123;		//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到		//m_A;		//m_B;		//m_C;	&#125;&#125;;
4.6.3 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？
示例：
class Base&#123;public:	int m_A;protected:	int m_B;private:	int m_C; //私有成员只是被隐藏了，但是还是会继承下去&#125;;//公共继承class Son :public Base&#123;public:	int m_D;&#125;;void test01()&#123;	cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
利用工具查看：

打开工具窗口后，定位到当前CPP文件的盘符
然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名
效果如下图：


结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到

4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数
问题：父类和子类的构造和析构顺序是谁先谁后？
示例：
class Base &#123;public:	Base()	&#123;		cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;	&#125;	~Base()	&#123;		cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;	&#125;&#125;;class Son : public Base&#123;public:	Son()	&#123;		cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;	&#125;	~Son()	&#123;		cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;	&#125;&#125;;void test01()&#123;	//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反	Son s;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;

总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反

4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

访问子类同名成员   直接访问即可
访问父类同名成员   需要加作用域

示例：
class Base &#123;public:	Base()	&#123;		m_A = 100;	&#125;	void func()	&#123;		cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;	&#125;	void func(int a)	&#123;		cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;	&#125;public:	int m_A;&#125;;class Son : public Base &#123;public:	Son()	&#123;		m_A = 200;	&#125;	//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数	//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域	void func()	&#123;		cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;	&#125;public:	int m_A;&#125;;void test01()&#123;	Son s;	cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;	cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;	s.func();	s.Base::func();	s.Base::func(10);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return EXIT_SUCCESS;&#125;
总结：

子类对象可以直接访问到子类中同名成员
子类对象加作用域可以访问到父类同名成员
当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数

4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？
静态成员和非静态成员出现同名，处理方式一致

访问子类同名成员   直接访问即可
访问父类同名成员   需要加作用域

示例：
class Base &#123;public:	static void func()	&#123;		cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;	&#125;	static void func(int a)	&#123;		cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;	&#125;	static int m_A;&#125;;int Base::m_A = 100;class Son : public Base &#123;public:	static void func()	&#123;		cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;	&#125;	static int m_A;&#125;;int Son::m_A = 200;//同名成员属性void test01()&#123;	//通过对象访问	cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;	Son s;	cout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;	cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;	//通过类名访问	cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;	cout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;	cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;&#125;//同名成员函数void test02()&#123;	//通过对象访问	cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;	Son s;	s.func();	s.Base::func();	cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;	Son::func();	Son::Base::func();	//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问	Son::Base::func(100);&#125;int main() &#123;	//test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;

总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）

4.6.7 多继承语法C++允许一个类继承多个类
语法：class 子类 ：继承方式 父类1 ， 继承方式 父类2...
多继承可能会引发父类中有同名成员出现，需要加作用域区分
C++实际开发中不建议用多继承
示例：
class Base1 &#123;public:	Base1()	&#123;		m_A = 100;	&#125;public:	int m_A;&#125;;class Base2 &#123;public:	Base2()	&#123;		m_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确	&#125;public:	int m_A;&#125;;//语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123;public:	Son()	&#123;		m_C = 300;		m_D = 400;	&#125;public:	int m_C;	int m_D;&#125;;//多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01()&#123;	Son s;	cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;

总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域

4.6.8 菱形继承菱形继承概念：
​    两个派生类继承同一个基类
​    又有某个类同时继承者两个派生类
​    这种继承被称为菱形继承，或者钻石继承
典型的菱形继承案例：

菱形继承问题：

羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。

草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。


示例：
class Animal&#123;public:	int m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo   : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123;	SheepTuo st;	st.Sheep::m_Age = 100;	st.Tuo::m_Age = 200;	cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;	cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;	cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
利用虚继承可以解决菱形继承问题

4.7  多态4.7.1 多态的基本概念多态是C++面向对象三大特性之一
多态分为两类

静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名
动态多态: 派生类和虚函数实现运行时多态

静态多态和动态多态区别：

静态多态的函数地址早绑定  -  编译阶段确定函数地址
动态多态的函数地址晚绑定  -  运行阶段确定函数地址

下面通过案例进行讲解多态
class Animal&#123;public:	//Speak函数就是虚函数	//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。	virtual void speak()	&#123;		cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;	&#125;&#125;;class Cat :public Animal&#123;public:	void speak()	&#123;		cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;	&#125;&#125;;class Dog :public Animal&#123;public:	void speak()	&#123;		cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;	&#125;&#125;;//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal &amp; animal)&#123;	animal.speak();&#125;////多态满足条件： //1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象void test01()&#123;	Cat cat;	DoSpeak(cat);	Dog dog;	DoSpeak(dog);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：
多态满足条件

有继承关系
子类重写父类中的虚函数

多态使用条件

父类指针或引用指向子类对象

重写：函数返回值类型  函数名 参数列表 完全一致称为重写
4.7.2 多态案例一-计算器类案例描述：
分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类
多态的优点：

代码组织结构清晰
可读性强
利于前期和后期的扩展以及维护

示例：
//普通实现class Calculator &#123;public:	int getResult(string oper)	&#123;		if (oper == &quot;+&quot;) &#123;			return m_Num1 + m_Num2;		&#125;		else if (oper == &quot;-&quot;) &#123;			return m_Num1 - m_Num2;		&#125;		else if (oper == &quot;*&quot;) &#123;			return m_Num1 * m_Num2;		&#125;		//如果要提供新的运算，需要修改源码	&#125;public:	int m_Num1;	int m_Num2;&#125;;void test01()&#123;	//普通实现测试	Calculator c;	c.m_Num1 = 10;	c.m_Num2 = 10;	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;//多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator&#123;public :	virtual int getResult()	&#123;		return 0;	&#125;	int m_Num1;	int m_Num2;&#125;;//加法计算器class AddCalculator :public AbstractCalculator&#123;public:	int getResult()	&#123;		return m_Num1 + m_Num2;	&#125;&#125;;//减法计算器class SubCalculator :public AbstractCalculator&#123;public:	int getResult()	&#123;		return m_Num1 - m_Num2;	&#125;&#125;;//乘法计算器class MulCalculator :public AbstractCalculator&#123;public:	int getResult()	&#123;		return m_Num1 * m_Num2;	&#125;&#125;;void test02()&#123;	//创建加法计算器	AbstractCalculator *abc = new AddCalculator;	abc-&gt;m_Num1 = 10;	abc-&gt;m_Num2 = 10;	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;	delete abc;  //用完了记得销毁	//创建减法计算器	abc = new SubCalculator;	abc-&gt;m_Num1 = 10;	abc-&gt;m_Num2 = 10;	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;	delete abc;  	//创建乘法计算器	abc = new MulCalculator;	abc-&gt;m_Num1 = 10;	abc-&gt;m_Num2 = 10;	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;	delete abc;&#125;int main() &#123;	//test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;

总结：C++开发提倡利用多态设计程序架构，因为多态优点很多

4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容
因此可以将虚函数改为纯虚函数
纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;
当类中有了纯虚函数，这个类也称为抽象类
抽象类特点：

无法实例化对象
子类必须重写抽象类中的纯虚函数，否则也属于抽象类

示例：
class Base&#123;public:	//纯虚函数	//类中只要有一个纯虚函数就称为抽象类	//抽象类无法实例化对象	//子类必须重写父类中的纯虚函数，否则也属于抽象类	virtual void func() = 0;&#125;;class Son :public Base&#123;public:	virtual void func() 	&#123;		cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;	&#125;;&#125;;void test01()&#123;	Base * base = NULL;	//base = new Base; // 错误，抽象类无法实例化对象	base = new Son;	base-&gt;func();	delete base;//记得销毁&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.7.4 多态案例二-制作饮品案例描述：
制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料
利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶

示例：
//抽象制作饮品class AbstractDrinking &#123;public:	//烧水	virtual void Boil() = 0;	//冲泡	virtual void Brew() = 0;	//倒入杯中	virtual void PourInCup() = 0;	//加入辅料	virtual void PutSomething() = 0;	//规定流程	void MakeDrink() &#123;		Boil();		Brew();		PourInCup();		PutSomething();	&#125;&#125;;//制作咖啡class Coffee : public AbstractDrinking &#123;public:	//烧水	virtual void Boil() &#123;		cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;	&#125;	//冲泡	virtual void Brew() &#123;		cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;	&#125;	//倒入杯中	virtual void PourInCup() &#123;		cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;	&#125;	//加入辅料	virtual void PutSomething() &#123;		cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;	&#125;&#125;;//制作茶水class Tea : public AbstractDrinking &#123;public:	//烧水	virtual void Boil() &#123;		cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;	&#125;	//冲泡	virtual void Brew() &#123;		cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;	&#125;	//倒入杯中	virtual void PourInCup() &#123;		cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;	&#125;	//加入辅料	virtual void PutSomething() &#123;		cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;	&#125;&#125;;//业务函数void DoWork(AbstractDrinking* drink) &#123;	drink-&gt;MakeDrink();	delete drink;&#125;void test01() &#123;	DoWork(new Coffee);	cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;	DoWork(new Tea);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码
解决方式：将父类中的析构函数改为虚析构或者纯虚析构
虚析构和纯虚析构共性：

可以解决父类指针释放子类对象
都需要有具体的函数实现

虚析构和纯虚析构区别：

如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：
virtual ~类名()&#123;&#125;
纯虚析构语法：
virtual ~类名() = 0;
类名::~类名()&#123;&#125;
示例：
class Animal &#123;public:	Animal()	&#123;		cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;	&#125;	virtual void Speak() = 0;	//析构函数加上virtual关键字，变成虚析构函数	//virtual ~Animal()	//&#123;	//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;	//&#125;	virtual ~Animal() = 0;&#125;;Animal::~Animal()&#123;	cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125;//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public:	Cat(string name)	&#123;		cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;		m_Name = new string(name);	&#125;	virtual void Speak()	&#123;		cout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl;	&#125;	~Cat()	&#123;		cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;		if (this-&gt;m_Name != NULL) &#123;			delete m_Name;			m_Name = NULL;		&#125;	&#125;public:	string *m_Name;&#125;;void test01()&#123;	Animal *animal = new Cat(&quot;Tom&quot;);	animal-&gt;Speak();	//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏	//怎么解决？给基类增加一个虚析构函数	//虚析构函数就是用来解决通过父类指针释放子类对象	delete animal;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：
​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
​    3. 拥有纯虚析构函数的类也属于抽象类
4.7.6 多态案例三-电脑组装案例描述：
电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）
将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商
创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口
测试时组装三台不同的电脑进行工作
示例：
#include&lt;iostream&gt;using namespace std;//抽象CPU类class CPU&#123;public:	//抽象的计算函数	virtual void calculate() = 0;&#125;;//抽象显卡类class VideoCard&#123;public:	//抽象的显示函数	virtual void display() = 0;&#125;;//抽象内存条类class Memory&#123;public:	//抽象的存储函数	virtual void storage() = 0;&#125;;//电脑类class Computer&#123;public:	Computer(CPU * cpu, VideoCard * vc, Memory * mem)	&#123;		m_cpu = cpu;		m_vc = vc;		m_mem = mem;	&#125;	//提供工作的函数	void work()	&#123;		//让零件工作起来，调用接口		m_cpu-&gt;calculate();		m_vc-&gt;display();		m_mem-&gt;storage();	&#125;	//提供析构函数 释放3个电脑零件	~Computer()	&#123;		//释放CPU零件		if (m_cpu != NULL)		&#123;			delete m_cpu;			m_cpu = NULL;		&#125;		//释放显卡零件		if (m_vc != NULL)		&#123;			delete m_vc;			m_vc = NULL;		&#125;		//释放内存条零件		if (m_mem != NULL)		&#123;			delete m_mem;			m_mem = NULL;		&#125;	&#125;private:	CPU * m_cpu; //CPU的零件指针	VideoCard * m_vc; //显卡零件指针	Memory * m_mem; //内存条零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public:	virtual void calculate()	&#123;		cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;	&#125;&#125;;class IntelVideoCard :public VideoCard&#123;public:	virtual void display()	&#123;		cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;	&#125;&#125;;class IntelMemory :public Memory&#123;public:	virtual void storage()	&#123;		cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;	&#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public:	virtual void calculate()	&#123;		cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;	&#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public:	virtual void display()	&#123;		cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;	&#125;&#125;;class LenovoMemory :public Memory&#123;public:	virtual void storage()	&#123;		cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;	&#125;&#125;;void test01()&#123;	//第一台电脑零件	CPU * intelCpu = new IntelCPU;	VideoCard * intelCard = new IntelVideoCard;	Memory * intelMem = new IntelMemory;	cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;	//创建第一台电脑	Computer * computer1 = new Computer(intelCpu, intelCard, intelMem);	computer1-&gt;work();	delete computer1;	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;	//第二台电脑组装	Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;	computer2-&gt;work();	delete computer2;	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;	//第三台电脑组装	Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;	computer3-&gt;work();	delete computer3;&#125;
5 文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放
通过文件可以将数据持久化
C++中对文件操作需要包含头文件 &lt; fstream &gt;
文件类型分为两种：

文本文件     -  文件以文本的ASCII码形式存储在计算机中
二进制文件 -  文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们

操作文件的三大类:

ofstream：写操作
ifstream： 读操作
fstream ： 读写操作

5.1文本文件5.1.1写文件   写文件步骤如下：

包含头文件   
  #include 

创建流对象  
ofstream ofs;

打开文件
ofs.open(“文件路径”,打开方式);

写数据
ofs &lt;&lt; “写入的数据”;

关闭文件
ofs.close();
​


文件打开方式：




打开方式
解释




ios::in
为读文件而打开文件


ios::out
为写文件而打开文件


ios::ate
初始位置：文件尾


ios::app
追加方式写文件


ios::trunc
如果文件存在先删除，再创建


ios::binary
二进制方式




注意： 文件打开方式可以配合使用，利用|操作符
例如：用二进制方式写文件 ios::binary |  ios:: out
示例：
#include &lt;fstream&gt;void test01()&#123;	ofstream ofs;	ofs.open(&quot;test.txt&quot;, ios::out);	ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;	ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;	ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;	ofs.close();&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

文件操作必须包含头文件 fstream
读文件可以利用 ofstream  ，或者fstream类
打开文件时候需要指定操作文件的路径，以及打开方式
利用&lt;&lt;可以向文件中写数据
操作完毕，要关闭文件

5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多
读文件步骤如下：

包含头文件   
  #include 

创建流对象  
ifstream ifs;

打开文件并判断文件是否打开成功
ifs.open(“文件路径”,打开方式);

读数据
四种方式读取

关闭文件
ifs.close();


示例：
#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123;	ifstream ifs;	ifs.open(&quot;test.txt&quot;, ios::in);	if (!ifs.is_open())	&#123;		cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;		return;	&#125;	//第一种方式	//char buf[1024] = &#123; 0 &#125;;	//while (ifs &gt;&gt; buf)	//&#123;	//	cout &lt;&lt; buf &lt;&lt; endl;	//&#125;	//第二种	//char buf[1024] = &#123; 0 &#125;;	//while (ifs.getline(buf,sizeof(buf)))	//&#123;	//	cout &lt;&lt; buf &lt;&lt; endl;	//&#125;	//第三种	//string buf;	//while (getline(ifs, buf))	//&#123;	//	cout &lt;&lt; buf &lt;&lt; endl;	//&#125;	char c;	while ((c = ifs.get()) != EOF)	&#123;		cout &lt;&lt; c;	&#125;	ifs.close();&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

读文件可以利用 ifstream  ，或者fstream类
利用is_open函数可以判断文件是否打开成功
close 关闭文件 

5.2 二进制文件以二进制的方式对文件进行读写操作
打开方式要指定为 ios::binary
5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write
函数原型 ：ostream&amp; write(const char * buffer,int len);
参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数
示例：
#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:	char m_Name[64];	int m_Age;&#125;;//二进制文件  写文件void test01()&#123;	//1、包含头文件	//2、创建输出流对象	ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);		//3、打开文件	//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);	Person p = &#123;&quot;张三&quot;  , 18&#125;;	//4、写文件	ofs.write((const char *)&amp;p, sizeof(p));	//5、关闭文件	ofs.close();&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

文件输出流对象 可以通过write函数，以二进制方式写数据

5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read
函数原型：istream&amp; read(char *buffer,int len);
参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数
示例：
#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:	char m_Name[64];	int m_Age;&#125;;void test01()&#123;	ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);	if (!ifs.is_open())	&#123;		cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;	&#125;	Person p;	ifs.read((char *)&amp;p, sizeof(p));	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;

文件输入流对象 可以通过read函数，以二进制方式读数据

职工管理系统1、管理系统需求职工管理系统可以用来管理公司内所有员工的信息
本教程主要利用C++来实现一个基于多态的职工管理系统
公司中职工分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号、职工姓名、职工岗位、以及职责
普通员工职责：完成经理交给的任务
经理职责：完成老板交给的任务，并下发任务给员工
老板职责：管理公司所有事务
管理系统中需要实现的功能如下：

退出管理程序：退出当前管理系统


增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号
显示职工信息：显示公司内部所有职工的信息
删除离职职工：按照编号删除指定的职工
修改职工信息：按照编号修改职工个人信息
查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息
按照编号排序：按照职工编号，进行排序，排序规则由用户指定
清空所有文档：清空文件中记录的所有职工信息 （清空前需要再次确认，防止误删）

系统界面效果图如下：

需根据用户不同的选择，完成不同的功能！
2、创建项目创建项目步骤如下：

创建新项目
添加文件

2.1 创建项目打开vs2017后，点击创建新项目，创建新的C++项目

填写项目名称以及项目路径，点击确定

2.2 添加文件右键源文件，进行添加文件操作



至此，项目已创建完毕
3、创建管理类​    管理类负责的内容如下：

与用户的沟通菜单界面
对职工增删改查的操作
与文件的读写交互

3.1创建文件在头文件和源文件的文件夹下分别创建workerManager.h 和 workerManager.cpp文件

3.2 头文件实现在workerManager.h中设计管理类
代码如下：
#pragma once#include&lt;iostream&gt;using namespace std;class WorkerManager&#123;public:	//构造函数	WorkerManager();	//析构函数	~WorkerManager();&#125;;
3.3 源文件实现在workerManager.cpp中将构造和析构函数空实现补全
#include &quot;workerManager.h&quot;WorkerManager::WorkerManager()&#123;&#125;WorkerManager::~WorkerManager()&#123;&#125;
至此职工管理类以创建完毕
4、菜单功能功能描述：与用户的沟通界面
4.1 添加成员函数在管理类workerManager.h中添加成员函数  void Show_Menu();

4.2 菜单功能实现在管理类workerManager.cpp中实现  Show_Menu()函数
void WorkerManager::Show_Menu()&#123;	cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*********  欢迎使用职工管理系统！ **********&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  0.退出管理程序  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  1.增加职工信息  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  2.显示职工信息  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  3.删除离职职工  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  4.修改职工信息  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  5.查找职工信息  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  6.按照编号排序  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  7.清空所有文档  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl;	cout &lt;&lt; endl;&#125;
4.3 测试菜单功能在职工管理系统.cpp中测试菜单功能
代码：
#include&lt;iostream&gt;using namespace std;#include &quot;workerManager.h&quot;int main() &#123;	WorkerManager wm;	wm.Show_Menu();	system(&quot;pause&quot;);	return 0;&#125;
运行效果如图：

5、退出功能5.1  提供功能接口在main函数中提供分支选择，提供每个功能接口
代码：
int main() &#123;	WorkerManager wm;	int choice = 0;	while (true)	&#123;		//展示菜单		wm.Show_Menu();		cout &lt;&lt; &quot;请输入您的选择:&quot; &lt;&lt; endl;		cin &gt;&gt; choice;		switch (choice)		&#123;		case 0: //退出系统			break;		case 1: //添加职工			break;		case 2: //显示职工			break;		case 3: //删除职工			break;		case 4: //修改职工			break;		case 5: //查找职工			break;		case 6: //排序职工			break;		case 7: //清空文件			break;		default:			system(&quot;cls&quot;);			break;		&#125;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
5.2 实现退出功能在workerManager.h中提供退出系统的成员函数 void exitSystem();
在workerManager.cpp中提供具体的功能实现
void WorkerManager::exitSystem()&#123;	cout &lt;&lt; &quot;欢迎下次使用&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	exit(0);&#125;
5.3测试功能在main函数分支 0  选项中，调用退出程序的接口

运行测试效果如图：

6、创建职工类6.1 创建职工抽象类职工的分类为：普通员工、经理、老板
将三种职工抽象到一个类（worker）中,利用多态管理不同职工种类
职工的属性为：职工编号、职工姓名、职工所在部门编号
职工的行为为：岗位职责信息描述，获取岗位名称
头文件文件夹下  创建文件worker.h  文件并且添加如下代码：
#pragma once#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//职工抽象基类class Worker&#123;public:	//显示个人信息	virtual void showInfo() = 0;	//获取岗位名称	virtual string getDeptName() = 0;	int m_Id; //职工编号	string m_Name; //职工姓名	int m_DeptId; //职工所在部门名称编号&#125;;
6.2 创建普通员工类普通员工类继承职工抽象类，并重写父类中纯虚函数
在头文件和源文件的文件夹下分别创建employee.h 和 employee.cpp文件
employee.h中代码如下：
#pragma once #include&lt;iostream&gt;using namespace std;#include &quot;worker.h&quot;//员工类class Employee :public Worker&#123;public:	//构造函数	Employee(int id, string name, int dId);	//显示个人信息	virtual void showInfo();	//获取职工岗位名称	virtual string getDeptName();&#125;;
employee.cpp中代码如下：
#include &quot;employee.h&quot;Employee::Employee(int id, string name, int dId)&#123;	this-&gt;m_Id = id;	this-&gt;m_Name = name;	this-&gt;m_DeptId = dId;&#125;void Employee::showInfo()&#123;	cout &lt;&lt; &quot;职工编号： &quot; &lt;&lt; this-&gt;m_Id		&lt;&lt; &quot; \t职工姓名： &quot; &lt;&lt; this-&gt;m_Name		&lt;&lt; &quot; \t岗位：&quot; &lt;&lt; this-&gt;getDeptName()		&lt;&lt; &quot; \t岗位职责：完成经理交给的任务&quot; &lt;&lt; endl;&#125;string Employee::getDeptName()&#123;	return string(&quot;员工&quot;);&#125;
6.3 创建经理类经理类继承职工抽象类，并重写父类中纯虚函数，和普通员工类似
在头文件和源文件的文件夹下分别创建manager.h 和 manager.cpp文件
manager.h中代码如下：
#pragma once#include&lt;iostream&gt;using namespace std;#include &quot;worker.h&quot;//经理类class Manager :public Worker&#123;public:	Manager(int id, string name, int dId);	//显示个人信息	virtual void showInfo();	//获取职工岗位名称	virtual string getDeptName();&#125;;
manager.cpp中代码如下：
#include &quot;manager.h&quot;Manager::Manager(int id, string name, int dId)&#123;	this-&gt;m_Id = id;	this-&gt;m_Name = name;	this-&gt;m_DeptId = dId;&#125;void Manager::showInfo()&#123;	cout &lt;&lt; &quot;职工编号： &quot; &lt;&lt; this-&gt;m_Id		&lt;&lt; &quot; \t职工姓名： &quot; &lt;&lt; this-&gt;m_Name		&lt;&lt; &quot; \t岗位：&quot; &lt;&lt; this-&gt;getDeptName()		&lt;&lt; &quot; \t岗位职责：完成老板交给的任务,并下发任务给员工&quot; &lt;&lt; endl;&#125;string Manager::getDeptName()&#123;	return string(&quot;经理&quot;);&#125;
6.4 创建老板类老板类继承职工抽象类，并重写父类中纯虚函数，和普通员工类似
在头文件和源文件的文件夹下分别创建boss.h 和 boss.cpp文件
boss.h中代码如下：
#pragma once#include&lt;iostream&gt;using namespace std;#include &quot;worker.h&quot;//老板类class Boss :public Worker&#123;public:	Boss(int id, string name, int dId);	//显示个人信息	virtual void showInfo();	//获取职工岗位名称	virtual string getDeptName();&#125;;
boss.cpp中代码如下：
#include &quot;boss.h&quot;Boss::Boss(int id, string name, int dId)&#123;	this-&gt;m_Id = id;	this-&gt;m_Name = name;	this-&gt;m_DeptId = dId;&#125;void Boss::showInfo()&#123;	cout &lt;&lt; &quot;职工编号： &quot; &lt;&lt; this-&gt;m_Id		&lt;&lt; &quot; \t职工姓名： &quot; &lt;&lt; this-&gt;m_Name		&lt;&lt; &quot; \t岗位：&quot; &lt;&lt; this-&gt;getDeptName()		&lt;&lt; &quot; \t岗位职责：管理公司所有事务&quot; &lt;&lt; endl;&#125;string Boss::getDeptName()&#123;	return string(&quot;总裁&quot;);&#125;
6.5 测试多态在职工管理系统.cpp中添加测试函数，并且运行能够产生多态
测试代码如下：
#include &quot;worker.h&quot;#include &quot;employee.h&quot;#include &quot;manager.h&quot;#include &quot;boss.h&quot;void test()&#123;	Worker * worker = NULL;	worker = new Employee(1, &quot;张三&quot;, 1);	worker-&gt;showInfo();	delete worker;		worker = new Manager(2, &quot;李四&quot;, 2);	worker-&gt;showInfo();	delete worker;	worker = new Boss(3, &quot;王五&quot;, 3);	worker-&gt;showInfo();	delete worker;&#125;
运行效果如图：

测试成功后，测试代码可以注释保留，或者选择删除
7、添加职工功能描述：批量添加职工，并且保存到文件中
7.1 功能分析分析：
用户在批量创建时，可能会创建不同种类的职工
如果想将所有不同种类的员工都放入到一个数组中，可以将所有员工的指针维护到一个数组里
如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用Worker **的指针维护

7.2 功能实现在WokerManager.h头文件中添加成员属性 代码：
//记录文件中的人数个数int m_EmpNum;//员工数组的指针Worker ** m_EmpArray;
在WorkerManager构造函数中初始化属性
WorkerManager::WorkerManager()&#123;	//初始化人数	this-&gt;m_EmpNum = 0;	//初始化数组指针	this-&gt;m_EmpArray = NULL;&#125;
在workerManager.h中添加成员函数
//增加职工void Add_Emp();
workerManager.cpp中实现该函数
//增加职工void WorkerManager::Add_Emp()&#123;	cout &lt;&lt; &quot;请输入增加职工数量： &quot; &lt;&lt; endl;	int addNum = 0;	cin &gt;&gt; addNum;	if (addNum &gt; 0)	&#123;		//计算新空间大小		int newSize = this-&gt;m_EmpNum + addNum;		//开辟新空间		Worker ** newSpace = new Worker*[newSize];		//将原空间下内容存放到新空间下		if (this-&gt;m_EmpArray != NULL)		&#123;			for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)			&#123;				newSpace[i] = this-&gt;m_EmpArray[i];			&#125;		&#125;		//输入新数据		for (int i = 0; i &lt; addNum; i++)		&#123;			int id;			string name;			int dSelect;			cout &lt;&lt; &quot;请输入第 &quot; &lt;&lt; i + 1 &lt;&lt; &quot; 个新职工编号：&quot; &lt;&lt; endl;			cin &gt;&gt; id;			cout &lt;&lt; &quot;请输入第 &quot; &lt;&lt; i + 1 &lt;&lt; &quot; 个新职工姓名：&quot; &lt;&lt; endl;			cin &gt;&gt; name;			cout &lt;&lt; &quot;请选择该职工的岗位：&quot; &lt;&lt; endl;			cout &lt;&lt; &quot;1、普通职工&quot; &lt;&lt; endl;			cout &lt;&lt; &quot;2、经理&quot; &lt;&lt; endl;			cout &lt;&lt; &quot;3、老板&quot; &lt;&lt; endl;			cin &gt;&gt; dSelect;			Worker * worker = NULL;			switch (dSelect)			&#123;			case 1: //普通员工				worker = new Employee(id, name, 1);				break;			case 2: //经理				worker = new Manager(id, name, 2);				break;			case 3:  //老板				worker = new Boss(id, name, 3);				break;			default:				break;			&#125;			newSpace[this-&gt;m_EmpNum + i] = worker;		&#125;		//释放原有空间		delete[] this-&gt;m_EmpArray;		//更改新空间的指向		this-&gt;m_EmpArray = newSpace;		//更新新的个数		this-&gt;m_EmpNum = newSize;		//提示信息		cout &lt;&lt; &quot;成功添加&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工！&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
在WorkerManager.cpp的析构函数中，释放堆区数据
WorkerManager::~WorkerManager()&#123;	if (this-&gt;m_EmpArray != NULL)	&#123;		delete[] this-&gt;m_EmpArray;	&#125;&#125;
7.3 测试添加在main函数分支 1  选项中，调用添加职工接口

效果如图：

至此，添加职工到程序中功能实现完毕
8、文件交互 - 写文件功能描述：对文件进行读写
​    在上一个添加功能中，我们只是将所有的数据添加到了内存中，一旦程序结束就无法保存了
​    因此文件管理类中需要一个与文件进行交互的功能，对于文件进行读写操作
8.1 设定文件路径首先我们将文件路径，在workerManager.h中添加宏常量,并且包含头文件 fstream
#include &lt;fstream&gt;#define  FILENAME &quot;empFile.txt&quot;
8.2 成员函数声明在workerManager.h中类里添加成员函数 void save()
//保存文件void save();
8.3 保存文件功能实现void WorkerManager::save()&#123;	ofstream ofs;	ofs.open(FILENAME, ios::out);	for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)	&#123;		ofs &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; &quot; &quot; 			&lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; &quot; &quot; 			&lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;	&#125;	ofs.close();&#125;
8.4 保存文件功能测试在添加职工功能中添加成功后添加保存文件函数

再次运行代码，添加职工

同级目录下多出文件，并且保存了添加的信息

9、文件交互 - 读文件功能描述：将文件中的内容读取到程序中
虽然我们实现了添加职工后保存到文件的操作，但是每次开始运行程序，并没有将文件中数据读取到程序中
而我们的程序功能中还有清空文件的需求
因此构造函数初始化数据的情况分为三种

第一次使用，文件未创建
文件存在，但是数据被用户清空
文件存在，并且保存职工的所有数据

9.1 文件未创建在workerManager.h中添加新的成员属性 m_FileIsEmpty标志文件是否为空
//标志文件是否为空bool m_FileIsEmpty;
修改WorkerManager.cpp中构造函数代码
WorkerManager::WorkerManager()&#123;	ifstream ifs;	ifs.open(FILENAME, ios::in);	//文件不存在情况	if (!ifs.is_open())	&#123;		cout &lt;&lt; &quot;文件不存在&quot; &lt;&lt; endl; //测试输出		this-&gt;m_EmpNum = 0;  //初始化人数		this-&gt;m_FileIsEmpty = true; //初始化文件为空标志		this-&gt;m_EmpArray = NULL; //初始化数组		ifs.close(); //关闭文件		return;	&#125;&#125;
删除文件后，测试文件不存在时初始化数据功能
9.2 文件存在且数据为空在workerManager.cpp中的构造函数追加代码：
//文件存在，并且没有记录char ch;ifs &gt;&gt; ch;if (ifs.eof())&#123;	cout &lt;&lt; &quot;文件为空!&quot; &lt;&lt; endl;	this-&gt;m_EmpNum = 0;	this-&gt;m_FileIsEmpty = true;	this-&gt;m_EmpArray = NULL;	ifs.close();	return;&#125;
追加代码位置如图：

将文件创建后清空文件内容，并测试该情况下初始化功能
我们发现文件不存在或者为空清空 m_FileIsEmpty 判断文件是否为空的标志都为真，那何时为假？
成功添加职工后，应该更改文件不为空的标志
在void WorkerManager::Add_Emp()成员函数中添加：
//更新职工不为空标志this-&gt;m_FileIsEmpty = false;

9.3 文件存在且保存职工数据9.3.1 获取记录的职工人数在workerManager.h中添加成员函数 int get_EmpNum();
//统计人数int get_EmpNum();
workerManager.cpp中实现
int WorkerManager::get_EmpNum()&#123;	ifstream ifs;	ifs.open(FILENAME, ios::in);	int id;	string name;	int dId;	int num = 0;	while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)	&#123;        //记录人数		num++;	&#125;	ifs.close();	return num;&#125;
在workerManager.cpp构造函数中继续追加代码：
int num =  this-&gt;get_EmpNum();cout &lt;&lt; &quot;职工个数为：&quot; &lt;&lt; num &lt;&lt; endl;  //测试代码this-&gt;m_EmpNum = num;  //更新成员属性 
手动添加一些职工数据，测试获取职工数量函数


9.3.2 初始化数组根据职工的数据以及职工数据，初始化workerManager中的Worker ** m_EmpArray 指针
在WorkerManager.h中添加成员函数  void init_Emp();
//初始化员工void init_Emp();
在WorkerManager.cpp中实现
void WorkerManager::init_Emp()&#123;	ifstream ifs;	ifs.open(FILENAME, ios::in);	int id;	string name;	int dId;		int index = 0;	while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)	&#123;		Worker * worker = NULL;		//根据不同的部门Id创建不同对象		if (dId == 1)  // 1普通员工		&#123;			worker = new Employee(id, name, dId);		&#125;		else if (dId == 2) //2经理		&#123;			worker = new Manager(id, name, dId);		&#125;		else //总裁		&#123;			worker = new Boss(id, name, dId);		&#125;		//存放在数组中		this-&gt;m_EmpArray[index] = worker;		index++;	&#125;&#125;
在workerManager.cpp构造函数中追加代码
//根据职工数创建数组this-&gt;m_EmpArray = new Worker *[this-&gt;m_EmpNum];//初始化职工init_Emp();//测试代码for (int i = 0; i &lt; m_EmpNum; i++)&#123;	cout &lt;&lt; &quot;职工号： &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id		&lt;&lt; &quot; 职工姓名： &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name		&lt;&lt; &quot; 部门编号： &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl;&#125;
运行程序，测试从文件中获取的数据

至此初始化数据功能完毕，测试代码可以注释或删除掉！
10、显示职工功能描述：显示当前所有职工信息
10.1 显示职工函数声明在workerManager.h中添加成员函数  void Show_Emp();
//显示职工void Show_Emp();
10.2 显示职工函数实现在workerManager.cpp中实现成员函数 void Show_Emp();
//显示职工void WorkerManager::Show_Emp()&#123;	if (this-&gt;m_FileIsEmpty)	&#123;		cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;	&#125;	else	&#123;		for (int i = 0; i &lt; m_EmpNum; i++)		&#123;			//利用多态调用接口			this-&gt;m_EmpArray[i]-&gt;showInfo();		&#125;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
10.3 测试显示职工在main函数分支 2  选项中，调用显示职工接口

测试时分别测试 文件为空和文件不为空两种情况
测试效果：
测试1-文件不存在或者为空情况

测试2 - 文件存在且有记录情况

测试完毕，至此，显示所有职工信息功能实现
11、删除职工功能描述：按照职工的编号进行删除职工操作
11.1 删除职工函数声明在workerManager.h中添加成员函数  void Del_Emp();
//删除职工void Del_Emp();
11.2 职工是否存在函数声明很多功能都需要用到根据职工是否存在来进行操作如：删除职工、修改职工、查找职工
因此添加该公告函数，以便后续调用
在workerManager.h中添加成员函数  int IsExist(int id);
//按照职工编号判断职工是否存在,若存在返回职工在数组中位置，不存在返回-1int IsExist(int id);
11.3 职工是否存在函数实现在workerManager.cpp中实现成员函数 int IsExist(int id);
int WorkerManager::IsExist(int id)&#123;	int index = -1;	for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)	&#123;		if (this-&gt;m_EmpArray[i]-&gt;m_Id == id)		&#123;			index = i;			break;		&#125;	&#125;	return index;&#125;
11.4 删除职工函数实现在workerManager.cpp中实现成员函数 void Del_Emp();
//删除职工void WorkerManager::Del_Emp()&#123;	if (this-&gt;m_FileIsEmpty)	&#123;		cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;	&#125;	else	&#123;		//按职工编号删除		cout &lt;&lt; &quot;请输入想要删除的职工号：&quot; &lt;&lt; endl;		int id = 0;		cin &gt;&gt; id;		int index = this-&gt;IsExist(id);		if (index != -1)  //说明index上位置数据需要删除		&#123;			for (int i = index; i &lt; this-&gt;m_EmpNum - 1; i++)			&#123;				this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[i + 1];			&#125;			this-&gt;m_EmpNum--;			this-&gt;save(); //删除后数据同步到文件中			cout &lt;&lt; &quot;删除成功！&quot; &lt;&lt; endl;		&#125;		else		&#123;			cout &lt;&lt; &quot;删除失败，未找到该职工&quot; &lt;&lt; endl;		&#125;	&#125;		system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
11.5 测试删除职工在main函数分支 3  选项中，调用删除职工接口

测试1 - 删除不存在职工情况

测试2 - 删除存在的职工情况
删除成功提示图：

再次显示所有职工信息，确保已经删除

查看文件中信息，再次核实员工已被完全删除

至此，删除职工功能实现完毕！
12、修改职工功能描述：能够按照职工的编号对职工信息进行修改并保存
12.1 修改职工函数声明在workerManager.h中添加成员函数  void Mod_Emp();
//修改职工void Mod_Emp();
12.2 修改职工函数实现在workerManager.cpp中实现成员函数 void Mod_Emp();
//修改职工void WorkerManager::Mod_Emp()&#123;	if (this-&gt;m_FileIsEmpty)	&#123;		cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;请输入修改职工的编号：&quot; &lt;&lt; endl;		int id;		cin &gt;&gt; id;		int ret = this-&gt;IsExist(id);		if (ret != -1)		&#123; 			//查找到编号的职工			delete this-&gt;m_EmpArray[ret];						int newId = 0;			string newName = &quot;&quot;;			int dSelect = 0;			cout &lt;&lt; &quot;查到： &quot; &lt;&lt; id &lt;&lt; &quot;号职工，请输入新职工号： &quot; &lt;&lt; endl;			cin &gt;&gt; newId;			cout &lt;&lt; &quot;请输入新姓名： &quot; &lt;&lt; endl;			cin &gt;&gt; newName;			cout &lt;&lt; &quot;请输入岗位： &quot; &lt;&lt; endl;			cout &lt;&lt; &quot;1、普通职工&quot; &lt;&lt; endl;			cout &lt;&lt; &quot;2、经理&quot; &lt;&lt; endl;			cout &lt;&lt; &quot;3、老板&quot; &lt;&lt; endl;			cin &gt;&gt; dSelect;			Worker * worker = NULL;			switch (dSelect)			&#123;			case1:				worker = new Employee(newId, newName, dSelect);				break;			case2:				worker = new Manager(newId, newName, dSelect);				break;			case 3:				worker = new Boss(newId, newName, dSelect);				break;			default:				break;			&#125;			//更改数据 到数组中			this-&gt;m_EmpArray[ret]= worker;						cout &lt;&lt; &quot;修改成功！&quot; &lt;&lt; endl;			//保存到文件中			this-&gt;save();		&#125;		else		&#123;			cout &lt;&lt; &quot;修改失败，查无此人&quot; &lt;&lt; endl;		&#125;	&#125;	//按任意键 清屏	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
12.3 测试修改职工在main函数分支 4  选项中，调用修改职工接口

测试1 - 修改不存在职工情况

测试2 - 修改存在职工情况，例如将职工 “李四” 改为 “赵四”

修改后再次查看所有职工信息，并确认修改成功

再次确认文件中信息也同步更新

至此，修改职工功能已实现！
13、查找职工功能描述：提供两种查找职工方式，一种按照职工编号，一种按照职工姓名
13.1 查找职工函数声明在workerManager.h中添加成员函数  void Find_Emp();
//查找职工void Find_Emp();
13.2 查找职工函数实现在workerManager.cpp中实现成员函数 void Find_Emp();
//查找职工void WorkerManager::Find_Emp()&#123;	if (this-&gt;m_FileIsEmpty)	&#123;		cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;请输入查找的方式：&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;1、按职工编号查找&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;2、按姓名查找&quot; &lt;&lt; endl;		int select = 0;		cin &gt;&gt; select;		if (select == 1) //按职工号查找		&#123;			int id;			cout &lt;&lt; &quot;请输入查找的职工编号：&quot; &lt;&lt; endl;			cin &gt;&gt; id;			int ret = IsExist(id);			if (ret != -1)			&#123;				cout &lt;&lt; &quot;查找成功！该职工信息如下：&quot; &lt;&lt; endl;				this-&gt;m_EmpArray[ret]-&gt;showInfo();			&#125;			else			&#123;				cout &lt;&lt; &quot;查找失败，查无此人&quot; &lt;&lt; endl;			&#125;		&#125;		else if(select == 2) //按姓名查找		&#123;			string name;			cout &lt;&lt; &quot;请输入查找的姓名：&quot; &lt;&lt; endl;			cin &gt;&gt; name;			bool flag = false;  //查找到的标志			for (int i = 0; i &lt; m_EmpNum; i++)			&#123;				if (m_EmpArray[i]-&gt;m_Name == name)				&#123;					cout &lt;&lt; &quot;查找成功,职工编号为：&quot;                           &lt;&lt; m_EmpArray[i]-&gt;m_Id                           &lt;&lt; &quot; 号的信息如下：&quot; &lt;&lt; endl;										flag = true;					this-&gt;m_EmpArray[i]-&gt;showInfo();				&#125;			&#125;			if (flag == false)			&#123;				//查无此人				cout &lt;&lt; &quot;查找失败，查无此人&quot; &lt;&lt; endl;			&#125;		&#125;		else		&#123;			cout &lt;&lt; &quot;输入选项有误&quot; &lt;&lt; endl;		&#125;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
13.3 测试查找职工在main函数分支 5  选项中，调用查找职工接口

测试1 - 按照职工编号查找 - 查找不存在职工

测试2 - 按照职工编号查找 -  查找存在职工

测试3 - 按照职工姓名查找 - 查找不存在职工

测试4 - 按照职工姓名查找 - 查找存在职工（如果出现重名，也一并显示，在文件中可以添加重名职工）
例如 添加两个王五的职工，然后按照姓名查找王五


至此，查找职工功能实现完毕！
14、排序功能描述：按照职工编号进行排序，排序的顺序由用户指定
14.1 排序函数声明在workerManager.h中添加成员函数  void Sort_Emp();
//排序职工void Sort_Emp();
14.2 排序函数实现在workerManager.cpp中实现成员函数 void Sort_Emp();
//排序职工void WorkerManager::Sort_Emp()&#123;	if (this-&gt;m_FileIsEmpty)	&#123;		cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl;		system(&quot;pause&quot;);		system(&quot;cls&quot;);	&#125;	else	&#123;		cout &lt;&lt; &quot;请选择排序方式： &quot; &lt;&lt; endl;		cout &lt;&lt; &quot;1、按职工号进行升序&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;2、按职工号进行降序&quot; &lt;&lt; endl;		int select = 0;		cin &gt;&gt; select;		for (int i = 0; i &lt; m_EmpNum; i++)		&#123;			int minOrMax = i;			for (int j = i + 1; j &lt; m_EmpNum; j++)			&#123;				if (select == 1) //升序				&#123;					if (m_EmpArray[minOrMax]-&gt;m_Id &gt; m_EmpArray[j]-&gt;m_Id)					&#123;						minOrMax = j;					&#125;				&#125;				else  //降序				&#123;					if (m_EmpArray[minOrMax]-&gt;m_Id &lt; m_EmpArray[j]-&gt;m_Id)					&#123;						minOrMax = j;					&#125;				&#125;			&#125;			if (i != minOrMax)			&#123;				Worker * temp = m_EmpArray[i];				m_EmpArray[i] = m_EmpArray[minOrMax];				m_EmpArray[minOrMax] = temp;			&#125;		&#125;		cout &lt;&lt; &quot;排序成功,排序后结果为：&quot; &lt;&lt; endl;		this-&gt;save();		this-&gt;Show_Emp();	&#125;&#125;
14.3 测试排序功能在main函数分支 6  选项中，调用排序职工接口

测试：
首先我们添加一些职工，序号是无序的，例如：

测试 - 升序排序

文件同步更新

测试 - 降序排序

文件同步更新

至此，职工按照编号排序的功能实现完毕！
15、清空文件功能描述：将文件中记录数据清空
15.1 清空函数声明在workerManager.h中添加成员函数  void Clean_File();
//清空文件void Clean_File();
15.2 清空函数实现在workerManager.cpp中实现员函数 void Clean_File();
//清空文件void WorkerManager::Clean_File()&#123;	cout &lt;&lt; &quot;确认清空？&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;1、确认&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;2、返回&quot; &lt;&lt; endl;	int select = 0;	cin &gt;&gt; select;	if (select == 1)	&#123;		//打开模式 ios::trunc 如果存在删除文件并重新创建		ofstream ofs(FILENAME, ios::trunc);		ofs.close();		if (this-&gt;m_EmpArray != NULL)		&#123;            for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)			&#123;				if (this-&gt;m_EmpArray[i] != NULL)				&#123;					delete this-&gt;m_EmpArray[i];				&#125;			&#125;			this-&gt;m_EmpNum = 0;			delete[] this-&gt;m_EmpArray;			this-&gt;m_EmpArray = NULL;			this-&gt;m_FileIsEmpty = true;		&#125;		cout &lt;&lt; &quot;清空成功！&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
15.3 测试清空文件在main函数分支 7  选项中，调用清空文件接口

测试：确认清空文件

再次查看文件中数据，记录已为空

打开文件，里面数据已确保清空，该功能需要慎用！

随着清空文件功能实现，本案例制作完毕  ^ _ ^  
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Deconfuse Track总结</title>
    <url>/2024/04/08/DeconfuseTrack%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[贴一个原文链接
很可惜这篇文章的代码没有开源

Abstract在多目标跟踪中，准确的数据关联十分重要，但是现有的方法大多进行简单的全局数据关联，忽略了轨迹的多样性以及外观线索存在的冲突性，导师检测-轨迹对存在混淆。为了解决这一问题，作者提出了一个简单、即插即用的数据关联方法，称为分解数据关联（DDA），此外还引入了遮挡感知的非极大值抑制（ONMS）来保留更多遮挡检测。基于这两种方法提出了DeconfuseTrack。
Introduction近年来大多数MOT方法都遵循TbD范式。在该范式中，数据关联建立轨迹与跟踪之间的的对应关系实现匹配。为了实现数据关联的准确性，许多方法引入额外的线索作为运动线索的补充。包括外观线索、深度信息、置信度分数、运动方向、自然语言信息等等，这些额外的线索可以一定程度上缓解运动线索的模糊，但是传统的数据关联具有一定的局限性。

图1(a)展示了全局关联导致的混乱，针对这些问题，文章提出了DecofuseTrack。将全局问题分解为多个子问题，包括单个轨迹与多个检测之间的关联、多个轨迹与单个检测之间的关联以及多个轨迹与多个检测之间的关联，并且将外观线索的使用限制在一定范围，仅在子问题中运动线索的判别力不足时补充外观线索，尽量减少对运动线索的干扰。
 如图1(b)所示，通过检测消歧模块(DDM)，我们识别出虽然不可靠，但更适合轨迹1的检测1，从而释放出检测2。利用轨迹消歧模块(TDM)，我们在轨迹3和轨迹4之间做出正确的选择，用于检测3。
通过关联消歧模块(ADM)，我们避免了轨迹5和轨迹6之间的关联混淆。其次，为了提高检测性能并减轻因遗漏检测而引起的混淆，我们设计了遮挡感知非最大抑制(ONMS)来保留更多的遮挡检测进行关联。
完整的模型结构如图所示：
MethodNotation类似于ByteTrack，将检测分为两类 $D_{first}^{t}$ 和 $D_{second}^{t}$ 用于第一轮和第二轮的数据关联。
Decomposed Data Association (DDA)利用卡尔曼滤波预测每个轨迹T的位置：$L$ = {$ l $ $_j$ = $(x,y,w,h)$ | $j$ $\in$ $\Bbb T$ }。$d_i$ 和 $T_j$ 的位置相似性用检测和轨迹之间的IoU来表示：

\begin{aligned}
LocSim ( d_i , \cal{T}_j ) = \mathit{IoU} ( d_i , T_j ) .
\end{aligned}代价公式如下：

\begin{aligned}
C_{ij} =1- LocSim ( d_i , \cal{T}_j ) , d_i \in \mathit{D}_{first}^t, \cal{T}_i \in \Bbb T.
\end{aligned}最后利用匈牙利算法求解 $C$，得到分配结果

\begin{aligned}
 P = \lbrace{(d, \cal{T}) | d \in \mathit{D}_{matched}^t, \cal{T} \in \Bbb T_{matched}}\rbrace. 
\end{aligned}以往的方法会直接输出匹配的结果，但是这种全局的关联过于模糊粗糙，因此需要细化 $P$ ，实现更加细粒度的分配。
Detection Disambiguation Module (DDM)DDM旨在解决多个检测与单一轨迹之间的混淆问题。
将低置信度中与 $\cal{T}_j$ 匹配度更高的 $d_i$ 定义为 $D_{blur}$ ，表示可能该轨迹存在更适合的低置信度检测。

\begin{aligned}
D_{blur}^j = \lbrace d_i | LocSim ( d_i , \cal{T}_j ) - \mathit{LocSim} ( d_j , \cal{T}_j ) > \kappa , \\ d_i \in D_{second}^t, d_j \in D_{matched}^t, \cal{T} \in \Bbb T_{matched} \rbrace.
\end{aligned}接下来定义 $P_{new}$ :

\begin{aligned}
P_{new} =  \lbrace (d_i, \cal{T}_j) | d = \mathop{argmax}\limits_{d_i \in D_{blur}^t}LocSim(d_i, \cal{T}_j) \\  if  D_{blur}^t \neq \emptyset , d_j \in D_{matched}^t, \cal{T} \in \Bbb T_{matched} \rbrace .
\end{aligned}将与轨迹匹配的低置信度检测移到 $D_{first}$ 里面，并在 $D_{second}$ 里将其删除。

\begin{aligned}
D^{t}_{first}{'} =  D_{first}^{t}  \cup \lbrace (d, \cal{T}) \in \mathit{P_{new}}  \rbrace 
\\ D^{t}_{second}{'} =  D_{second}^{t} - \lbrace (d, \cal{T}) \in \mathit{P_{new}} \rbrace .
\end{aligned}获得 $P_{new}$ 后，释放 $P$ 中的一些可靠检测，因为它们虽然被更合适的不可靠检测所取代，但这些不匹配的可靠检测仍然有可能与不匹配的轨迹相关联。因此，在最后一步，在保证 $P_{new}$ 中赋值关系有效性的前提下，首先对 $T$ 和 $D_t$ 进行重新赋值，得到检测消歧后新的分配关系 $P_{ddm}$ 。
Trajectory Disambiguation Module (TDM)这个模块将多个轨迹与单一检测进行匹配。
首先 $\Bbb T_{lost}$ = $\Bbb T - \Bbb T_{matched} $

\begin{aligned}
T_{blur}^j = \lbrace \cal{T}_i | \mathit{LocSim} ( d_j , \cal{T}_j ) - \mathit{LocSim} ( d_j , \cal{T}_i ) < \kappa , \\ \cal T_i \in  \Bbb T_{lost} , d_j \in D_{matched}^t, \cal{T}_j \in \Bbb T_{matched} \rbrace \cup \cal{T}_j.
\end{aligned}接下来采用外观模型实现更加精确的分配：

\begin{aligned}
T_{best}^j = \mathop{argmin}\limits_{\cal{T} \in \Bbb{T}_{blur}^j} CostDist(f_d, f_{\cal{T}}).
\end{aligned}其中 $CostDist(\cdot{})$ 表示余弦距离，最后得到轨迹消歧后的新分配关系:

\begin{aligned}
P_{tdm} = \lbrace (d_j , \cal{T}_{best}^j) | d_j \in \mathit{D}_{matched}^t \rbrace. 
\end{aligned}Association Disambiguation Module (ADM)在这个模块处理多个轨迹和多个检测关联的混淆问题。可以分为多个二对二的问题解决。对于配对中任意两个不同的任务，使用变异系数来量化他们之间的混淆：

\begin{aligned}
Cv(i,j) =  \frac{Std(\lbrace LocSim(d_{k_1}, \cal{T}_{k_2}|k_1,k_2 \in \lbrace i,j \rbrace \rbrace) )}{Mean(\lbrace LocSim(d_{k_1}, \cal{T}_{k_2}|k_1,k_2 \in \lbrace i,j \rbrace \rbrace) )}, \\ d_i,d_j \in D_{matched}^t, \cal{T}_i,\cal{T}_j \in \Bbb T_{matched} ,i \neq j .
\end{aligned}变异系数较小时，说明分配对之间的位置线索差异不大。接下来，我们识别所有表现出强烈混淆的配对:

\begin{aligned}
P_{blur} = \lbrace (d_i , \cal{T}_i), (d_j , \cal{T}_j) | Cv(i,j) < \kappa. \rbrace
\end{aligned}接下来，类似于TDM，我们利用外观线索来解决Pblur中的位置混淆，并找到更合适的分配关系:

\begin{aligned}
P_{new} = &\lbrace (d_i , \cal{T}_j), (d_j , \cal{T}_i) | \mathit{CostDist}(f_{d_i}, f_{\cal{T}_j})\\+&\mathit{CostDist}(f_{d_j}, f_{\cal{T}_i}) < \mathit{CostDist}(f_{d_i}, f_{\cal{T}_i})\\+&\mathit{CostDist}(f_{d_j}, f_{\cal{T}_j}), (d_i,\cal T_i), (d_j,\cal T_j)\in \mathit{P}_{blur}. \rbrace
\end{aligned}在涉及多个检测和轨迹交叉关联的复杂匹配过程中，可能会产生冲突。为了解决这些冲突，我们再次使用外观线索执行匈牙利匹配算法来消除 $P_{new}$ 中的冲突。最后，将修正后的赋值关系 $P_{new}$ 与原集合 $P$ 结合，得到关联消歧后的新匹配关系 $P_{adm}$ 。
Module Combination 三个模型可以串行组合，得到完整的DDA。所有三个模块共用参数 $\kappa$ ,当 $\kappa$ 增加时，我们在TDM和ADM中考虑更多的混淆，而在DDM中考虑更少的不可靠检测。因此， $\kappa$ 值越大表明对位置线索的依赖程度越低，而 $\kappa$ 值越小表明对运动线索的依赖程度越高。 $\kappa$ 的值可以根据数据集中摄像机和被跟踪对象的运动特征灵活调整。
Occlusion-aware NMS (ONMS)该模块用于提高检测的质量。$u^t$ 表示置信度大于 $d_i$ 的检测中IoU最大的检测:

\begin{aligned}
u_i^t =   \mathop{max}\limits_{d_j^t \in \lbrace d^t | c^t > c_i^t, d^tb \in D^t \rbrace } IoU(d_i^t,d_j^t).
\end{aligned}如图3显示，传统的跟踪器设置了置信阈值 $\eta_{conf}$ 和NMS阈值  $\eta_{nms}$ ，仅仅保留置信值在这两个之间的检测，然而这种方法放弃了许多正确的检测。ByteTrack通过设置两个置信阈值 $\eta_{conf}^{first}$ 、$\eta_{conf}^{second}$ 将检测分为两组，并执行两段关联。但是作者认为仍有改进的余地，设置了两个NMS阈值 $\eta_{NMS}^{first}$ 、$\eta_{NMS}^{second}$，以便为数据关联保留更多的检测：

\begin{aligned}
D_{first}^t = \lbrace d^t | d^t \in D^t, c^t \ge \eta_{conf}^{first},u^t \le \eta_{nms}^{first} \rbrace\\D_{second}^t = \lbrace d^t | d^t \in D^t, \eta_{conf}^{first} \gt c^t \ge \eta_{conf}^{second},u^t \le \eta_{nms}^{first} \rbrace \\ \cup \lbrace d^t | d^t \in D^t, c^t \ge \eta_{conf}^{first}, \eta_{nms}^{first} \lt u^t \le \eta_{nms}^{second} \rbrace 
\end{aligned}DeconfuseTrack通过结合ONMS和DDA，提出了Deconfuse Track，专门解决数据混淆的问题。
Experiments

]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简单使用说明</title>
    <url>/2025/06/13/Git%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[Git简单使用说明参考了这个博客，下文内容都是本地仓库使用的说明，远程仓库的使用后续补充
该博客由浅入深，十分推荐参考学习
什么是GitGit是目前世界上最先进的分布式版本控制系统，主要用于跟踪文件变化，管理软件开发中分写作和版本迭代，有Linus于2005年为Linux内核开发（这段历史蛮有意思的，感兴趣可以去找找看），使用C语言编写，是目前全球最主流的代码管理工具之一。
核心概念
工作区：本地磁盘中实际编辑的文件目录。
暂存区（Index/Stage）：临时存放待提交修改的区域，可选择性提交部分文件。
本地仓库：存储所有历史版本和分支数据的本地数据库。
远程仓库：托管在服务器上的共享版本库（如 GitHub），用于团队协作和代码共享。

安装GitLinux系统sudo apt install git
macOS系统先安装包管理器HomeBrew，然后通过Homebrew安装Git：
brew install git
Windows系统直接从Git官网下载安装程序，按照默认选项安装即可。安装完成后，可以在开始菜单找到Git -&gt; Git Bash，就说明安装成功了。
配置Git安装好后需要一步设置，在命令行输入：
git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot;
创建仓库前期工作准备完成后就可以愉快的开始进入使用阶段，首先就是创建仓库（Repository），经常浏览Github，对这个应该都不陌生，简单理解就是一个目录，目录中的所有文件都可以被Git管理。
创建仓库非常简单，首先选择一个合适的地方创建空目录(或者可以直接在本地已有的项目文件夹创建仓库)：
mkdir your/pathcd your/path
第二步：
git init
这样一个仓库就创建好了，当前目录下就会多一个.git目录，这个目录是Git来跟踪管理版本库的。
添加文件到版本库这里要注意，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。但是图片、视频这种二进制文件就无法追踪文件变化了。
言归正传，对文件进行改动或者添加新文件后，需要把文件添加到暂存区，使用
git add &lt;youfile&gt;
也可以直接一键添加所有有改动的文件
git add -A
然后把文件提交到仓库，这里可以添加本次提交的说明，这样可以更方便的找到改动记录：
git commit -m &quot;your message&quot;
文件管理查看修改提交了文件后，可能会对文件进行再次修改，这时可以运行git status命令，会显示哪些文件被改动了。git diff命令可以查看某个文件具体修改了什么内容。
版本回退多次修改文件后，如果想回退回某个历史版本就需要用到以下命令：
git log  //显示从最近到最远的提交日志git reset --hard HEAD^  //有几个^ 就表示回退几个版本这里的hard表示回退到上个版本的已提交状态，soft表示回退到上个版本的未提交状态，mixed表示四回退到上个版本已添加但未提交的状态git reset --hard &lt;commit id&gt;  //回退到指定版本git reflog  //记录每一次命令
撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- &lt;file&gt;。git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。
场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。
场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库。
删除文件可以先手动删除文件，然后选择下一步操作：

确实要删除文件

git rm &lt;file&gt;git commit -m &quot;remove &lt;file&gt;&quot;

误删文件

$ git checkout -- &lt;file&gt;
这里要注意，没有被提交到版本库的文件，删除是无法恢复的
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>文献《Simple Cues Lead to a Strong Multi-Object Tracker》总结</title>
    <url>/2024/02/23/GHOST-reading/</url>
    <content><![CDATA[这篇文章收录于CVPR2023贴一下原文链接
一、Introduction作者提出在MOT工作中，TbD（Tracking by Detection）是最常见的范式，即先在视频帧中检测出目标，然后进行关联。大多数的关联模型都是基于运动和外观线索，近年来基于注意力机制的方式十分火热，作者希望通过传统的TbD也可以达到端对端模型的性能。于是提出两个关键设计——on-the-fly域适应，以及对于活跃与不活跃轨迹的不同处理。
reID在MOT任务重性能不佳的两个原因：①reID模型在相邻帧中外观变化小，但是在时间间隔较长的情况下，特别是在遮挡情况下外观特征变化剧烈。
②在不同数据集上训练的reID模型无法通用，即鲁棒性较差。为了解决上述问题，作者使用加权的方式将reID和简单的线性运动模型相结合，面对不同的数据集可以赋予不同的权重。作者提出的模型在四个数据集上达到了SOTA。
二、Related WorkGraph-Based Approches： 在TbD中的常见形式是将每个检测视为图中的节点，将节点相连形成轨迹，GHOST可以不使用复杂的图模型获得强大的跟踪器。
Motion-Based Association： 使用运动和位置新西进行逐帧关联，跟踪器利用两个相邻帧之间的空间相邻性进行匹配，最典型的就是卡尔曼滤波。最新的工作引入了基于注意力机制的跟踪范式，使用了复杂的运动模型，需要复杂的训练策略。GHOST表明简单的直线运动模型足以在大多数情况下对短期关联进行建模。
Appearance-Based Association： 为了长期关联场景，许多方法使用额外的基于外观的再识别网络，但是这种只使用外观线索而不使用运动线索的方法使用十分复杂的关联方案，也很难得出正确的结论。相比GHOST不依赖复杂的过程，只在一个简单的TbD跟踪器上结合轻量级的运动和外观线索，只需要很少的训练数据。
Person Re-Identification and Domain Adaptation： Person re-ID是根据外观线索，从给定的图库中查询相同行人的边界框。但对领域外的数据集进行评估时，re-ID模型的性能往往会显著的降低，在应用中可以使用跨数据集评估方式将模型在给定目标中训练。GHOST使用简单的动态域适应方法增强了外观模型，使其更适应MOT任务。
三、 Methodology3.1 跟踪器在跟踪中，在每个时间t中使用线性运动模型产生轨迹对应的预测位置，检测被分配给轨迹，若轨迹未与检测匹配则定义为不活跃，否则活跃，使用内存库来保存不活跃轨迹，将检测与实况轨迹进行匹配。
通过匈牙利算法利用二分匹配将连续镇上的现有检测关联起来。该分配由成本矩阵驱动，该成本矩阵由外观和运动特征的加权和填充，最后利用匹配阈值筛选匹配后的轨迹检测对。
3.2 外观模型外观模型基于ResNet50设计，在末端增加了一个全连接层进行下采样，并在普通人reID数据集上进行训练（没有在MOT数据集上进行训练）。
提出两种设计提升外观模型：
（1）对于活跃与不活跃轨迹的不同处理；（2）on-the-fly域适应图（a）：外观特征距离直方图，分析了最新检测与活跃或非活跃轨迹之间外观特征的距离直方图，深色表示了轨迹与相同身份（正样本）的距离直方图，浅色表示了轨迹与不同身份（负样本）的距离直方图。
图（b）：外观特征的代理距离直方图，分析了最新检测与活跃或非活跃轨迹之间外观特征的代理距离直方图，深色表示了轨迹与相同身份（正样本）的距离直方图，浅色表示了轨迹与不同身份（负样本）的距离直方图。
图（c）：采用IoU度量的活跃非活跃轨迹运动距离直方图
对活跃非活跃轨迹的不同处理： 对于活跃轨迹，利用在t-1帧分配给轨道j的检测外观特征来计算t帧检测i的距离。对于非活跃轨迹，计算非活动轨迹k中所有Nk检测的外观特征向量与新的检测i间的距离，然后利用这些距离的平均值作为代理距离，即： 从Figure 2可以看出活跃与非活跃轨迹距离直方图的显著差异，因此对于活跃轨迹与非活跃轨迹在二分匹配时需要采取不同的处理方式，使用阈值确定允许匹配的成本，不同阈值确定了距离直方图中深色与浅色的划分，对于活跃和不活跃轨迹使用两种不同阈值，比起级联匹配，GHOST的赋值可以避免每帧多次运用二分匹配。
动态域适应： 前面提到过将动态域适应技术应用于reID领域可以防止reID模型应用于不同MOT序列时的性能下降。
最近，有一些reID的工作引入了DA的思想来实现跨数据集泛化的方法，将归一化层适用于Instance Batch、Meta Batch或Camera - Batch Normalization层。与上述方法相反，我们在架构的BN层中使用当前批次特征的均值和方差，该特征对应于测试时间内的一帧检测：其中xi是样本i的特征，μb和σb是当前批次的均值和方差，γ和β在训练时被学习。由于一个序列之间的图像都具有高度相似的底层分布，因此不需要多个BN层就可以很好的近似序列的统计信息，并且可以定义一个适合于所有序列的匹配阈值τi，就可以很有效的分离所有直方图。
将这些应用于外观模型，使对遮挡更适应，更适合不同序列。

由于没有看代码，实验部分也就没仔细看，留到开始看代码了认真看实验

]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo本地预览与部署不同的解决方法</title>
    <url>/2024/01/19/Hexoerror/</url>
    <content><![CDATA[

最近一直在忙考试的事情，终于有时间打开博客了，但出现了一个问题：我的样式全乱了，尝试了重新发布，本地查看的时候还是正常的，部署之后依旧是乱的。 于是在这里贴一下我尝试过的解决方法。

1 重新配置URL在博客根目录中的config.yml文件中修改URL的配置：url是你生成的page页网址，root是你的根目录

2 如果使用图床图片，则需要修改以下内容①找到index.ejs文件，路径为：└──hexo-theme-yourtheme (当前使用的主题文件夹)   └──layout      └──index.ejs②在inddex.ejs的头部中加入：&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&lt;meta http-equiv=&quot;Content-Security-Policy&quot; ontent=&quot;upgrade-insecure-requests&quot;&gt;
3 更改部署的分支在仓库中新建一个分支，不要在master分支上部署pages。我没有尝试新建分支，只是把分支从main改为了master，不确定是否真的有用。
4 浏览器保存了之前部署的数据，清除浏览器缓存后重启浏览器，问题解决。

这些方法我都按顺序尝试过，不是很确定是哪个解决了问题，大家可以都尝试一下。
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hybridsort总结</title>
    <url>/2024/03/25/Hybridsort%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[惯例贴一下原文链接
阅读这篇文章建议先去读一读他的baseline，OC-SORT

AbstractMOT的目标是在帧之间检测和关联所有目标。大多数的方法都是使用强线索（空间信息或者外观信息）完成任务，这些强线索在没有发生遮挡和聚类的时候是十分有用的，一旦发生遮挡和聚类，由于物体高度重叠，空间和外观信息会变得模糊。文章提出了可以用弱线索（高度、检测框置信度、速度方向）作为强线索的补充。
IntroductionMOT中流行的范例习惯将问题分为两个子任务。首先检测每个帧中的对象，其次将他们在不同的框架中联系起来。关联的任务主要通过强线索完成。但是常用的强线索在遇到遮挡和聚类的问题时就会出现退化。如图一所示：

图中展示了强弱线索的辨别能力。绿色实线箭头表示对一对对象的可靠判别，红色虚线表示不可靠的判别，箭头的值越高，表示鉴别越可靠。
可以看出大部分情况下强线索可以分辨出检测框之间的区别，但是红色和橙色框出现了大面积重叠，仅靠交并比和外观线索的判别并不可靠，在这种情况下依靠检测框置信度可以得到更好的区分效果。
作者为了保持SORT简单、在线和实时的特点，使用以下策略利用上述的弱线索：Tracklet置信度建模(TCM)和高度调制IoU (HMIoU)。
MethodWeak Cues ModelingTracklet Confidence Modeling作者改进了传统SORT广泛使用的标准卡尔曼滤波器，增加了两个额外的状态：轨迹置信度c以及其速度分量 $\dot{c}$ :

对于轨迹置信度，作者使用线性预测进行估计。在遮挡发生时，物体的置信度会迅速降低，但是卡尔曼滤波的预测具有滞后性，如图三所示：

因此，作者使用简单的线性预测来估计轨迹的置信状态。线性建模公式如下：

其中ctrk表示保存在Tracklet Memory中的Tracklet置信度。
置信度的代价计算公式如下：

Height Modulated IoU高度状态在两个方面增强了关联。首先，物体的高度在一定程度上反映了深度信息。对于DanceTrack这样的数据集，检测框的高度主要取决于物体与相机之间的距离。这使得高度状态成为区分高度重叠对象的有效线索。其次，高度状态对不同姿态具有较强的鲁棒性，是一种准确估计的状态，是物体的高质量表征。
两个方框分别定义为（x11, y11, x12, y12）,（x21, y21, x22, y22）
则可以通过基于高度度量计算IoU来生成高度IoU (HIoU)，如下图所示：


Hybrid-SORTRobust Observation-Centric Momentum在OC-SORT中，OCM考虑目标中心的速度方向。使用的成本度量是轨迹速度方向θt与轨迹到探测速度方向θd之间的绝对差值，以弧度形式表示为∆θ = |θt - θd|。轨迹波速度方向由轨迹波中两个时间间隔∆t的盒中心获得，轨迹波到检测的速度方向由轨迹波历史盒和新检测盒的中心获得。给定两个点(u1, v1)和(u2, v2)，速度方向按下图所示公式计算。然而，原始OCM的建模容易受到固定时间间隔和稀疏点(即只有目标中心)引起的噪声的影响。

作者通过引入更加鲁棒的速度方向来改进OCM，称之为ROCM，修改包括两个方面。首先，将3帧的固定时间间隔扩展为1 ~ 3的多个时间间隔的叠加；其次，我们用物体的四个角代替它的中心点来计算速度方向。对于多个时间区间和点，ROCM的计算公式如下式所示。

从Figure4可以看出，对于运动复杂的物体，拐角的速度方向保持高度相似，而中心的速度方向几乎相反。

Appearance ModelingReID模型遵循BoT-SORT，首先检测对象，然后将结果裁剪的补丁提供给ReID模型。我们使用指数移动平均(EMA)对轨迹图外观信息建模，并利用余弦距离作为度量来计算轨迹图和检测外观特征之间的成本CAppr。
Algorithm Framework关联阶段主要包括三个阶段:第一阶段是高置信度对象的关联阶段，第二阶段是低置信度对象的关联阶段(ByteTrack中的BYTE)，第三阶段是用最后一次检测恢复丢失的轨迹(OC-SORT中的OCR)。
考虑到所有的强弱线索，最终的成本矩阵为：


]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】C++讲义[提高]</title>
    <url>/2024/08/27/C3/</url>
    <content><![CDATA[C++提高编程
本阶段主要针对C++泛型编程和STL技术做详细讲解，探讨C++更深层的使用

1 模板1.1 模板的概念模板就是建立通用的模具，大大提高复用性
例如生活中的模板
一寸照片模板：

PPT模板：


模板的特点：

模板不可以直接使用，它只是一个框架
模板的通用并不是万能的

1.2 函数模板
C++另一种编程思想称为 泛型编程 ，主要利用的技术就是模板


C++提供两种模板机制:函数模板和类模板 

1.2.1 函数模板语法函数模板作用：
建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。
语法： 
template&lt;typename T&gt;函数声明或定义
解释：
template  —-  声明创建模板
typename  —- 表面其后面的符号是一种数据类型，可以用class代替
T    —-   通用的数据类型，名称可以替换，通常为大写字母
示例：
//交换整型函数void swapInt(int&amp; a, int&amp; b) &#123;	int temp = a;	a = b;	b = temp;&#125;//交换浮点型函数void swapDouble(double&amp; a, double&amp; b) &#123;	double temp = a;	a = b;	b = temp;&#125;//利用模板提供通用的交换函数template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123;	T temp = a;	a = b;	b = temp;&#125;void test01()&#123;	int a = 10;	int b = 20;		//swapInt(a, b);	//利用模板实现交换	//1、自动类型推导	mySwap(a, b);	//2、显示指定类型	mySwap&lt;int&gt;(a, b);	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;	cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

函数模板利用关键字 template
使用函数模板有两种方式：自动类型推导、显示指定类型
模板的目的是为了提高复用性，将类型参数化

1.2.2 函数模板注意事项注意事项：

自动类型推导，必须推导出一致的数据类型T,才可以使用


模板必须要确定出T的数据类型，才可以使用

示例：
//利用模板提供通用的交换函数template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123;	T temp = a;	a = b;	b = temp;&#125;// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用void test01()&#123;	int a = 10;	int b = 20;	char c = &#x27;c&#x27;;	mySwap(a, b); // 正确，可以推导出一致的T	//mySwap(a, c); // 错误，推导不出一致的T类型&#125;// 2、模板必须要确定出T的数据类型，才可以使用template&lt;class T&gt;void func()&#123;	cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;&#125;void test02()&#123;	//func(); //错误，模板不能独立使用，必须确定出T的类型	func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板&#125;int main() &#123;	test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：

使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型

1.2.3 函数模板案例案例描述：

利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序
排序规则从大到小，排序算法为选择排序
分别利用char数组和int数组进行测试

示例：
//交换的函数模板template&lt;typename T&gt;void mySwap(T &amp;a, T&amp;b)&#123;	T temp = a;	a = b;	b = temp;&#125;template&lt;class T&gt; // 也可以替换成typename//利用选择排序，进行对数组从大到小的排序void mySort(T arr[], int len)&#123;	for (int i = 0; i &lt; len; i++)	&#123;		int max = i; //最大数的下标		for (int j = i + 1; j &lt; len; j++)		&#123;			if (arr[max] &lt; arr[j])			&#123;				max = j;			&#125;		&#125;		if (max != i) //如果最大数的下标不是i，交换两者		&#123;			mySwap(arr[max], arr[i]);		&#125;	&#125;&#125;template&lt;typename T&gt;void printArray(T arr[], int len) &#123;	for (int i = 0; i &lt; len; i++) &#123;		cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;void test01()&#123;	//测试char数组	char charArr[] = &quot;bdcfeagh&quot;;	int num = sizeof(charArr) / sizeof(char);	mySort(charArr, num);	printArray(charArr, num);&#125;void test02()&#123;	//测试int数组	int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;;	int num = sizeof(intArr) / sizeof(int);	mySort(intArr, num);	printArray(intArr, num);&#125;int main() &#123;	test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：模板可以提高代码复用，需要熟练掌握
1.2.4 普通函数与函数模板的区别普通函数与函数模板区别：

普通函数调用时可以发生自动类型转换（隐式类型转换）
函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
如果利用显示指定类型的方式，可以发生隐式类型转换

示例：
//普通函数int myAdd01(int a, int b)&#123;	return a + b;&#125;//函数模板template&lt;class T&gt;T myAdd02(T a, T b)  &#123;	return a + b;&#125;//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换void test01()&#123;	int a = 10;	int b = 20;	char c = &#x27;c&#x27;;		cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99	//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换	myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T
1.2.5 普通函数与函数模板的调用规则调用规则如下：

如果函数模板和普通函数都可以实现，优先调用普通函数
可以通过空模板参数列表来强制调用函数模板
函数模板也可以发生重载
如果函数模板可以产生更好的匹配,优先调用函数模板

示例：
//普通函数与函数模板调用规则void myPrint(int a, int b)&#123;	cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b) &#123; 	cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b, T c) &#123; 	cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; &#125;void test01()&#123;	//1、如果函数模板和普通函数都可以实现，优先调用普通函数	// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到	int a = 10;	int b = 20;	myPrint(a, b); //调用普通函数	//2、可以通过空模板参数列表来强制调用函数模板	myPrint&lt;&gt;(a, b); //调用函数模板	//3、函数模板也可以发生重载	int c = 30;	myPrint(a, b, c); //调用重载的函数模板	//4、 如果函数模板可以产生更好的匹配,优先调用函数模板	char c1 = &#x27;a&#x27;;	char c2 = &#x27;b&#x27;;	myPrint(c1, c2); //调用函数模板&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性
1.2.6 模板的局限性局限性：

模板的通用性并不是万能的

例如：
template&lt;class T&gt;void f(T a, T b)&#123;    	a = b;   &#125;
在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了
再例如：
template&lt;class T&gt;void f(T a, T b)&#123;    	if(a &gt; b) &#123; ... &#125;   &#125;
在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行
因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板
示例：
#include&lt;iostream&gt;using namespace std;#include &lt;string&gt;class Person&#123;public:	Person(string name, int age)	&#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;	string m_Name;	int m_Age;&#125;;//普通函数模板template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123;	if (a == b)	&#123;		return true;	&#125;	else	&#123;		return false;	&#125;&#125;//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型//具体化优先于常规模板template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123;	if ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)	&#123;		return true;	&#125;	else	&#123;		return false;	&#125;&#125;void test01()&#123;	int a = 10;	int b = 20;	//内置数据类型可以直接使用通用的函数模板	bool ret = myCompare(a, b);	if (ret)	&#123;		cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl;	&#125;&#125;void test02()&#123;	Person p1(&quot;Tom&quot;, 10);	Person p2(&quot;Tom&quot;, 10);	//自定义数据类型，不会调用普通的函数模板	//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型	bool ret = myCompare(p1, p2);	if (ret)	&#123;		cout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：

利用具体化的模板，可以解决自定义类型的通用化
学习模板并不是为了写模板，而是在STL能够运用系统提供的模板

1.3 类模板1.3.1 类模板语法类模板作用：

建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。

语法： 
template&lt;typename T&gt;类
解释：
template  —-  声明创建模板
typename  —- 表面其后面的符号是一种数据类型，可以用class代替
T    —-   通用的数据类型，名称可以替换，通常为大写字母
示例：
#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType&gt; class Person&#123;public:	Person(NameType name, AgeType age)	&#123;		this-&gt;mName = name;		this-&gt;mAge = age;	&#125;	void showPerson()	&#123;		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;	&#125;public:	NameType mName;	AgeType mAge;&#125;;void test01()&#123;	// 指定NameType 为string类型，AgeType 为 int类型	Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999);	P1.showPerson();&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板
1.3.2 类模板与函数模板区别类模板与函数模板区别主要有两点：

类模板没有自动类型推导的使用方式
类模板在模板参数列表中可以有默认参数

示例：
#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public:	Person(NameType name, AgeType age)	&#123;		this-&gt;mName = name;		this-&gt;mAge = age;	&#125;	void showPerson()	&#123;		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;	&#125;public:	NameType mName;	AgeType mAge;&#125;;//1、类模板没有自动类型推导的使用方式void test01()&#123;	// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导	Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板	p.showPerson();&#125;//2、类模板在模板参数列表中可以有默认参数void test02()&#123;	Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数	p.showPerson();&#125;int main() &#123;	test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：

类模板使用只能用显示指定类型方式
类模板中的模板参数列表可以有默认参数

1.3.3 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的：

普通类中的成员函数一开始就可以创建
类模板中的成员函数在调用时才创建

示例：
class Person1&#123;public:	void showPerson1()	&#123;		cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl;	&#125;&#125;;class Person2&#123;public:	void showPerson2()	&#123;		cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl;	&#125;&#125;;template&lt;class T&gt;class MyClass&#123;public:	T obj;	//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成	void fun1() &#123; obj.showPerson1(); &#125;	void fun2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123;	MyClass&lt;Person1&gt; m;		m.fun1();	//m.fun2();//编译会出错，说明函数调用才会去创建成员函数&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建
1.3.4 类模板对象做函数参数学习目标：

类模板实例化出的对象，向函数传参的方式

一共有三种传入方式：

指定传入的类型   —- 直接显示对象的数据类型
参数模板化           —- 将对象中的参数变为模板进行传递
整个类模板化       —- 将这个对象类型 模板化进行传递

示例：
#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public:	Person(NameType name, AgeType age)	&#123;		this-&gt;mName = name;		this-&gt;mAge = age;	&#125;	void showPerson()	&#123;		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;	&#125;public:	NameType mName;	AgeType mAge;&#125;;//1、指定传入的类型void printPerson1(Person&lt;string, int&gt; &amp;p) &#123;	p.showPerson();&#125;void test01()&#123;	Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100);	printPerson1(p);&#125;//2、参数模板化template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123;	p.showPerson();	cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl;	cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123;	Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90);	printPerson2(p);&#125;//3、整个类模板化template&lt;class T&gt;void printPerson3(T &amp; p)&#123;	cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;	p.showPerson();&#125;void test03()&#123;	Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30);	printPerson3(p);&#125;int main() &#123;	test01();	test02();	test03();	system(&quot;pause&quot;);	return 0;&#125;
总结：

通过类模板创建的对象，可以有三种方式向函数中进行传参
使用比较广泛是第一种：指定传入的类型

1.3.5 类模板与继承当类模板碰到继承时，需要注意一下几点：

当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
如果不指定，编译器无法给子类分配内存
如果想灵活指定出父类中T的类型，子类也需变为类模板

示例：
template&lt;class T&gt;class Base&#123;	T m;&#125;;//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承class Son :public Base&lt;int&gt; //必须指定一个类型&#123;&#125;;void test01()&#123;	Son c;&#125;//类模板继承类模板 ,可以用T2指定父类中的T类型template&lt;class T1, class T2&gt;class Son2 :public Base&lt;T2&gt;&#123;public:	Son2()	&#123;		cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;		cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;	&#125;&#125;;void test02()&#123;	Son2&lt;int, char&gt; child1;&#125;int main() &#123;	test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：如果父类是类模板，子类需要指定出父类中T的数据类型
1.3.6 类模板成员函数类外实现学习目标：能够掌握类模板中的成员函数类外实现
示例：
#include &lt;string&gt;//类模板中成员函数类外实现template&lt;class T1, class T2&gt;class Person &#123;public:	//成员函数类内声明	Person(T1 name, T2 age);	void showPerson();public:	T1 m_Name;	T2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;	this-&gt;m_Name = name;	this-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123;	cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123;	Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);	p.showPerson();&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：类模板中成员函数类外实现时，需要加上模板参数列表
1.3.7 类模板分文件编写学习目标：

掌握类模板成员函数分文件编写产生的问题以及解决方式

问题：

类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到

解决：

解决方式1：直接包含.cpp源文件
解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制

示例：
person.hpp中代码：
#pragma once#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;template&lt;class T1, class T2&gt;class Person &#123;public:	Person(T1 name, T2 age);	void showPerson();public:	T1 m_Name;	T2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;	this-&gt;m_Name = name;	this-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123;	cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;
类模板分文件编写.cpp中代码
#include&lt;iostream&gt;using namespace std;//#include &quot;person.h&quot;#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp#include &quot;person.hpp&quot;void test01()&#123;	Person&lt;string, int&gt; p(&quot;Tom&quot;, 10);	p.showPerson();&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp
1.3.8 类模板与友元学习目标：

掌握类模板配合友元函数的类内和类外实现

全局函数类内实现 - 直接在类内声明友元即可
全局函数类外实现 - 需要提前让编译器知道全局函数的存在
示例：
#include &lt;string&gt;//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元template&lt;class T1, class T2&gt; class Person;//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt; &amp; p)&#123;	cout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1, class T2&gt;class Person&#123;	//1、全局函数配合友元   类内实现	friend void printPerson(Person&lt;T1, T2&gt; &amp; p)	&#123;		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;	&#125;	//全局函数配合友元  类外实现	friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);public:	Person(T1 name, T2 age)	&#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;private:	T1 m_Name;	T2 m_Age;&#125;;//1、全局函数在类内实现void test01()&#123;	Person &lt;string, int &gt;p(&quot;Tom&quot;, 20);	printPerson(p);&#125;//2、全局函数在类外实现void test02()&#123;	Person &lt;string, int &gt;p(&quot;Jerry&quot;, 30);	printPerson2(p);&#125;int main() &#123;	//test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别
1.3.9 类模板案例案例描述:  实现一个通用的数组类，要求如下：

可以对内置数据类型以及自定义数据类型的数据进行存储
将数组中的数据存储到堆区
构造函数中可以传入数组的容量
提供对应的拷贝构造函数以及operator=防止浅拷贝问题
提供尾插法和尾删法对数组中的数据进行增加和删除
可以通过下标的方式访问数组中的元素
可以获取数组中当前元素个数和数组的容量

示例：
myArray.hpp中代码
#pragma once#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class MyArray&#123;public:    	//构造函数	MyArray(int capacity)	&#123;		this-&gt;m_Capacity = capacity;		this-&gt;m_Size = 0;		pAddress = new T[this-&gt;m_Capacity];	&#125;	//拷贝构造	MyArray(const MyArray &amp; arr)	&#123;		this-&gt;m_Capacity = arr.m_Capacity;		this-&gt;m_Size = arr.m_Size;		this-&gt;pAddress = new T[this-&gt;m_Capacity];		for (int i = 0; i &lt; this-&gt;m_Size; i++)		&#123;			//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，			// 普通类型可以直接= 但是指针类型需要深拷贝			this-&gt;pAddress[i] = arr.pAddress[i];		&#125;	&#125;	//重载= 操作符  防止浅拷贝问题	MyArray&amp; operator=(const MyArray&amp; myarray) &#123;		if (this-&gt;pAddress != NULL) &#123;			delete[] this-&gt;pAddress;			this-&gt;m_Capacity = 0;			this-&gt;m_Size = 0;		&#125;		this-&gt;m_Capacity = myarray.m_Capacity;		this-&gt;m_Size = myarray.m_Size;		this-&gt;pAddress = new T[this-&gt;m_Capacity];		for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123;			this-&gt;pAddress[i] = myarray[i];		&#125;		return *this;	&#125;	//重载[] 操作符  arr[0]	T&amp; operator [](int index)	&#123;		return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理	&#125;	//尾插法	void Push_back(const T &amp; val)	&#123;		if (this-&gt;m_Capacity == this-&gt;m_Size)		&#123;			return;		&#125;		this-&gt;pAddress[this-&gt;m_Size] = val;		this-&gt;m_Size++;	&#125;	//尾删法	void Pop_back()	&#123;		if (this-&gt;m_Size == 0)		&#123;			return;		&#125;		this-&gt;m_Size--;	&#125;	//获取数组容量	int getCapacity()	&#123;		return this-&gt;m_Capacity;	&#125;	//获取数组大小	int	getSize()	&#123;		return this-&gt;m_Size;	&#125;	//析构	~MyArray()	&#123;		if (this-&gt;pAddress != NULL)		&#123;			delete[] this-&gt;pAddress;			this-&gt;pAddress = NULL;			this-&gt;m_Capacity = 0;			this-&gt;m_Size = 0;		&#125;	&#125;private:	T * pAddress;  //指向一个堆空间，这个空间存储真正的数据	int m_Capacity; //容量	int m_Size;   // 大小&#125;;
类模板案例—数组类封装.cpp中
#include &quot;myArray.hpp&quot;#include &lt;string&gt;void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123;	for (int i = 0; i &lt; arr.getSize(); i++) &#123;		cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//测试内置数据类型void test01()&#123;	MyArray&lt;int&gt; array1(10);	for (int i = 0; i &lt; 10; i++)	&#123;		array1.Push_back(i);	&#125;	cout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl;	printIntArray(array1);	cout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl;	cout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl;	cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;	MyArray&lt;int&gt; array2(array1);	array2.Pop_back();	cout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl;	printIntArray(array2);	cout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl;	cout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl;&#125;//测试自定义数据类型class Person &#123;public:	Person() &#123;&#125; 		Person(string name, int age) &#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;public:	string m_Name;	int m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)&#123;	for (int i = 0; i &lt; personArr.getSize(); i++) &#123;		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl;	&#125;&#125;void test02()&#123;	//创建数组	MyArray&lt;Person&gt; pArray(10);	Person p1(&quot;孙悟空&quot;, 30);	Person p2(&quot;韩信&quot;, 20);	Person p3(&quot;妲己&quot;, 18);	Person p4(&quot;王昭君&quot;, 15);	Person p5(&quot;赵云&quot;, 24);	//插入数据	pArray.Push_back(p1);	pArray.Push_back(p2);	pArray.Push_back(p3);	pArray.Push_back(p4);	pArray.Push_back(p5);	printPersonArray(pArray);	cout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl;	cout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl;&#125;int main() &#123;	//test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：
能够利用所学知识点实现通用的数组
2 STL初识2.1 STL的诞生
长久以来，软件界一直希望建立一种可重复利用的东西

C++的面向对象和泛型编程思想，目的就是复用性的提升

大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作

为了建立数据结构和算法的一套标准,诞生了STL
​


2.2 STL基本概念
STL(Standard Template Library,标准模板库)
STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)
容器和算法之间通过迭代器进行无缝连接。
STL 几乎所有的代码都采用了模板类或者模板函数

2.3 STL六大组件STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器

容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。
算法：各种常用的算法，如sort、find、copy、for_each等
迭代器：扮演了容器与算法之间的胶合剂。
仿函数：行为类似函数，可作为算法的某种策略。
适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
空间配置器：负责空间的配置与管理。

2.4  STL中容器、算法、迭代器容器：置物之所也
STL容器就是将运用最广泛的一些数据结构实现出来
常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等
这些容器分为序列式容器和关联式容器两种:
​    序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。    关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系
算法：问题之解法也
有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)
算法分为:质变算法和非质变算法。
质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等
非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等
迭代器：容器和算法之间粘合剂
提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。
每个容器都有自己专属的迭代器
迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针
迭代器种类：




种类
功能
支持运算




输入迭代器
对数据的只读访问
只读，支持++、==、！=


输出迭代器
对数据的只写访问
只写，支持++


前向迭代器
读写操作，并能向前推进迭代器
读写，支持++、==、！=


双向迭代器
读写操作，并能向前和向后操作
读写，支持++、—，


随机访问迭代器
读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器
读写，支持++、—、[n]、-n、&lt;、&lt;=、&gt;、&gt;=




常用的容器中迭代器种类为双向迭代器，和随机访问迭代器
2.5 容器算法迭代器初识了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力
STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器
2.5.1 vector存放内置数据类型容器：     vector
算法：     for_each
迭代器： vector&lt;int&gt;::iterator
示例：
#include &lt;vector&gt;#include &lt;algorithm&gt;void MyPrint(int val)&#123;	cout &lt;&lt; val &lt;&lt; endl;&#125;void test01() &#123;	//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型	vector&lt;int&gt; v;	//向容器中放数据	v.push_back(10);	v.push_back(20);	v.push_back(30);	v.push_back(40);	//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素	//v.begin()返回迭代器，这个迭代器指向容器中第一个数据	//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置	//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型	vector&lt;int&gt;::iterator pBegin = v.begin();	vector&lt;int&gt;::iterator pEnd = v.end();	//第一种遍历方式：	while (pBegin != pEnd) &#123;		cout &lt;&lt; *pBegin &lt;&lt; endl;		pBegin++;	&#125;		//第二种遍历方式：	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; endl;	&#125;	cout &lt;&lt; endl;	//第三种遍历方式：	//使用STL提供标准遍历算法  头文件 algorithm	for_each(v.begin(), v.end(), MyPrint);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
2.5.2 Vector存放自定义数据类型学习目标：vector中存放自定义数据类型，并打印输出
示例：
#include &lt;vector&gt;#include &lt;string&gt;//自定义数据类型class Person &#123;public:	Person(string name, int age) &#123;		mName = name;		mAge = age;	&#125;public:	string mName;	int mAge;&#125;;//存放对象void test01() &#123;	vector&lt;Person&gt; v;	//创建数据	Person p1(&quot;aaa&quot;, 10);	Person p2(&quot;bbb&quot;, 20);	Person p3(&quot;ccc&quot;, 30);	Person p4(&quot;ddd&quot;, 40);	Person p5(&quot;eee&quot;, 50);	v.push_back(p1);	v.push_back(p2);	v.push_back(p3);	v.push_back(p4);	v.push_back(p5);	for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;	&#125;&#125;//放对象指针void test02() &#123;	vector&lt;Person*&gt; v;	//创建数据	Person p1(&quot;aaa&quot;, 10);	Person p2(&quot;bbb&quot;, 20);	Person p3(&quot;ccc&quot;, 30);	Person p4(&quot;ddd&quot;, 40);	Person p5(&quot;eee&quot;, 50);	v.push_back(&amp;p1);	v.push_back(&amp;p2);	v.push_back(&amp;p3);	v.push_back(&amp;p4);	v.push_back(&amp;p5);	for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		Person * p = (*it);		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();    	test02();	system(&quot;pause&quot;);	return 0;&#125;
2.5.3 Vector容器嵌套容器学习目标：容器中嵌套容器，我们将所有数据进行遍历输出
示例：
#include &lt;vector&gt;//容器嵌套容器void test01() &#123;	vector&lt; vector&lt;int&gt; &gt;  v;	vector&lt;int&gt; v1;	vector&lt;int&gt; v2;	vector&lt;int&gt; v3;	vector&lt;int&gt; v4;	for (int i = 0; i &lt; 4; i++) &#123;		v1.push_back(i + 1);		v2.push_back(i + 2);		v3.push_back(i + 3);		v4.push_back(i + 4);	&#125;	//将容器元素插入到vector v中	v.push_back(v1);	v.push_back(v2);	v.push_back(v3);	v.push_back(v4);	for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;			cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;		&#125;		cout &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
3 STL- 常用容器3.1 string容器3.1.1 string基本概念本质：

string是C++风格的字符串，而string本质上是一个类

string和char * 区别：

char * 是一个指针
string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。

特点：
string 类内部封装了很多成员方法
例如：查找find，拷贝copy，删除delete 替换replace，插入insert
string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责
3.1.2 string构造函数构造函数原型：

string();                          //创建一个空的字符串 例如: string str;   string(const char* s);            //使用字符串s初始化
string(const string&amp; str);    //使用一个string对象初始化另一个string对象
string(int n, char c);           //使用n个字符c初始化 

示例：
#include &lt;string&gt;//string构造void test01()&#123;	string s1; //创建空字符串，调用无参构造函数	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; s1 &lt;&lt; endl;	const char* str = &quot;hello world&quot;;	string s2(str); //把c_string转换成了string	cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl;	string s3(s2); //调用拷贝构造函数	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;	string s4(10, &#x27;a&#x27;);	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：string的多种构造方式没有可比性，灵活使用即可
3.1.3 string赋值操作功能描述：

给string字符串进行赋值

赋值的函数原型：

string&amp; operator=(const char* s);             //char*类型字符串 赋值给当前的字符串
string&amp; operator=(const string &amp;s);         //把字符串s赋给当前的字符串
string&amp; operator=(char c);                          //字符赋值给当前的字符串
string&amp; assign(const char *s);                  //把字符串s赋给当前的字符串
string&amp; assign(const char *s, int n);     //把字符串s的前n个字符赋给当前的字符串
string&amp; assign(const string &amp;s);              //把字符串s赋给当前字符串
string&amp; assign(int n, char c);                  //用n个字符c赋给当前字符串

示例：
//赋值void test01()&#123;	string str1;	str1 = &quot;hello world&quot;;	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;	string str2;	str2 = str1;	cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;	string str3;	str3 = &#x27;a&#x27;;	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;	string str4;	str4.assign(&quot;hello c++&quot;);	cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;	string str5;	str5.assign(&quot;hello c++&quot;,5);	cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;	string str6;	str6.assign(str5);	cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;	string str7;	str7.assign(5, &#x27;x&#x27;);	cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：
​    string的赋值方式很多，operator=  这种方式是比较实用的
3.1.4 string字符串拼接功能描述：

实现在字符串末尾拼接字符串

函数原型：

string&amp; operator+=(const char* str);                   //重载+=操作符
string&amp; operator+=(const char c);                         //重载+=操作符
string&amp; operator+=(const string&amp; str);                //重载+=操作符
string&amp; append(const char *s);                               //把字符串s连接到当前字符串结尾
string&amp; append(const char *s, int n);                 //把字符串s的前n个字符连接到当前字符串结尾
string&amp; append(const string &amp;s);                           //同operator+=(const string&amp; str)
string&amp; append(const string &amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾

示例：
//字符串拼接void test01()&#123;	string str1 = &quot;我&quot;;	str1 += &quot;爱玩游戏&quot;;	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;		str1 += &#x27;:&#x27;;	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;	string str2 = &quot;LOL DNF&quot;;	str1 += str2;	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;	string str3 = &quot;I&quot;;	str3.append(&quot; love &quot;);	str3.append(&quot;game abcde&quot;, 4);	//str3.append(str2);	str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：字符串拼接的重载版本很多，初学阶段记住几种即可
3.1.5 string查找和替换功能描述：

查找：查找指定字符串是否存在
替换：在指定的位置替换字符串

函数原型：

int find(const string&amp; str, int pos = 0) const;              //查找str第一次出现位置,从pos开始查找
int find(const char* s, int pos = 0) const;                     //查找s第一次出现位置,从pos开始查找
int find(const char* s, int pos, int n) const;               //从pos位置查找s的前n个字符第一次位置
int find(const char c, int pos = 0) const;                       //查找字符c第一次出现位置
int rfind(const string&amp; str, int pos = npos) const;      //查找str最后一次位置,从pos开始查找
int rfind(const char* s, int pos = npos) const;              //查找s最后一次出现位置,从pos开始查找
int rfind(const char* s, int pos, int n) const;              //从pos查找s的前n个字符最后一次位置
int rfind(const char c, int pos = 0) const;                      //查找字符c最后一次出现位置
string&amp; replace(int pos, int n, const string&amp; str);       //替换从pos开始n个字符为字符串str
string&amp; replace(int pos, int n,const char* s);                 //替换从pos开始的n个字符为字符串s

示例：
//查找和替换void test01()&#123;	//查找	string str1 = &quot;abcdefgde&quot;;	int pos = str1.find(&quot;de&quot;);	if (pos == -1)	&#123;		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;	&#125;		pos = str1.rfind(&quot;de&quot;);	cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;&#125;void test02()&#123;	//替换	string str1 = &quot;abcdefgde&quot;;	str1.replace(1, 3, &quot;1111&quot;);	cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;&#125;int main() &#123;	//test01();	//test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：

find查找是从左往后，rfind从右往左
find找到字符串后返回查找的第一个字符位置，找不到返回-1
replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串

3.1.6 string字符串比较功能描述：

字符串之间的比较

比较方式：

字符串比较是按字符的ASCII码进行对比

= 返回   0
> 返回   1 
&lt; 返回  -1
函数原型：

int compare(const string &amp;s) const;  //与字符串s比较
int compare(const char *s) const;      //与字符串s比较

示例：
//字符串比较void test01()&#123;	string s1 = &quot;hello&quot;;	string s2 = &quot;aello&quot;;	int ret = s1.compare(s2);	if (ret == 0) &#123;		cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;	&#125;	else if (ret &gt; 0)	&#123;		cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大
3.1.7 string字符存取string中单个字符存取方式有两种

char&amp; operator[](int n);     //通过[]方式取字符
char&amp; at(int n);                    //通过at方法获取字符

示例：
void test01()&#123;	string str = &quot;hello world&quot;;	for (int i = 0; i &lt; str.size(); i++)	&#123;		cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	for (int i = 0; i &lt; str.size(); i++)	&#123;		cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	//字符修改	str[0] = &#x27;x&#x27;;	str.at(1) = &#x27;x&#x27;;	cout &lt;&lt; str &lt;&lt; endl;	&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at
3.1.8 string插入和删除功能描述：

对string字符串进行插入和删除字符操作

函数原型：

string&amp; insert(int pos, const char* s);                //插入字符串
string&amp; insert(int pos, const string&amp; str);        //插入字符串
string&amp; insert(int pos, int n, char c);                //在指定位置插入n个字符c
string&amp; erase(int pos, int n = npos);                    //删除从Pos开始的n个字符 

示例：
//字符串插入和删除void test01()&#123;	string str = &quot;hello&quot;;	str.insert(1, &quot;111&quot;);	cout &lt;&lt; str &lt;&lt; endl;	str.erase(1, 3);  //从1号位置开始3个字符	cout &lt;&lt; str &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：插入和删除的起始下标都是从0开始
3.1.9 string子串功能描述：

从字符串中获取想要的子串

函数原型：

string substr(int pos = 0, int n = npos) const;   //返回由pos开始的n个字符组成的字符串

示例：
//子串void test01()&#123;	string str = &quot;abcdefg&quot;;	string subStr = str.substr(1, 3);	cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;	string email = &quot;hello@sina.com&quot;;	int pos = email.find(&quot;@&quot;);	string username = email.substr(0, pos);	cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息
3.2 vector容器3.2.1 vector基本概念功能：

vector数据结构和数组非常相似，也称为单端数组

vector与普通数组区别：

不同之处在于数组是静态空间，而vector可以动态扩展

动态扩展：

并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间



vector容器的迭代器是支持随机访问的迭代器

3.2.2 vector构造函数功能描述：

创建vector容器

函数原型：

vector&lt;T&gt; v;                            //采用模板实现类实现，默认构造函数
vector(v.begin(), v.end());       //将v[begin(), end())区间中的元素拷贝给本身。
vector(n, elem);                            //构造函数将n个elem拷贝给本身。
vector(const vector &amp;vec);         //拷贝构造函数。

示例：
#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;void test01()&#123;	vector&lt;int&gt; v1; //无参构造	for (int i = 0; i &lt; 10; i++)	&#123;		v1.push_back(i);	&#125;	printVector(v1);	vector&lt;int&gt; v2(v1.begin(), v1.end());	printVector(v2);	vector&lt;int&gt; v3(10, 100);	printVector(v3);		vector&lt;int&gt; v4(v3);	printVector(v4);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：vector的多种构造方式没有可比性，灵活使用即可
3.2.3 vector赋值操作功能描述：

给vector容器进行赋值

函数原型：

vector&amp; operator=(const vector &amp;vec);//重载等号操作符


assign(beg, end);       //将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);        //将n个elem拷贝赋值给本身。

示例：
#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;	vector&lt;int&gt; v1; //无参构造	for (int i = 0; i &lt; 10; i++)	&#123;		v1.push_back(i);	&#125;	printVector(v1);	vector&lt;int&gt;v2;	v2 = v1;	printVector(v2);	vector&lt;int&gt;v3;	v3.assign(v1.begin(), v1.end());	printVector(v3);	vector&lt;int&gt;v4;	v4.assign(10, 100);	printVector(v4);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结： vector赋值方式比较简单，使用operator=，或者assign都可以
3.2.4  vector容量和大小功能描述：

对vector容器的容量和大小操作

函数原型：

empty();                            //判断容器是否为空

capacity();                      //容器的容量

size();                              //返回容器中元素的个数

resize(int num);             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。
​                          //如果容器变短，则末尾超出容器长度的元素被删除。

resize(int num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。
​                              //如果容器变短，则末尾超出容器长度的元素被删除


示例：
#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;void test01()&#123;	vector&lt;int&gt; v1;	for (int i = 0; i &lt; 10; i++)	&#123;		v1.push_back(i);	&#125;	printVector(v1);	if (v1.empty())	&#123;		cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;		cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;	&#125;	//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充	v1.resize(15,10);	printVector(v1);	//resize 重新指定大小 ，若指定的更小，超出部分元素被删除	v1.resize(5);	printVector(v1);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

判断是否为空  —- empty
返回元素个数  —- size
返回容器容量  —- capacity
重新指定大小  —-  resize

3.2.5 vector插入和删除功能描述：

对vector容器进行插入、删除操作

函数原型：

push_back(ele);                                         //尾部插入元素ele
pop_back();                                                //删除最后一个元素
insert(const_iterator pos, ele);        //迭代器指向位置pos插入元素ele
insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele
erase(const_iterator pos);                     //删除迭代器指向的元素
erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素
clear();                                                        //删除容器中所有元素

示例：
#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;	vector&lt;int&gt; v1;	//尾插	v1.push_back(10);	v1.push_back(20);	v1.push_back(30);	v1.push_back(40);	v1.push_back(50);	printVector(v1);	//尾删	v1.pop_back();	printVector(v1);	//插入	v1.insert(v1.begin(), 100);	printVector(v1);	v1.insert(v1.begin(), 2, 1000);	printVector(v1);	//删除	v1.erase(v1.begin());	printVector(v1);	//清空	v1.erase(v1.begin(), v1.end());	v1.clear();	printVector(v1);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

尾插  —- push_back
尾删  —- pop_back
插入  —- insert    (位置迭代器)
删除  —- erase  （位置迭代器）
清空  —-  clear  

3.2.6 vector数据存取功能描述：

对vector中的数据的存取操作

函数原型：

at(int idx);     //返回索引idx所指的数据
operator[];       //返回索引idx所指的数据
front();            //返回容器中第一个数据元素
back();              //返回容器中最后一个数据元素

示例：
#include &lt;vector&gt;void test01()&#123;	vector&lt;int&gt;v1;	for (int i = 0; i &lt; 10; i++)	&#123;		v1.push_back(i);	&#125;	for (int i = 0; i &lt; v1.size(); i++)	&#123;		cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	for (int i = 0; i &lt; v1.size(); i++)	&#123;		cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;	cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

除了用迭代器获取vector容器中元素，[ ]和at也可以
front返回容器第一个元素
back返回容器最后一个元素

3.2.7 vector互换容器功能描述：

实现两个容器内元素进行互换

函数原型：

swap(vec);  // 将vec与本身的元素互换

示例：
#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;void test01()&#123;	vector&lt;int&gt;v1;	for (int i = 0; i &lt; 10; i++)	&#123;		v1.push_back(i);	&#125;	printVector(v1);	vector&lt;int&gt;v2;	for (int i = 10; i &gt; 0; i--)	&#123;		v2.push_back(i);	&#125;	printVector(v2);	//互换容器	cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;	v1.swap(v2);	printVector(v1);	printVector(v2);&#125;void test02()&#123;	vector&lt;int&gt; v;	for (int i = 0; i &lt; 100000; i++) &#123;		v.push_back(i);	&#125;	cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;	cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;	v.resize(3);	cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;	cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;	//收缩内存	vector&lt;int&gt;(v).swap(v); //匿名对象	cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;	cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;int main() &#123;	test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：swap可以使两个容器互换，可以达到实用的收缩内存效果
3.2.8 vector预留空间功能描述：

减少vector在动态扩展容量时的扩展次数

函数原型：

reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。
​


示例：
#include &lt;vector&gt;void test01()&#123;	vector&lt;int&gt; v;	//预留空间	v.reserve(100000);	int num = 0;	int* p = NULL;	for (int i = 0; i &lt; 100000; i++) &#123;		v.push_back(i);		if (p != &amp;v[0]) &#123;			p = &amp;v[0];			num++;		&#125;	&#125;	cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;	test01();    	system(&quot;pause&quot;);	return 0;&#125;
总结：如果数据量较大，可以一开始利用reserve预留空间
3.3 deque容器3.3.1 deque容器基本概念功能：

双端数组，可以对头端进行插入删除操作

deque与vector区别：

vector对于头部的插入删除效率低，数据量越大，效率越低
deque相对而言，对头部的插入删除速度回比vector快
vector访问元素时的速度会比deque快,这和两者内部实现有关


deque内部工作原理:
deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据
中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间


deque容器的迭代器也是支持随机访问的

3.3.2 deque构造函数功能描述：

deque容器构造

函数原型：

deque&lt;T&gt; deqT;                      //默认构造形式
deque(beg, end);                  //构造函数将[beg, end)区间中的元素拷贝给本身。
deque(n, elem);                    //构造函数将n个elem拷贝给本身。
deque(const deque &amp;deq);   //拷贝构造函数

示例：
#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//deque构造void test01() &#123;	deque&lt;int&gt; d1; //无参构造函数	for (int i = 0; i &lt; 10; i++)	&#123;		d1.push_back(i);	&#125;	printDeque(d1);	deque&lt;int&gt; d2(d1.begin(),d1.end());	printDeque(d2);	deque&lt;int&gt;d3(10,100);	printDeque(d3);	deque&lt;int&gt;d4 = d3;	printDeque(d4);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可
3.3.3 deque赋值操作功能描述：

给deque容器进行赋值

函数原型：

deque&amp; operator=(const deque &amp;deq);         //重载等号操作符


assign(beg, end);                                           //将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);                                             //将n个elem拷贝赋值给本身。

示例：
#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;	deque&lt;int&gt; d1;	for (int i = 0; i &lt; 10; i++)	&#123;		d1.push_back(i);	&#125;	printDeque(d1);	deque&lt;int&gt;d2;	d2 = d1;	printDeque(d2);	deque&lt;int&gt;d3;	d3.assign(d1.begin(), d1.end());	printDeque(d3);	deque&lt;int&gt;d4;	d4.assign(10, 100);	printDeque(d4);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：deque赋值操作也与vector相同，需熟练掌握
3.3.4 deque大小操作功能描述：

对deque容器的大小进行操作

函数原型：

deque.empty();                       //判断容器是否为空

deque.size();                         //返回容器中元素的个数

deque.resize(num);                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。
​                                         //如果容器变短，则末尾超出容器长度的元素被删除。

deque.resize(num, elem);     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。
​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。
​


示例：
#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;	deque&lt;int&gt; d1;	for (int i = 0; i &lt; 10; i++)	&#123;		d1.push_back(i);	&#125;	printDeque(d1);	//判断容器是否为空	if (d1.empty()) &#123;		cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;	&#125;	else &#123;		cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;		//统计大小		cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;	&#125;	//重新指定大小	d1.resize(15, 1);	printDeque(d1);	d1.resize(5);	printDeque(d1);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

deque没有容量的概念
判断是否为空   —- empty
返回元素个数   —- size
重新指定个数   —- resize

3.3.5 deque 插入和删除功能描述：

向deque容器中插入和删除数据

函数原型：
两端插入操作：

push_back(elem);          //在容器尾部添加一个数据
push_front(elem);        //在容器头部插入一个数据
pop_back();                   //删除容器最后一个数据
pop_front();                 //删除容器第一个数据

指定位置操作：

insert(pos,elem);         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。

insert(pos,n,elem);     //在pos位置插入n个elem数据，无返回值。

insert(pos,beg,end);    //在pos位置插入[beg,end)区间的数据，无返回值。

clear();                           //清空容器的所有数据

erase(beg,end);             //删除[beg,end)区间的数据，返回下一个数据的位置。

erase(pos);                    //删除pos位置的数据，返回下一个数据的位置。
​
​


示例：
#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//两端操作void test01()&#123;	deque&lt;int&gt; d;	//尾插	d.push_back(10);	d.push_back(20);	//头插	d.push_front(100);	d.push_front(200);	printDeque(d);	//尾删	d.pop_back();	//头删	d.pop_front();	printDeque(d);&#125;//插入void test02()&#123;	deque&lt;int&gt; d;	d.push_back(10);	d.push_back(20);	d.push_front(100);	d.push_front(200);	printDeque(d);	d.insert(d.begin(), 1000);	printDeque(d);	d.insert(d.begin(), 2,10000);	printDeque(d);	deque&lt;int&gt;d2;	d2.push_back(1);	d2.push_back(2);	d2.push_back(3);	d.insert(d.begin(), d2.begin(), d2.end());	printDeque(d);&#125;//删除void test03()&#123;	deque&lt;int&gt; d;	d.push_back(10);	d.push_back(20);	d.push_front(100);	d.push_front(200);	printDeque(d);	d.erase(d.begin());	printDeque(d);	d.erase(d.begin(), d.end());	d.clear();	printDeque(d);&#125;int main() &#123;	//test01();	//test02();    test03();    	system(&quot;pause&quot;);	return 0;&#125;
总结：

插入和删除提供的位置是迭代器！
尾插   —-  push_back
尾删   —-  pop_back
头插   —-  push_front
头删   —-  pop_front

3.3.6 deque 数据存取功能描述：

对deque 中的数据的存取操作

函数原型：

at(int idx);     //返回索引idx所指的数据
operator[];      //返回索引idx所指的数据
front();            //返回容器中第一个数据元素
back();              //返回容器中最后一个数据元素

示例：
#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//数据存取void test01()&#123;	deque&lt;int&gt; d;	d.push_back(10);	d.push_back(20);	d.push_front(100);	d.push_front(200);	for (int i = 0; i &lt; d.size(); i++) &#123;		cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	for (int i = 0; i &lt; d.size(); i++) &#123;		cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;	cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

除了用迭代器获取deque容器中元素，[ ]和at也可以
front返回容器第一个元素
back返回容器最后一个元素

3.3.7  deque 排序功能描述：

利用算法实现对deque容器进行排序

算法：

sort(iterator beg, iterator end)  //对beg和end区间内元素进行排序

示例：
#include &lt;deque&gt;#include &lt;algorithm&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;void test01()&#123;	deque&lt;int&gt; d;	d.push_back(10);	d.push_back(20);	d.push_front(100);	d.push_front(200);	printDeque(d);	sort(d.begin(), d.end());	printDeque(d);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：sort算法非常实用，使用时包含头文件 algorithm即可
3.4 案例-评委打分3.4.1 案例描述有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。
3.4.2 实现步骤
创建五名选手，放到vector中
遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中
sort算法对deque容器中分数排序，去除最高和最低分
deque容器遍历一遍，累加总分
获取平均分

示例代码：
//选手类class Person&#123;public:	Person(string name, int score)	&#123;		this-&gt;m_Name = name;		this-&gt;m_Score = score;	&#125;	string m_Name; //姓名	int m_Score;  //平均分&#125;;void createPerson(vector&lt;Person&gt;&amp;v)&#123;	string nameSeed = &quot;ABCDE&quot;;	for (int i = 0; i &lt; 5; i++)	&#123;		string name = &quot;选手&quot;;		name += nameSeed[i];		int score = 0;		Person p(name, score);		//将创建的person对象 放入到容器中		v.push_back(p);	&#125;&#125;//打分void setScore(vector&lt;Person&gt;&amp;v)&#123;	for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)	&#123;		//将评委的分数 放入到deque容器中		deque&lt;int&gt;d;		for (int i = 0; i &lt; 10; i++)		&#123;			int score = rand() % 41 + 60;  // 60 ~ 100			d.push_back(score);		&#125;		//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;		//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)		//&#123;		//	cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;		//&#125;		//cout &lt;&lt; endl;		//排序		sort(d.begin(), d.end());		//去除最高和最低分		d.pop_back();		d.pop_front();		//取平均分		int sum = 0;		for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)		&#123;			sum += *dit; //累加每个评委的分数		&#125;		int avg = sum / d.size();		//将平均分 赋值给选手身上		it-&gt;m_Score = avg;	&#125;&#125;void showScore(vector&lt;Person&gt;&amp;v)&#123;	for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)	&#123;		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl;	&#125;&#125;int main() &#123;	//随机数种子	srand((unsigned int)time(NULL));	//1、创建5名选手	vector&lt;Person&gt;v;  //存放选手容器	createPerson(v);	//测试	//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)	//&#123;	//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;	//&#125;	//2、给5名选手打分	setScore(v);	//3、显示最后得分	showScore(v);	system(&quot;pause&quot;);	return 0;&#125;
总结： 选取不同的容器操作数据，可以提升代码的效率
3.5 stack容器3.5.1 stack 基本概念概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口

栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为
栈中进入数据称为  —- 入栈  push
栈中弹出数据称为  —- 出栈  pop
生活中的栈：


3.5.2 stack 常用接口功能描述：栈容器常用的对外接口
构造函数：

stack&lt;T&gt; stk;                                 //stack采用模板类实现， stack对象的默认构造形式
stack(const stack &amp;stk);            //拷贝构造函数

赋值操作：

stack&amp; operator=(const stack &amp;stk);           //重载等号操作符

数据存取：

push(elem);      //向栈顶添加元素
pop();                //从栈顶移除第一个元素
top();                //返回栈顶元素

大小操作：

empty();            //判断堆栈是否为空
size();              //返回栈的大小

示例：
#include &lt;stack&gt;//栈容器常用接口void test01()&#123;	//创建栈容器 栈容器必须符合先进后出	stack&lt;int&gt; s;	//向栈中添加元素，叫做 压栈 入栈	s.push(10);	s.push(20);	s.push(30);	while (!s.empty()) &#123;		//输出栈顶元素		cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;		//弹出栈顶元素		s.pop();	&#125;	cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

入栈   —- push
出栈   —- pop
返回栈顶   —- top
判断栈是否为空   —- empty
返回栈大小   —- size

3.6 queue 容器3.6.1 queue 基本概念概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口

队列容器允许从一端新增元素，从另一端移除元素
队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为
队列中进数据称为 —- 入队    push
队列中出数据称为 —- 出队    pop
生活中的队列：

3.6.2 queue 常用接口功能描述：栈容器常用的对外接口
构造函数：

queue&lt;T&gt; que;                                 //queue采用模板类实现，queue对象的默认构造形式
queue(const queue &amp;que);            //拷贝构造函数

赋值操作：

queue&amp; operator=(const queue &amp;que);           //重载等号操作符

数据存取：

push(elem);                             //往队尾添加元素
pop();                                      //从队头移除第一个元素
back();                                    //返回最后一个元素
front();                                  //返回第一个元素

大小操作：

empty();            //判断堆栈是否为空
size();              //返回栈的大小

示例：
#include &lt;queue&gt;#include &lt;string&gt;class Person&#123;public:	Person(string name, int age)	&#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;	string m_Name;	int m_Age;&#125;;void test01() &#123;	//创建队列	queue&lt;Person&gt; q;	//准备数据	Person p1(&quot;唐僧&quot;, 30);	Person p2(&quot;孙悟空&quot;, 1000);	Person p3(&quot;猪八戒&quot;, 900);	Person p4(&quot;沙僧&quot;, 800);	//向队列中添加元素  入队操作	q.push(p1);	q.push(p2);	q.push(p3);	q.push(p4);	//队列不提供迭代器，更不支持随机访问		while (!q.empty()) &#123;		//输出队头元素		cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name               &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;        		cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name                &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;        		cout &lt;&lt; endl;		//弹出队头元素		q.pop();	&#125;	cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

入队   —- push
出队   —- pop
返回队头元素   —- front
返回队尾元素   —- back
判断队是否为空   —- empty
返回队列大小   —- size

3.7 list容器3.7.1 list基本概念功能：将数据进行链式存储
链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的
链表的组成：链表由一系列结点组成
结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域
STL中的链表是一个双向循环链表

由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器
list的优点：

采用动态存储分配，不会造成内存浪费和溢出
链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素

list的缺点：

链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大

List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。
总结：STL中List和vector是两个最常被使用的容器，各有优缺点
3.7.2  list构造函数功能描述：

创建list容器

函数原型：

list&lt;T&gt; lst;                               //list采用采用模板类实现,对象的默认构造形式：
list(beg,end);                           //构造函数将[beg, end)区间中的元素拷贝给本身。
list(n,elem);                             //构造函数将n个elem拷贝给本身。
list(const list &amp;lst);            //拷贝构造函数。

示例：
#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;void test01()&#123;	list&lt;int&gt;L1;	L1.push_back(10);	L1.push_back(20);	L1.push_back(30);	L1.push_back(40);	printList(L1);	list&lt;int&gt;L2(L1.begin(),L1.end());	printList(L2);	list&lt;int&gt;L3(L2);	printList(L3);	list&lt;int&gt;L4(10, 1000);	printList(L4);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：list构造方式同其他几个STL常用容器，熟练掌握即可
3.7.3 list 赋值和交换功能描述：

给list容器进行赋值，以及交换list容器

函数原型：

assign(beg, end);            //将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);              //将n个elem拷贝赋值给本身。
list&amp; operator=(const list &amp;lst);         //重载等号操作符
swap(lst);                         //将lst与本身的元素互换。

示例：
#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123;	list&lt;int&gt;L1;	L1.push_back(10);	L1.push_back(20);	L1.push_back(30);	L1.push_back(40);	printList(L1);	//赋值	list&lt;int&gt;L2;	L2 = L1;	printList(L2);	list&lt;int&gt;L3;	L3.assign(L2.begin(), L2.end());	printList(L3);	list&lt;int&gt;L4;	L4.assign(10, 100);	printList(L4);&#125;//交换void test02()&#123;	list&lt;int&gt;L1;	L1.push_back(10);	L1.push_back(20);	L1.push_back(30);	L1.push_back(40);	list&lt;int&gt;L2;	L2.assign(10, 100);	cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;	printList(L1);	printList(L2);	cout &lt;&lt; endl;	L1.swap(L2);	cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;	printList(L1);	printList(L2);&#125;int main() &#123;	//test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：list赋值和交换操作能够灵活运用即可
3.7.4 list 大小操作功能描述：

对list容器的大小进行操作

函数原型：

size();                             //返回容器中元素的个数

empty();                           //判断容器是否为空

resize(num);                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。
​                        //如果容器变短，则末尾超出容器长度的元素被删除。

resize(num, elem);       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。
                   ​                        //如果容器变短，则末尾超出容器长度的元素被删除。


示例：
#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//大小操作void test01()&#123;	list&lt;int&gt;L1;	L1.push_back(10);	L1.push_back(20);	L1.push_back(30);	L1.push_back(40);	if (L1.empty())	&#123;		cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;	&#125;	//重新指定大小	L1.resize(10);	printList(L1);	L1.resize(2);	printList(L1);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

判断是否为空   —- empty
返回元素个数   —- size
重新指定个数   —- resize

3.7.5 list 插入和删除功能描述：

对list容器进行数据的插入和删除

函数原型：

push_back(elem);//在容器尾部加入一个元素
pop_back();//删除容器中最后一个元素
push_front(elem);//在容器开头插入一个元素
pop_front();//从容器开头移除第一个元素
insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
remove(elem);//删除容器中所有与elem值匹配的元素。

示例：
#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;	list&lt;int&gt; L;	//尾插	L.push_back(10);	L.push_back(20);	L.push_back(30);	//头插	L.push_front(100);	L.push_front(200);	L.push_front(300);	printList(L);	//尾删	L.pop_back();	printList(L);	//头删	L.pop_front();	printList(L);	//插入	list&lt;int&gt;::iterator it = L.begin();	L.insert(++it, 1000);	printList(L);	//删除	it = L.begin();	L.erase(++it);	printList(L);	//移除	L.push_back(10000);	L.push_back(10000);	L.push_back(10000);	printList(L);	L.remove(10000);	printList(L);        //清空	L.clear();	printList(L);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

尾插   —- push_back
尾删   —- pop_back
头插   —- push_front
头删   —- pop_front
插入   —- insert
删除   —- erase
移除   —- remove
清空   —- clear

3.7.6 list 数据存取功能描述：

对list容器中数据进行存取

函数原型：

front();        //返回第一个元素。
back();         //返回最后一个元素。

示例：
#include &lt;list&gt;//数据存取void test01()&#123;	list&lt;int&gt;L1;	L1.push_back(10);	L1.push_back(20);	L1.push_back(30);	L1.push_back(40);		//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据	//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据	cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;	cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;	//list容器的迭代器是双向迭代器，不支持随机访问	list&lt;int&gt;::iterator it = L1.begin();	//it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

list容器中不可以通过[]或者at方式访问数据
返回第一个元素   —- front
返回最后一个元素   —- back

3.7.7 list 反转和排序功能描述：

将容器中的元素反转，以及将容器中的数据进行排序

函数原型：

reverse();   //反转链表
sort();        //链表排序

示例：
void printList(const list&lt;int&gt;&amp; L) &#123;	for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123;	return val1 &gt; val2;&#125;//反转和排序void test01()&#123;	list&lt;int&gt; L;	L.push_back(90);	L.push_back(30);	L.push_back(20);	L.push_back(70);	printList(L);	//反转容器的元素	L.reverse();	printList(L);	//排序	L.sort(); //默认的排序规则 从小到大	printList(L);	L.sort(myCompare); //指定规则，从大到小	printList(L);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

反转   —- reverse
排序   —- sort （成员函数）

3.7.8 排序案例案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高
排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序
示例：
#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public:	Person(string name, int age , int height) &#123;		m_Name = name;		m_Age = age;		m_Height = height;	&#125;public:	string m_Name;  //姓名	int m_Age;      //年龄	int m_Height;   //身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;	if (p1.m_Age == p2.m_Age) &#123;		return p1.m_Height  &gt; p2.m_Height;	&#125;	else	&#123;		return  p1.m_Age &lt; p2.m_Age;	&#125;&#125;void test01() &#123;	list&lt;Person&gt; L;	Person p1(&quot;刘备&quot;, 35 , 175);	Person p2(&quot;曹操&quot;, 45 , 180);	Person p3(&quot;孙权&quot;, 40 , 170);	Person p4(&quot;赵云&quot;, 25 , 190);	Person p5(&quot;张飞&quot;, 35 , 160);	Person p6(&quot;关羽&quot;, 35 , 200);	L.push_back(p1);	L.push_back(p2);	L.push_back(p3);	L.push_back(p4);	L.push_back(p5);	L.push_back(p6);	for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age               &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;	&#125;	cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;	L.sort(ComparePerson); //排序	for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age               &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序


高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂

3.8 set/ multiset 容器3.8.1 set基本概念简介：

所有元素都会在插入时自动被排序

本质：

set/multiset属于关联式容器，底层结构是用二叉树实现。

set和multiset区别：

set不允许容器中有重复的元素
multiset允许容器中有重复的元素

3.8.2 set构造和赋值功能描述：创建set容器以及赋值
构造：

set&lt;T&gt; st;                        //默认构造函数：
set(const set &amp;st);       //拷贝构造函数

赋值：

set&amp; operator=(const set &amp;st);    //重载等号操作符

示例：
#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;	for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)	&#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//构造和赋值void test01()&#123;	set&lt;int&gt; s1;	s1.insert(10);	s1.insert(30);	s1.insert(20);	s1.insert(40);	printSet(s1);	//拷贝构造	set&lt;int&gt;s2(s1);	printSet(s2);	//赋值	set&lt;int&gt;s3;	s3 = s2;	printSet(s3);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

set容器插入数据时用insert
set容器插入数据的数据会自动排序

3.8.3 set大小和交换功能描述：

统计set容器大小以及交换set容器

函数原型：

size();          //返回容器中元素的数目
empty();        //判断容器是否为空
swap(st);      //交换两个集合容器

示例：
#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;	for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)	&#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//大小void test01()&#123;	set&lt;int&gt; s1;		s1.insert(10);	s1.insert(30);	s1.insert(20);	s1.insert(40);	if (s1.empty())	&#123;		cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;	&#125;&#125;//交换void test02()&#123;	set&lt;int&gt; s1;	s1.insert(10);	s1.insert(30);	s1.insert(20);	s1.insert(40);	set&lt;int&gt; s2;	s2.insert(100);	s2.insert(300);	s2.insert(200);	s2.insert(400);	cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;	printSet(s1);	printSet(s2);	cout &lt;&lt; endl;	cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;	s1.swap(s2);	printSet(s1);	printSet(s2);&#125;int main() &#123;	//test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：

统计大小   —- size
判断是否为空   —- empty
交换容器   —- swap

3.8.4 set插入和删除功能描述：

set容器进行插入数据和删除数据

函数原型：

insert(elem);           //在容器中插入元素。
clear();                    //清除所有元素
erase(pos);              //删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg, end);    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(elem);            //删除容器中值为elem的元素。

示例：
#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;	for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)	&#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;	set&lt;int&gt; s1;	//插入	s1.insert(10);	s1.insert(30);	s1.insert(20);	s1.insert(40);	printSet(s1);	//删除	s1.erase(s1.begin());	printSet(s1);	s1.erase(30);	printSet(s1);	//清空	//s1.erase(s1.begin(), s1.end());	s1.clear();	printSet(s1);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

插入   —- insert
删除   —- erase
清空   —- clear

3.8.5 set查找和统计功能描述：

对set容器进行查找数据以及统计数据

函数原型：

find(key);                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
count(key);                //统计key的元素个数

示例：
#include &lt;set&gt;//查找和统计void test01()&#123;	set&lt;int&gt; s1;	//插入	s1.insert(10);	s1.insert(30);	s1.insert(20);	s1.insert(40);		//查找	set&lt;int&gt;::iterator pos = s1.find(30);	if (pos != s1.end())	&#123;		cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;	&#125;	//统计	int num = s1.count(30);	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

查找   —-  find    （返回的是迭代器）
统计   —-  count  （对于set，结果为0或者1）

3.8.6 set和multiset区别学习目标：

掌握set和multiset的区别

区别：

set不可以插入重复数据，而multiset可以
set插入数据的同时会返回插入结果，表示插入是否成功
multiset不会检测数据，因此可以插入重复数据

示例：
#include &lt;set&gt;//set和multiset区别void test01()&#123;	set&lt;int&gt; s;	pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);	if (ret.second) &#123;		cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;	&#125;	else &#123;		cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;	&#125;	ret = s.insert(10);	if (ret.second) &#123;		cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;	&#125;	else &#123;		cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;	&#125;    	//multiset	multiset&lt;int&gt; ms;	ms.insert(10);	ms.insert(10);	for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

如果不允许插入重复数据可以利用set
如果需要插入重复数据利用multiset

3.8.7 pair对组创建功能描述：

成对出现的数据，利用对组可以返回两个数据

两种创建方式：

pair&lt;type, type&gt; p ( value1, value2 );
pair&lt;type, type&gt; p = make_pair( value1, value2 );

示例：
#include &lt;string&gt;//对组创建void test01()&#123;	pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt;  p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;	pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10);	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：
两种方式都可以创建对组，记住一种即可
3.8.8 set容器排序学习目标：

set容器默认排序规则为从小到大，掌握如何改变排序规则

主要技术点：

利用仿函数，可以改变排序规则

示例一   set存放内置数据类型
#include &lt;set&gt;class MyCompare &#123;public:	bool operator()(int v1, int v2) &#123;		return v1 &gt; v2;	&#125;&#125;;void test01() &#123;    	set&lt;int&gt; s1;	s1.insert(10);	s1.insert(40);	s1.insert(20);	s1.insert(30);	s1.insert(50);	//默认从小到大	for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	//指定排序规则	set&lt;int,MyCompare&gt; s2;	s2.insert(10);	s2.insert(40);	s2.insert(20);	s2.insert(30);	s2.insert(50);	for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：利用仿函数可以指定set容器的排序规则
示例二 set存放自定义数据类型
#include &lt;set&gt;#include &lt;string&gt;class Person&#123;public:	Person(string name, int age)	&#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;	string m_Name;	int m_Age;&#125;;class comparePerson&#123;public:	bool operator()(const Person&amp; p1, const Person &amp;p2)	&#123;		//按照年龄进行排序  降序		return p1.m_Age &gt; p2.m_Age;	&#125;&#125;;void test01()&#123;	set&lt;Person, comparePerson&gt; s;	Person p1(&quot;刘备&quot;, 23);	Person p2(&quot;关羽&quot;, 27);	Person p3(&quot;张飞&quot;, 25);	Person p4(&quot;赵云&quot;, 21);	s.insert(p1);	s.insert(p2);	s.insert(p3);	s.insert(p4);	for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)	&#123;		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：
对于自定义数据类型，set必须指定排序规则才可以插入数据
3.9 map/ multimap容器3.9.1 map基本概念简介：

map中所有元素都是pair
pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）
所有元素都会根据元素的键值自动排序

本质：

map/multimap属于关联式容器，底层结构是用二叉树实现。

优点：

可以根据key值快速找到value值

map和multimap区别：

map不允许容器中有重复key值元素
multimap允许容器中有重复key值元素

3.9.2  map构造和赋值功能描述：

对map容器进行构造和赋值操作

函数原型：
构造：

map&lt;T1, T2&gt; mp;                     //map默认构造函数: 
map(const map &amp;mp);             //拷贝构造函数

赋值：

map&amp; operator=(const map &amp;mp);    //重载等号操作符

示例：
#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)	&#123;		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;	&#125;	cout &lt;&lt; endl;&#125;void test01()&#123;	map&lt;int,int&gt;m; //默认构造	m.insert(pair&lt;int, int&gt;(1, 10));	m.insert(pair&lt;int, int&gt;(2, 20));	m.insert(pair&lt;int, int&gt;(3, 30));	printMap(m);	map&lt;int, int&gt;m2(m); //拷贝构造	printMap(m2);	map&lt;int, int&gt;m3;	m3 = m2; //赋值	printMap(m3);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：map中所有元素都是成对出现，插入数据时候要使用对组
3.9.3 map大小和交换功能描述：

统计map容器大小以及交换map容器

函数原型：

size();          //返回容器中元素的数目
empty();        //判断容器是否为空
swap(st);      //交换两个集合容器

示例：
#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)	&#123;		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;	&#125;	cout &lt;&lt; endl;&#125;void test01()&#123;	map&lt;int, int&gt;m;	m.insert(pair&lt;int, int&gt;(1, 10));	m.insert(pair&lt;int, int&gt;(2, 20));	m.insert(pair&lt;int, int&gt;(3, 30));	if (m.empty())	&#123;		cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;	&#125;&#125;//交换void test02()&#123;	map&lt;int, int&gt;m;	m.insert(pair&lt;int, int&gt;(1, 10));	m.insert(pair&lt;int, int&gt;(2, 20));	m.insert(pair&lt;int, int&gt;(3, 30));	map&lt;int, int&gt;m2;	m2.insert(pair&lt;int, int&gt;(4, 100));	m2.insert(pair&lt;int, int&gt;(5, 200));	m2.insert(pair&lt;int, int&gt;(6, 300));	cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;	printMap(m);	printMap(m2);	cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;	m.swap(m2);	printMap(m);	printMap(m2);&#125;int main() &#123;	test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：

统计大小   —- size
判断是否为空   —- empty
交换容器   —- swap

3.9.4 map插入和删除功能描述：

map容器进行插入数据和删除数据

函数原型：

insert(elem);           //在容器中插入元素。
clear();                    //清除所有元素
erase(pos);              //删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg, end);    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(key);            //删除容器中值为key的元素。

示例：
#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;	for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)	&#123;		cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;	&#125;	cout &lt;&lt; endl;&#125;void test01()&#123;	//插入	map&lt;int, int&gt; m;	//第一种插入方式	m.insert(pair&lt;int, int&gt;(1, 10));	//第二种插入方式	m.insert(make_pair(2, 20));	//第三种插入方式	m.insert(map&lt;int, int&gt;::value_type(3, 30));	//第四种插入方式	m[4] = 40; 	printMap(m);	//删除	m.erase(m.begin());	printMap(m);	m.erase(3);	printMap(m);	//清空	m.erase(m.begin(),m.end());	m.clear();	printMap(m);&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

map插入方式很多，记住其一即可


插入   —- insert 
删除   —- erase
清空   —- clear

3.9.5 map查找和统计功能描述：

对map容器进行查找数据以及统计数据

函数原型：

find(key);                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
count(key);                //统计key的元素个数

示例：
#include &lt;map&gt;//查找和统计void test01()&#123;	map&lt;int, int&gt;m; 	m.insert(pair&lt;int, int&gt;(1, 10));	m.insert(pair&lt;int, int&gt;(2, 20));	m.insert(pair&lt;int, int&gt;(3, 30));	//查找	map&lt;int, int&gt;::iterator pos = m.find(3);	if (pos != m.end())	&#123;		cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;	&#125;	//统计	int num = m.count(3);	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

查找   —-  find    （返回的是迭代器）
统计   —-  count  （对于map，结果为0或者1）

3.9.6 map容器排序学习目标：

map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则

主要技术点:

利用仿函数，可以改变排序规则

示例：
#include &lt;map&gt;class MyCompare &#123;public:	bool operator()(int v1, int v2) &#123;		return v1 &gt; v2;	&#125;&#125;;void test01() &#123;	//默认从小到大排序	//利用仿函数实现从大到小排序	map&lt;int, int, MyCompare&gt; m;	m.insert(make_pair(1, 10));	m.insert(make_pair(2, 20));	m.insert(make_pair(3, 30));	m.insert(make_pair(4, 40));	m.insert(make_pair(5, 50));	for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;		cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：

利用仿函数可以指定map容器的排序规则
对于自定义数据类型，map必须要指定排序规则,同set容器

3.10 案例-员工分组3.10.1 案例描述
公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作
员工信息有: 姓名  工资组成；部门分为：策划、美术、研发
随机给10名员工分配部门和工资
通过multimap进行信息的插入  key(部门编号) value(员工)
分部门显示员工信息

3.10.2 实现步骤
创建10名员工，放到vector中
遍历vector容器，取出每个员工，进行随机分组
分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中
分部门显示员工信息

案例代码：
#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;ctime&gt;/*- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发- 随机给10名员工分配部门和工资- 通过multimap进行信息的插入  key(部门编号) value(员工)- 分部门显示员工信息*/#define CEHUA  0#define MEISHU 1#define YANFA  2class Worker&#123;public:	string m_Name;	int m_Salary;&#125;;void createWorker(vector&lt;Worker&gt;&amp;v)&#123;	string nameSeed = &quot;ABCDEFGHIJ&quot;;	for (int i = 0; i &lt; 10; i++)	&#123;		Worker worker;		worker.m_Name = &quot;员工&quot;;		worker.m_Name += nameSeed[i];		worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999		//将员工放入到容器中		v.push_back(worker);	&#125;&#125;//员工分组void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)&#123;	for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)	&#123;		//产生随机部门编号		int deptId = rand() % 3; // 0 1 2 		//将员工插入到分组中		//key部门编号，value具体员工		m.insert(make_pair(deptId, *it));	&#125;&#125;void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)&#123;	// 0  A  B  C   1  D  E   2  F G ...	cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;	multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);	int count = m.count(CEHUA); // 统计具体人数	int index = 0;	for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)	&#123;		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;	&#125;	cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;	pos = m.find(MEISHU);	count = m.count(MEISHU); // 统计具体人数	index = 0;	for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)	&#123;		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;	&#125;	cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;	pos = m.find(YANFA);	count = m.count(YANFA); // 统计具体人数	index = 0;	for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)	&#123;		cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;	&#125;&#125;int main() &#123;	srand((unsigned int)time(NULL));	//1、创建员工	vector&lt;Worker&gt;vWorker;	createWorker(vWorker);	//2、员工分组	multimap&lt;int, Worker&gt;mWorker;	setGroup(vWorker, mWorker);	//3、分组显示员工	showWorkerByGourp(mWorker);	////测试	//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)	//&#123;	//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;	//&#125;	system(&quot;pause&quot;);	return 0;&#125;
总结：

当数据以键值对形式存在，可以考虑用map 或 multimap

4 STL- 函数对象4.1 函数对象4.1.1 函数对象概念概念：

重载函数调用操作符的类，其对象常称为函数对象
函数对象使用重载的()时，行为类似函数调用，也叫仿函数

本质：
函数对象(仿函数)是一个类，不是一个函数
4.1.2  函数对象使用特点：

函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值
函数对象超出普通函数的概念，函数对象可以有自己的状态
函数对象可以作为参数传递

示例:
#include &lt;string&gt;//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值class MyAdd&#123;public :	int operator()(int v1,int v2)	&#123;		return v1 + v2;	&#125;&#125;;void test01()&#123;	MyAdd myAdd;	cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;&#125;//2、函数对象可以有自己的状态class MyPrint&#123;public:	MyPrint()	&#123;		count = 0;	&#125;	void operator()(string test)	&#123;		cout &lt;&lt; test &lt;&lt; endl;		count++; //统计使用次数	&#125;	int count; //内部自己的状态&#125;;void test02()&#123;	MyPrint myPrint;	myPrint(&quot;hello world&quot;);	myPrint(&quot;hello world&quot;);	myPrint(&quot;hello world&quot;);	cout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl;&#125;//3、函数对象可以作为参数传递void doPrint(MyPrint &amp;mp , string test)&#123;	mp(test);&#125;void test03()&#123;	MyPrint myPrint;	doPrint(myPrint, &quot;Hello C++&quot;);&#125;int main() &#123;	//test01();	//test02();	test03();	system(&quot;pause&quot;);	return 0;&#125;
总结：

仿函数写法非常灵活，可以作为参数进行传递。

4.2  谓词4.2.1 谓词概念概念：

返回bool类型的仿函数称为谓词
如果operator()接受一个参数，那么叫做一元谓词
如果operator()接受两个参数，那么叫做二元谓词

4.2.2 一元谓词示例：
#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive&#123;	bool operator()(int val) &#123;		return val &gt; 5;	&#125;&#125;;void test01() &#123;	vector&lt;int&gt; v;	for (int i = 0; i &lt; 10; i++)	&#123;		v.push_back(i);	&#125;	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());	if (it == v.end()) &#123;		cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;	&#125;	else &#123;		cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：参数只有一个的谓词，称为一元谓词
4.2.3 二元谓词示例：
#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare&#123;public:	bool operator()(int num1, int num2)	&#123;		return num1 &gt; num2;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v;	v.push_back(10);	v.push_back(40);	v.push_back(20);	v.push_back(30);	v.push_back(50);	//默认从小到大	sort(v.begin(), v.end());	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)	&#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;	//使用函数对象改变算法策略，排序从大到小	sort(v.begin(), v.end(), MyCompare());	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)	&#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：参数只有两个的谓词，称为二元谓词
4.3 内建函数对象4.3.1 内建函数对象意义概念：

STL内建了一些函数对象

分类:

算术仿函数

关系仿函数

逻辑仿函数


用法：

这些仿函数所产生的对象，用法和一般函数完全相同
使用内建函数对象，需要引入头文件 #include&lt;functional&gt;

4.3.2 算术仿函数功能描述：

实现四则运算
其中negate是一元运算，其他都是二元运算

仿函数原型：

template&lt;class T&gt; T plus&lt;T&gt;                //加法仿函数
template&lt;class T&gt; T minus&lt;T&gt;              //减法仿函数
template&lt;class T&gt; T multiplies&lt;T&gt;    //乘法仿函数
template&lt;class T&gt; T divides&lt;T&gt;         //除法仿函数
template&lt;class T&gt; T modulus&lt;T&gt;         //取模仿函数
template&lt;class T&gt; T negate&lt;T&gt;           //取反仿函数

示例：
#include &lt;functional&gt;//negatevoid test01()&#123;	negate&lt;int&gt; n;	cout &lt;&lt; n(50) &lt;&lt; endl;&#125;//plusvoid test02()&#123;	plus&lt;int&gt; p;	cout &lt;&lt; p(10, 20) &lt;&lt; endl;&#125;int main() &#123;	test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：使用内建函数对象时，需要引入头文件 #include &lt;functional&gt;
4.3.3 关系仿函数功能描述：

实现关系对比

仿函数原型：

template&lt;class T&gt; bool equal_to&lt;T&gt;                    //等于
template&lt;class T&gt; bool not_equal_to&lt;T&gt;            //不等于
template&lt;class T&gt; bool greater&lt;T&gt;                      //大于
template&lt;class T&gt; bool greater_equal&lt;T&gt;          //大于等于
template&lt;class T&gt; bool less&lt;T&gt;                           //小于
template&lt;class T&gt; bool less_equal&lt;T&gt;               //小于等于

示例：
#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public:	bool operator()(int v1,int v2)	&#123;		return v1 &gt; v2;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v;	v.push_back(10);	v.push_back(30);	v.push_back(50);	v.push_back(40);	v.push_back(20);	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	//自己实现仿函数	//sort(v.begin(), v.end(), MyCompare());	//STL内建仿函数  大于仿函数	sort(v.begin(), v.end(), greater&lt;int&gt;());	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：关系仿函数中最常用的就是greater&lt;&gt;大于
4.3.4 逻辑仿函数功能描述：

实现逻辑运算

函数原型：

template&lt;class T&gt; bool logical_and&lt;T&gt;              //逻辑与
template&lt;class T&gt; bool logical_or&lt;T&gt;                //逻辑或
template&lt;class T&gt; bool logical_not&lt;T&gt;              //逻辑非

示例：
#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123;	vector&lt;bool&gt; v;	v.push_back(true);	v.push_back(false);	v.push_back(true);	v.push_back(false);	for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++)	&#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;	//逻辑非  将v容器搬运到v2中，并执行逻辑非运算	vector&lt;bool&gt; v2;	v2.resize(v.size());	transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;bool&gt;());	for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++)	&#123;		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;	&#125;	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：逻辑仿函数实际应用较少，了解即可
5 STL- 常用算法概述:

算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。


&lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等
&lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数
&lt;functional&gt;定义了一些模板类,用以声明函数对象。

5.1 常用遍历算法学习目标：

掌握常用的遍历算法

算法简介：

for_each     //遍历容器
transform   //搬运容器到另一个容器中

5.1.1 for_each功能描述：

实现遍历容器

函数原型：

for_each(iterator beg, iterator end, _func);
// 遍历算法 遍历容器元素
// beg 开始迭代器
// end 结束迭代器
// _func 函数或者函数对象


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;//普通函数void print01(int val) &#123;	cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;//函数对象class print02 &#123; public:	void operator()(int val) 	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;//for_each算法基本用法void test01() &#123;	vector&lt;int&gt; v;	for (int i = 0; i &lt; 10; i++) 	&#123;		v.push_back(i);	&#125;	//遍历算法	for_each(v.begin(), v.end(), print01);	cout &lt;&lt; endl;	for_each(v.begin(), v.end(), print02());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握
5.1.2 transform功能描述：

搬运容器到另一个容器中

函数原型：

transform(iterator beg1, iterator end1, iterator beg2, _func);

//beg1 源容器开始迭代器
//end1 源容器结束迭代器
//beg2 目标容器开始迭代器
//_func 函数或者函数对象
示例：
#include&lt;vector&gt;#include&lt;algorithm&gt;//常用遍历算法  搬运 transformclass TransForm&#123;public:	int operator()(int val)	&#123;		return val;	&#125;&#125;;class MyPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt;v;	for (int i = 0; i &lt; 10; i++)	&#123;		v.push_back(i);	&#125;	vector&lt;int&gt;vTarget; //目标容器	vTarget.resize(v.size()); // 目标容器需要提前开辟空间	transform(v.begin(), v.end(), vTarget.begin(), TransForm());	for_each(vTarget.begin(), vTarget.end(), MyPrint());&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运
5.2 常用查找算法学习目标：

掌握常用的查找算法

算法简介：

find                     //查找元素
find_if               //按条件查找元素
adjacent_find    //查找相邻重复元素
binary_search    //二分查找法
count                   //统计元素个数
count_if             //按条件统计元素个数

5.2.1 find功能描述：

查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()

函数原型：

find(iterator beg, iterator end, value);
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
// beg 开始迭代器
// end 结束迭代器
// value 查找的元素


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123;	vector&lt;int&gt; v;	for (int i = 0; i &lt; 10; i++) &#123;		v.push_back(i + 1);	&#125;	//查找容器中是否有 5 这个元素	vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5);	if (it == v.end()) 	&#123;		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;	&#125;	else 	&#123;		cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;	&#125;&#125;class Person &#123;public:	Person(string name, int age) 	&#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;	//重载==	bool operator==(const Person&amp; p) 	&#123;		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) 		&#123;			return true;		&#125;		return false;	&#125;public:	string m_Name;	int m_Age;&#125;;void test02() &#123;	vector&lt;Person&gt; v;	//创建数据	Person p1(&quot;aaa&quot;, 10);	Person p2(&quot;bbb&quot;, 20);	Person p3(&quot;ccc&quot;, 30);	Person p4(&quot;ddd&quot;, 40);	v.push_back(p1);	v.push_back(p2);	v.push_back(p3);	v.push_back(p4);	vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);	if (it == v.end()) 	&#123;		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;	&#125;	else 	&#123;		cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;	&#125;&#125;
总结： 利用find可以在容器中找指定的元素，返回值是迭代器
5.2.2 find_if功能描述：

按条件查找元素

函数原型：

find_if(iterator beg, iterator end, _Pred);
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
// beg 开始迭代器
// end 结束迭代器
// _Pred 函数或者谓词（返回bool类型的仿函数）


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;//内置数据类型class GreaterFive&#123;public:	bool operator()(int val)	&#123;		return val &gt; 5;	&#125;&#125;;void test01() &#123;	vector&lt;int&gt; v;	for (int i = 0; i &lt; 10; i++) &#123;		v.push_back(i + 1);	&#125;	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());	if (it == v.end()) &#123;		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;	&#125;	else &#123;		cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl;	&#125;&#125;//自定义数据类型class Person &#123;public:	Person(string name, int age)	&#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;public:	string m_Name;	int m_Age;&#125;;class Greater20&#123;public:	bool operator()(Person &amp;p)	&#123;		return p.m_Age &gt; 20;	&#125;&#125;;void test02() &#123;	vector&lt;Person&gt; v;	//创建数据	Person p1(&quot;aaa&quot;, 10);	Person p2(&quot;bbb&quot;, 20);	Person p3(&quot;ccc&quot;, 30);	Person p4(&quot;ddd&quot;, 40);	v.push_back(p1);	v.push_back(p2);	v.push_back(p3);	v.push_back(p4);	vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());	if (it == v.end())	&#123;		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;	&#125;&#125;int main() &#123;	//test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略
5.2.3 adjacent_find功能描述：

查找相邻重复元素

函数原型：

adjacent_find(iterator beg, iterator end);
// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器
// beg 开始迭代器
// end 结束迭代器
​


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;	vector&lt;int&gt; v;	v.push_back(1);	v.push_back(2);	v.push_back(5);	v.push_back(2);	v.push_back(4);	v.push_back(4);	v.push_back(3);	//查找相邻重复元素	vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());	if (it == v.end()) &#123;		cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;	&#125;	else &#123;		cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;	&#125;&#125;
总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法
5.2.4 binary_search功能描述：

查找指定元素是否存在

函数原型：

bool binary_search(iterator beg, iterator end, value);
// 查找指定的元素，查到 返回true  否则false
// 注意: 在无序序列中不可用
// beg 开始迭代器
// end 结束迭代器
// value 查找的元素


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;	vector&lt;int&gt;v;	for (int i = 0; i &lt; 10; i++)	&#123;		v.push_back(i);	&#125;	//二分查找	bool ret = binary_search(v.begin(), v.end(),2);	if (ret)	&#123;		cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;	&#125;	else	&#123;		cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;	&#125;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列
5.2.5 count功能描述：

统计元素个数

函数原型：

count(iterator beg, iterator end, value);
// 统计元素出现次数
// beg 开始迭代器
// end 结束迭代器
// value 统计的元素


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;//内置数据类型void test01()&#123;	vector&lt;int&gt; v;	v.push_back(1);	v.push_back(2);	v.push_back(4);	v.push_back(5);	v.push_back(3);	v.push_back(4);	v.push_back(4);	int num = count(v.begin(), v.end(), 4);	cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:	Person(string name, int age)	&#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;	bool operator==(const Person &amp; p)	&#123;		if (this-&gt;m_Age == p.m_Age)		&#123;			return true;		&#125;		else		&#123;			return false;		&#125;	&#125;	string m_Name;	int m_Age;&#125;;void test02()&#123;	vector&lt;Person&gt; v;	Person p1(&quot;刘备&quot;, 35);	Person p2(&quot;关羽&quot;, 35);	Person p3(&quot;张飞&quot;, 35);	Person p4(&quot;赵云&quot;, 30);	Person p5(&quot;曹操&quot;, 25);	v.push_back(p1);	v.push_back(p2);	v.push_back(p3);	v.push_back(p4);	v.push_back(p5);        Person p(&quot;诸葛亮&quot;,35);	int num = count(v.begin(), v.end(), p);	cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;	//test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结： 统计自定义数据类型时候，需要配合重载 operator==
5.2.6 count_if功能描述：

按条件统计元素个数

函数原型：

count_if(iterator beg, iterator end, _Pred);
// 按条件统计元素出现次数
// beg 开始迭代器
// end 结束迭代器
// _Pred 谓词
​


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public:	bool operator()(int val)	&#123;		return val &gt;= 4;	&#125;&#125;;//内置数据类型void test01()&#123;	vector&lt;int&gt; v;	v.push_back(1);	v.push_back(2);	v.push_back(4);	v.push_back(5);	v.push_back(3);	v.push_back(4);	v.push_back(4);	int num = count_if(v.begin(), v.end(), Greater4());	cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:	Person(string name, int age)	&#123;		this-&gt;m_Name = name;		this-&gt;m_Age = age;	&#125;	string m_Name;	int m_Age;&#125;;class AgeLess35&#123;public:	bool operator()(const Person &amp;p)	&#123;		return p.m_Age &lt; 35;	&#125;&#125;;void test02()&#123;	vector&lt;Person&gt; v;	Person p1(&quot;刘备&quot;, 35);	Person p2(&quot;关羽&quot;, 35);	Person p3(&quot;张飞&quot;, 35);	Person p4(&quot;赵云&quot;, 30);	Person p5(&quot;曹操&quot;, 25);	v.push_back(p1);	v.push_back(p2);	v.push_back(p3);	v.push_back(p4);	v.push_back(p5);	int num = count_if(v.begin(), v.end(), AgeLess35());	cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;	//test01();	test02();	system(&quot;pause&quot;);	return 0;&#125;
总结：按值统计用count，按条件统计用count_if
5.3 常用排序算法学习目标：

掌握常用的排序算法

算法简介：

sort             //对容器内元素进行排序
random_shuffle   //洗牌   指定范围内的元素随机调整次序
merge           // 容器元素合并，并存储到另一容器中
reverse       // 反转指定范围的元素

5.3.1 sort功能描述：

对容器内元素进行排序

函数原型：

sort(iterator beg, iterator end, _Pred);
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
//  beg    开始迭代器
//  end    结束迭代器
// _Pred  谓词


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;void myPrint(int val)&#123;	cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01() &#123;	vector&lt;int&gt; v;	v.push_back(10);	v.push_back(30);	v.push_back(50);	v.push_back(20);	v.push_back(40);	//sort默认从小到大排序	sort(v.begin(), v.end());	for_each(v.begin(), v.end(), myPrint);	cout &lt;&lt; endl;	//从大到小排序	sort(v.begin(), v.end(), greater&lt;int&gt;());	for_each(v.begin(), v.end(), myPrint);	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：sort属于开发中最常用的算法之一，需熟练掌握
5.3.2 random_shuffle功能描述：

洗牌   指定范围内的元素随机调整次序

函数原型：

random_shuffle(iterator beg, iterator end);
// 指定范围内的元素随机调整次序
// beg 开始迭代器
// end 结束迭代器
​


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	srand((unsigned int)time(NULL));	vector&lt;int&gt; v;	for(int i = 0 ; i &lt; 10;i++)	&#123;		v.push_back(i);	&#125;	for_each(v.begin(), v.end(), myPrint());	cout &lt;&lt; endl;	//打乱顺序	random_shuffle(v.begin(), v.end());	for_each(v.begin(), v.end(), myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子
5.3.3 merge功能描述：

两个容器元素合并，并存储到另一容器中

函数原型：

merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
// 容器元素合并，并存储到另一容器中
// 注意: 两个容器必须是有序的
// beg1   容器1开始迭代器// end1   容器1结束迭代器// beg2   容器2开始迭代器// end2   容器2结束迭代器// dest    目标容器开始迭代器
​


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v1;	vector&lt;int&gt; v2;	for (int i = 0; i &lt; 10 ; i++)     &#123;		v1.push_back(i);		v2.push_back(i + 1);	&#125;	vector&lt;int&gt; vtarget;	//目标容器需要提前开辟空间	vtarget.resize(v1.size() + v2.size());	//合并  需要两个有序序列	merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());	for_each(vtarget.begin(), vtarget.end(), myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：merge合并的两个容器必须的有序序列
5.3.4 reverse功能描述：

将容器内元素进行反转

函数原型：

reverse(iterator beg, iterator end);
// 反转指定范围的元素
// beg 开始迭代器
// end 结束迭代器
​


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v;	v.push_back(10);	v.push_back(30);	v.push_back(50);	v.push_back(20);	v.push_back(40);	cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;	for_each(v.begin(), v.end(), myPrint());	cout &lt;&lt; endl;	cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;	reverse(v.begin(), v.end());	for_each(v.begin(), v.end(), myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：reverse反转区间内元素，面试题可能涉及到
5.4 常用拷贝和替换算法学习目标：

掌握常用的拷贝和替换算法

算法简介：

copy                      // 容器内指定范围的元素拷贝到另一容器中
replace                // 将容器内指定范围的旧元素修改为新元素
replace_if          // 容器内指定范围满足条件的元素替换为新元素
swap                     // 互换两个容器的元素

5.4.1 copy功能描述：

容器内指定范围的元素拷贝到另一容器中

函数原型：

copy(iterator beg, iterator end, iterator dest);
// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置
// beg  开始迭代器
// end  结束迭代器
// dest 目标起始迭代器


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v1;	for (int i = 0; i &lt; 10; i++) &#123;		v1.push_back(i + 1);	&#125;	vector&lt;int&gt; v2;	v2.resize(v1.size());	copy(v1.begin(), v1.end(), v2.begin());	for_each(v2.begin(), v2.end(), myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：利用copy算法在拷贝时，目标容器记得提前开辟空间
5.4.2 replace功能描述：

将容器内指定范围的旧元素修改为新元素

函数原型：

replace(iterator beg, iterator end, oldvalue, newvalue);
// 将区间内旧元素 替换成 新元素
// beg 开始迭代器
// end 结束迭代器
// oldvalue 旧元素
// newvalue 新元素


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v;	v.push_back(20);	v.push_back(30);	v.push_back(20);	v.push_back(40);	v.push_back(50);	v.push_back(10);	v.push_back(20);	cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;	for_each(v.begin(), v.end(), myPrint());	cout &lt;&lt; endl;	//将容器中的20 替换成 2000	cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;	replace(v.begin(), v.end(), 20,2000);	for_each(v.begin(), v.end(), myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：replace会替换区间内满足条件的元素
5.4.3 replace_if功能描述:  

将区间内满足条件的元素，替换成指定元素

函数原型：

replace_if(iterator beg, iterator end, _pred, newvalue);
// 按条件替换元素，满足条件的替换成指定元素
// beg 开始迭代器
// end 结束迭代器
// _pred 谓词
// newvalue 替换的新元素


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;class ReplaceGreater30&#123;public:	bool operator()(int val)	&#123;		return val &gt;= 30;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v;	v.push_back(20);	v.push_back(30);	v.push_back(20);	v.push_back(40);	v.push_back(50);	v.push_back(10);	v.push_back(20);	cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;	for_each(v.begin(), v.end(), myPrint());	cout &lt;&lt; endl;	//将容器中大于等于的30 替换成 3000	cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;	replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);	for_each(v.begin(), v.end(), myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件
5.4.4 swap功能描述：

互换两个容器的元素

函数原型：

swap(container c1, container c2);
// 互换两个容器的元素
// c1容器1
// c2容器2
​


示例：
#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v1;	vector&lt;int&gt; v2;	for (int i = 0; i &lt; 10; i++) &#123;		v1.push_back(i);		v2.push_back(i+100);	&#125;	cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;	for_each(v1.begin(), v1.end(), myPrint());	cout &lt;&lt; endl;	for_each(v2.begin(), v2.end(), myPrint());	cout &lt;&lt; endl;	cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;	swap(v1, v2);	for_each(v1.begin(), v1.end(), myPrint());	cout &lt;&lt; endl;	for_each(v2.begin(), v2.end(), myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：swap交换容器时，注意交换的容器要同种类型
5.5 常用算术生成算法学习目标：

掌握常用的算术生成算法

注意：

算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt;

算法简介：

accumulate      // 计算容器元素累计总和

fill                 // 向容器中添加元素
​


5.5.1 accumulate功能描述：

计算区间内 容器元素累计总和

函数原型：

accumulate(iterator beg, iterator end, value);
// 计算容器元素累计总和
// beg 开始迭代器
// end 结束迭代器
// value 起始值


示例：
#include &lt;numeric&gt;#include &lt;vector&gt;void test01()&#123;	vector&lt;int&gt; v;	for (int i = 0; i &lt;= 100; i++) &#123;		v.push_back(i);	&#125;	int total = accumulate(v.begin(), v.end(), 0);	cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：accumulate使用时头文件注意是 numeric，这个算法很实用
5.5.2 fill功能描述：

向容器中填充指定的元素

函数原型：

fill(iterator beg, iterator end, value);
// 向容器中填充元素
// beg 开始迭代器
// end 结束迭代器
// value 填充的值


示例：
#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v;	v.resize(10);	//填充	fill(v.begin(), v.end(), 100);	for_each(v.begin(), v.end(), myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结：利用fill可以将容器区间内元素填充为 指定的值
5.6 常用集合算法学习目标：

掌握常用的集合算法

算法简介：

set_intersection          // 求两个容器的交集

set_union                       // 求两个容器的并集

set_difference              // 求两个容器的差集
​


5.6.1 set_intersection功能描述：

求两个容器的交集

函数原型：

set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
// 求两个集合的交集
// 注意:两个集合必须是有序序列
// beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器


示例：
#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v1;	vector&lt;int&gt; v2;	for (int i = 0; i &lt; 10; i++)    &#123;		v1.push_back(i);		v2.push_back(i+5);	&#125;	vector&lt;int&gt; vTarget;	//取两个里面较小的值给目标容器开辟空间	vTarget.resize(min(v1.size(), v2.size()));	//返回目标容器的最后一个元素的迭代器地址	vector&lt;int&gt;::iterator itEnd =         set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());	for_each(vTarget.begin(), itEnd, myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结： 

求交集的两个集合必须的有序序列
目标容器开辟空间需要从两个容器中取小值
set_intersection返回值既是交集中最后一个元素的位置

5.6.2 set_union功能描述：

求两个集合的并集

函数原型：

set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
// 求两个集合的并集
// 注意:两个集合必须是有序序列
// beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器
​


示例：
#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v1;	vector&lt;int&gt; v2;	for (int i = 0; i &lt; 10; i++) &#123;		v1.push_back(i);		v2.push_back(i+5);	&#125;	vector&lt;int&gt; vTarget;	//取两个容器的和给目标容器开辟空间	vTarget.resize(v1.size() + v2.size());	//返回目标容器的最后一个元素的迭代器地址	vector&lt;int&gt;::iterator itEnd =         set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());	for_each(vTarget.begin(), itEnd, myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结： 

求并集的两个集合必须的有序序列
目标容器开辟空间需要两个容器相加
set_union返回值既是并集中最后一个元素的位置

5.6.3  set_difference功能描述：

求两个集合的差集

函数原型：

set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);
// 求两个集合的差集
// 注意:两个集合必须是有序序列
// beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器
​


示例：
#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:	void operator()(int val)	&#123;		cout &lt;&lt; val &lt;&lt; &quot; &quot;;	&#125;&#125;;void test01()&#123;	vector&lt;int&gt; v1;	vector&lt;int&gt; v2;	for (int i = 0; i &lt; 10; i++) &#123;		v1.push_back(i);		v2.push_back(i+5);	&#125;	vector&lt;int&gt; vTarget;	//取两个里面较大的值给目标容器开辟空间	vTarget.resize( max(v1.size() , v2.size()));	//返回目标容器的最后一个元素的迭代器地址	cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;	vector&lt;int&gt;::iterator itEnd =         set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());	for_each(vTarget.begin(), itEnd, myPrint());	cout &lt;&lt; endl;	cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;	itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());	for_each(vTarget.begin(), itEnd, myPrint());	cout &lt;&lt; endl;&#125;int main() &#123;	test01();	system(&quot;pause&quot;);	return 0;&#125;
总结： 

求差集的两个集合必须的有序序列
目标容器开辟空间需要从两个容器取较大值
set_difference返回值既是差集中最后一个元素的位置

演讲比赛流程管理系统1、 演讲比赛程序需求
1.1 比赛规则
学校举行一场演讲比赛，共有12个人参加。比赛共两轮，第一轮为淘汰赛，第二轮为决赛。
比赛方式：分组比赛，每组6个人；选手每次要随机分组，进行比赛
每名选手都有对应的编号，如 10001 ~ 10012 
第一轮分为两个小组，每组6个人。 整体按照选手编号进行抽签后顺序演讲。
当小组演讲完后，淘汰组内排名最后的三个选手，前三名晋级，进入下一轮的比赛。
第二轮为决赛，前三名胜出
每轮比赛过后需要显示晋级选手的信息

1.2 程序功能
开始演讲比赛：完成整届比赛的流程，每个比赛阶段需要给用户一个提示，用户按任意键后继续下一个阶段
查看往届记录：查看之前比赛前三名结果，每次比赛都会记录到文件中，文件用.csv后缀名保存
清空比赛记录：将文件中数据清空
退出比赛程序：可以退出当前程序

1.3 程序效果图：
2、 项目创建创建项目步骤如下：

创建新项目
添加文件

2.1 创建项目
打开vs2017后，点击创建新项目，创建新的C++项目

如图：


填写项目名称以及选取项目路径，点击确定生成项目


2.2 添加文件
右键源文件，进行添加文件操作



填写文件名称，点击添加



生成文件成功，效果如下图



至此，项目已创建完毕

3、 创建管理类功能描述：

提供菜单界面与用户交互
对演讲比赛流程进行控制
与文件的读写交互

3.1创建文件
在头文件和源文件的文件夹下分别创建speechManager.h 和 speechManager.cpp文件


3.2 头文件实现在speechManager.h中设计管理类
代码如下：
#pragma once#include&lt;iostream&gt;using namespace std;//演讲管理类class SpeechManager&#123;public:	//构造函数	SpeechManager();	//析构函数	~SpeechManager();&#125;;
3.3 源文件实现在speechManager.cpp中将构造和析构函数空实现补全
#include &quot;speechManager.h&quot;SpeechManager::SpeechManager()&#123;&#125;SpeechManager::~SpeechManager()&#123;&#125;

至此演讲管理类以创建完毕

4、 菜单功能功能描述：与用户的沟通界面
4.1 添加成员函数在管理类speechManager.h中添加成员函数  void show_Menu();

4.2 菜单功能实现
在管理类speechManager.cpp中实现 show_Menu()函数

void SpeechManager::show_Menu()&#123;	cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  欢迎参加演讲比赛 ************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  1.开始演讲比赛  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  2.查看往届记录  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  3.清空比赛记录  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;*************  0.退出比赛程序  *************&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl;	cout &lt;&lt; endl;&#125;
4.3 测试菜单功能
在演讲比赛流程管理系统.cpp中测试菜单功能

代码：
#include&lt;iostream&gt;using namespace std;#include &quot;speechManager.h&quot;int main() &#123;	SpeechManager sm;	sm.show_Menu();	system(&quot;pause&quot;);	return 0;&#125;

运行效果如图：



菜单界面搭建完毕

5、 退出功能5.1  提供功能接口
在main函数中提供分支选择，提供每个功能接口

代码：
int main() &#123;	SpeechManager sm;	int choice = 0; //用来存储用户的选项	while (true)	&#123;		sm.show_Menu();		cout &lt;&lt; &quot;请输入您的选择： &quot; &lt;&lt; endl;		cin &gt;&gt; choice; // 接受用户的选项		switch (choice)		&#123;		case 1:  //开始比赛			break;		case 2:  //查看记录			break;		case 3:  //清空记录			break;		case 0:  //退出系统			break;		default:			system(&quot;cls&quot;); //清屏			break;		&#125;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
5.2 实现退出功能在speechManager.h中提供退出系统的成员函数 void exitSystem();
在speechManager.cpp中提供具体的功能实现
void SpeechManager::exitSystem()&#123;	cout &lt;&lt; &quot;欢迎下次使用&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	exit(0);&#125;
5.3测试功能在main函数分支 0  选项中，调用退出程序的接口

运行测试效果如图：

6、演讲比赛功能6.1 功能分析比赛流程分析：
抽签 → 开始演讲比赛 → 显示第一轮比赛结果 → 
抽签 → 开始演讲比赛 → 显示前三名结果 → 保存分数
6.2 创建选手类
选手类中的属性包含：选手姓名、分数
头文件中创建 speaker.h文件，并添加代码：

#pragma once#include&lt;iostream&gt;using namespace std;class Speaker&#123;public:	string m_Name;  //姓名	double m_Score[2]; //分数  最多有两轮得分&#125;;
6.3 比赛6.3.1 成员属性添加
在speechManager.h中添加属性

//比赛选手 容器  12人vector&lt;int&gt;v1;//第一轮晋级容器  6人vector&lt;int&gt;v2;//胜利前三名容器  3人vector&lt;int&gt;vVictory;//存放编号 以及对应的 具体选手 容器map&lt;int, Speaker&gt; m_Speaker;
6.3.2 初始化属性
在speechManager.h中提供开始比赛的的成员函数 void initSpeech();

//初始化属性void initSpeech();

在speechManager.cpp中实现void initSpeech();

void SpeechManager::initSpeech()&#123;	//容器保证为空	this-&gt;v1.clear();  	this-&gt;v2.clear();	this-&gt;vVictory.clear();	this-&gt;m_Speaker.clear();	//初始化比赛轮数	this-&gt;m_Index = 1;&#125;

SpeechManager构造函数中调用void initSpeech();

SpeechManager::SpeechManager()&#123;	//初始化属性	this-&gt;initSpeech();&#125;
6.3.3 创建选手
在speechManager.h中提供开始比赛的的成员函数 void createSpeaker();

//初始化创建12名选手void createSpeaker();

在speechManager.cpp中实现void createSpeaker();

void SpeechManager::createSpeaker()&#123;	string nameSeed = &quot;ABCDEFGHIJKL&quot;;	for (int i = 0; i &lt; nameSeed.size(); i++)	&#123;		string name = &quot;选手&quot;;		name += nameSeed[i];		Speaker sp;		sp.m_Name = name;		for (int i = 0; i &lt; 2; i++)		&#123;			sp.m_Score[i] = 0;		&#125;		//12名选手编号		this-&gt;v1.push_back(i + 10001);		//选手编号 以及对应的选手 存放到map容器中		this-&gt;m_Speaker.insert(make_pair(i + 10001, sp));	&#125;&#125;

SpeechManager类的 构造函数中调用void createSpeaker();

SpeechManager::SpeechManager()&#123;    //初始化属性	this-&gt;initSpeech();    	//创建选手	this-&gt;createSpeaker();&#125;

测试 在main函数中，可以在创建完管理对象后，使用下列代码测试12名选手初始状态

for (map&lt;int, Speaker&gt;::iterator it = sm.m_Speaker.begin(); it != sm.m_Speaker.end(); it++)&#123;	cout  &lt;&lt; &quot;选手编号：&quot; &lt;&lt; it-&gt;first           &lt;&lt; &quot; 姓名： &quot; &lt;&lt; it-&gt;second.m_Name           &lt;&lt; &quot; 成绩： &quot; &lt;&lt; it-&gt;second.m_Score[0] &lt;&lt; endl;&#125;


测试效果如图：



测试完毕后，可以将测试代码删除或注释。

6.3.4 开始比赛成员函数添加
在speechManager.h中提供开始比赛的的成员函数 void startSpeech();
该函数功能是主要控制比赛的流程

//开始比赛 - 比赛流程控制void startSpeech();

在speechManager.cpp中将startSpeech的空实现先写入
我们可以先将整个比赛的流程 写到函数中

//开始比赛void SpeechManager::startSpeech()&#123;	//第一轮比赛	//1、抽签		//2、比赛	//3、显示晋级结果	//第二轮比赛	//1、抽签	//2、比赛	//3、显示最终结果	//4、保存分数&#125;
6.3.5 抽签功能描述：

正式比赛前，所有选手的比赛顺序需要打乱，我们只需要将存放选手编号的容器  打乱次序即可


在speechManager.h中提供抽签的的成员函数 void speechDraw();

//抽签void speechDraw();

在speechManager.cpp中实现成员函数 void speechDraw();

void SpeechManager::speechDraw()&#123;	cout &lt;&lt; &quot;第 &lt;&lt; &quot; &lt;&lt; this-&gt;m_Index &lt;&lt; &quot; &gt;&gt; 轮比赛选手正在抽签&quot;&lt;&lt;endl;	cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;抽签后演讲顺序如下：&quot; &lt;&lt; endl;	if (this-&gt;m_Index == 1)	&#123;		random_shuffle(v1.begin(), v1.end());		for (vector&lt;int&gt;::iterator it = v1.begin(); it != v1.end(); it++)		&#123;			cout &lt;&lt; *it &lt;&lt; &quot; &quot;;		&#125;		cout &lt;&lt; endl;	&#125;	else	&#123;		random_shuffle(v2.begin(), v2.end());		for (vector&lt;int&gt;::iterator it = v2.begin(); it != v2.end(); it++)		&#123;			cout &lt;&lt; *it &lt;&lt; &quot; &quot;;		&#125;		cout &lt;&lt; endl;	&#125;	cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	cout &lt;&lt; endl;&#125;

在startSpeech比赛流程控制的函数中，调用抽签函数



在main函数中，分支1选项中，调用开始比赛的接口



测试


6.3.6 开始比赛
在speechManager.h中提供比赛的的成员函数 void speechContest();

//比赛void speechContest();

在speechManager.cpp中实现成员函数 void speechContest();

void SpeechManager::speechContest()&#123;	cout &lt;&lt; &quot;------------- 第&quot;&lt;&lt; this-&gt;m_Index &lt;&lt; &quot;轮正式比赛开始：------------- &quot; &lt;&lt; endl;	multimap&lt;double, int, greater&lt;int&gt;&gt; groupScore; //临时容器，保存key分数 value 选手编号	int num = 0; //记录人员数，6个为1组	vector &lt;int&gt;v_Src;   //比赛的人员容器	if (this-&gt;m_Index == 1)	&#123;		v_Src = v1;	&#125;	else	&#123;		v_Src = v2;	&#125;	//遍历所有参赛选手	for (vector&lt;int&gt;::iterator it = v_Src.begin(); it != v_Src.end(); it++)	&#123;		num++;		//评委打分		deque&lt;double&gt;d;		for (int i = 0; i &lt; 10; i++)		&#123;			double score = (rand() % 401 + 600) / 10.f;  // 600 ~ 1000			//cout &lt;&lt; score &lt;&lt; &quot; &quot;;			d.push_back(score);		&#125;		sort(d.begin(), d.end(), greater&lt;double&gt;());				//排序		d.pop_front();												//去掉最高分		d.pop_back();												//去掉最低分		double sum = accumulate(d.begin(), d.end(), 0.0f);				//获取总分		double avg = sum / (double)d.size();									//获取平均分		//每个人平均分		//cout &lt;&lt; &quot;编号： &quot; &lt;&lt; *it  &lt;&lt; &quot; 选手： &quot; &lt;&lt; this-&gt;m_Speaker[*it].m_Name &lt;&lt; &quot; 获取平均分为： &quot; &lt;&lt; avg &lt;&lt; endl;  //打印分数		this-&gt;m_Speaker[*it].m_Score[this-&gt;m_Index - 1] = avg;		//6个人一组，用临时容器保存		groupScore.insert(make_pair(avg, *it));		if (num % 6 == 0)		&#123;			cout &lt;&lt; &quot;第&quot; &lt;&lt; num / 6 &lt;&lt; &quot;小组比赛名次：&quot; &lt;&lt; endl;			for (multimap&lt;double, int, greater&lt;int&gt;&gt;::iterator it = groupScore.begin(); it != groupScore.end(); it++)			&#123;				cout &lt;&lt; &quot;编号: &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot; 姓名： &quot; &lt;&lt; this-&gt;m_Speaker[it-&gt;second].m_Name &lt;&lt; &quot; 成绩： &quot; &lt;&lt; this-&gt;m_Speaker[it-&gt;second].m_Score[this-&gt;m_Index - 1] &lt;&lt; endl;			&#125;			int count = 0;			//取前三名			for (multimap&lt;double, int, greater&lt;int&gt;&gt;::iterator it = groupScore.begin(); it != groupScore.end() &amp;&amp; count &lt; 3; it++, count++)			&#123;				if (this-&gt;m_Index == 1)				&#123;					v2.push_back((*it).second);				&#125;				else				&#123;					vVictory.push_back((*it).second);				&#125;			&#125;			groupScore.clear();			cout &lt;&lt; endl;		&#125;	&#125;	cout &lt;&lt; &quot;------------- 第&quot; &lt;&lt; this-&gt;m_Index &lt;&lt; &quot;轮比赛完毕  ------------- &quot; &lt;&lt; endl;	system(&quot;pause&quot;);&#125;

在startSpeech比赛流程控制的函数中，调用比赛函数



再次运行代码，测试比赛


6.3.7 显示比赛分数
在speechManager.h中提供比赛的的成员函数 void showScore();

//显示比赛结果void showScore();

在speechManager.cpp中实现成员函数 void  showScore();

void SpeechManager::showScore()&#123;	cout &lt;&lt; &quot;---------第&quot; &lt;&lt; this-&gt;m_Index &lt;&lt; &quot;轮晋级选手信息如下：-----------&quot; &lt;&lt; endl;	vector&lt;int&gt;v;	if (this-&gt;m_Index == 1)	&#123;		v = v2;	&#125;	else	&#123;		v = vVictory;	&#125;	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)	&#123;		cout &lt;&lt; &quot;选手编号：&quot; &lt;&lt; *it &lt;&lt; &quot; 姓名： &quot; &lt;&lt; m_Speaker[*it].m_Name &lt;&lt; &quot; 得分： &quot; &lt;&lt; m_Speaker[*it].m_Score[this-&gt;m_Index - 1] &lt;&lt; endl;	&#125;	cout &lt;&lt; endl;	system(&quot;pause&quot;);	system(&quot;cls&quot;);	this-&gt;show_Menu(); &#125;

在startSpeech比赛流程控制的函数中，调用显示比赛分数函数



运行代码，测试效果


6.3.8 第二轮比赛第二轮比赛流程同第一轮，只是比赛的轮是+1，其余流程不变

在startSpeech比赛流程控制的函数中，加入第二轮的流程


测试，将整个比赛流程都跑通

6.4 保存分数功能描述：

将每次演讲比赛的得分记录到文件中

功能实现：

在speechManager.h中添加保存记录的成员函数 void saveRecord();

//保存记录void saveRecord();

在speechManager.cpp中实现成员函数 void saveRecord();

void SpeechManager::saveRecord()&#123;	ofstream ofs;	ofs.open(&quot;speech.csv&quot;, ios::out | ios::app); // 用输出的方式打开文件  -- 写文件	//将每个人数据写入到文件中	for (vector&lt;int&gt;::iterator it = vVictory.begin(); it != vVictory.end(); it++)	&#123;		ofs &lt;&lt; *it &lt;&lt; &quot;,&quot;			&lt;&lt; m_Speaker[*it].m_Score[1] &lt;&lt; &quot;,&quot;;	&#125;	ofs &lt;&lt; endl;    	//关闭文件	ofs.close();    	cout &lt;&lt; &quot;记录已经保存&quot; &lt;&lt; endl;&#125;

在startSpeech比赛流程控制的函数中，最后调用保存记录分数函数



测试，整个比赛完毕后记录保存情况


利用记事本打开文件 speech.csv，里面保存了前三名选手的编号以及得分

至此，整个演讲比赛功能制作完毕！
7、 查看记录7.1 读取记录分数
在speechManager.h中添加保存记录的成员函数 void loadRecord();
添加判断文件是否为空的标志  bool fileIsEmpty;
添加往届记录的容器map&lt;int, vector&lt;string&gt;&gt; m_Record;   

其中m_Record 中的key代表第几届，value记录具体的信息
//读取记录void loadRecord();//文件为空的标志bool fileIsEmpty;//往届记录map&lt;int, vector&lt;string&gt;&gt; m_Record;

在speechManager.cpp中实现成员函数 void loadRecord();

void SpeechManager::loadRecord()&#123;	ifstream ifs(&quot;speech.csv&quot;, ios::in); //输入流对象 读取文件	if (!ifs.is_open())	&#123;		this-&gt;fileIsEmpty = true;		cout &lt;&lt; &quot;文件不存在！&quot; &lt;&lt; endl;		ifs.close();		return;	&#125;	char ch;	ifs &gt;&gt; ch;	if (ifs.eof())	&#123;		cout &lt;&lt; &quot;文件为空!&quot; &lt;&lt; endl;		this-&gt;fileIsEmpty = true;		ifs.close();		return;	&#125;	//文件不为空	this-&gt;fileIsEmpty = false;	ifs.putback(ch); //读取的单个字符放回去	string data;	int index = 0;	while (ifs &gt;&gt; data)	&#123;		//cout &lt;&lt; data &lt;&lt; endl;		vector&lt;string&gt;v;		int pos = -1;		int start = 0;		while (true)		&#123;			pos = data.find(&quot;,&quot;, start); //从0开始查找 &#x27;,&#x27;			if (pos == -1)			&#123;				break; //找不到break返回			&#125;			string tmp = data.substr(start, pos - start); //找到了,进行分割 参数1 起始位置，参数2 截取长度			v.push_back(tmp);			start = pos + 1;		&#125;		this-&gt;m_Record.insert(make_pair(index, v));		index++;	&#125;	ifs.close();&#125;

在SpeechManager构造函数中调用获取往届记录函数


7.2 查看记录功能
在speechManager.h中添加保存记录的成员函数 void showRecord();

//显示往届得分void showRecord();

在speechManager.cpp中实现成员函数 void showRecord();

void SpeechManager::showRecord()&#123;	for (int i = 0; i &lt; this-&gt;m_Record.size(); i++)	&#123;		cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;届 &quot; &lt;&lt;			&quot;冠军编号：&quot; &lt;&lt; this-&gt;m_Record[i][0] &lt;&lt; &quot; 得分：&quot; &lt;&lt; this-&gt;m_Record[i][1] &lt;&lt; &quot; &quot;			&quot;亚军编号：&quot; &lt;&lt; this-&gt;m_Record[i][2] &lt;&lt; &quot; 得分：&quot; &lt;&lt; this-&gt;m_Record[i][3] &lt;&lt; &quot; &quot;			&quot;季军编号：&quot; &lt;&lt; this-&gt;m_Record[i][4] &lt;&lt; &quot; 得分：&quot; &lt;&lt; this-&gt;m_Record[i][5] &lt;&lt; endl;	&#125;    system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
7.3 测试功能在main函数分支 2  选项中，调用查看记录的接口

显示效果如图：（本次测试添加了4条记录）

7.4 bug解决目前程序中有几处bug未解决：

查看往届记录，若文件不存在或为空，并未提示

解决方式：在showRecord函数中，开始判断文件状态并加以判断


若记录为空或不存在，比完赛后依然提示记录为空

解决方式：saveRecord中更新文件为空的标志


比完赛后查不到本届比赛的记录，没有实时更新

解决方式：比赛完毕后，所有数据重置


在初始化时，没有初始化记录容器

解决方式：initSpeech中添加 初始化记录容器


每次记录都是一样的

解决方式：在main函数一开始 添加随机数种子
srand((unsigned int)time(NULL));
所有bug解决后 测试：

8、 清空记录8.1 清空记录功能实现
在speechManager.h中添加保存记录的成员函数 void clearRecord();

//清空记录void clearRecord();

在speechManager.cpp中实现成员函数 void clearRecord();

void SpeechManager::clearRecord()&#123;	cout &lt;&lt; &quot;确认清空？&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;1、确认&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;2、返回&quot; &lt;&lt; endl;	int select = 0;	cin &gt;&gt; select;	if (select == 1)	&#123;		//打开模式 ios::trunc 如果存在删除文件并重新创建		ofstream ofs(&quot;speech.csv&quot;, ios::trunc);		ofs.close();		//初始化属性		this-&gt;initSpeech();		//创建选手		this-&gt;createSpeaker();		//获取往届记录		this-&gt;loadRecord();				cout &lt;&lt; &quot;清空成功！&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
8.2 测试清空在main函数分支 3  选项中，调用清空比赛记录的接口

运行程序，测试清空记录：

speech.csv中记录也为空


至此本案例结束！ ^_^

机房预约系统1、机房预约系统需求1.1 系统简介
学校现有几个规格不同的机房，由于使用时经常出现”撞车”现象,现开发一套机房预约系统，解决这一问题。


1.2 身份简介分别有三种身份使用该程序

学生代表：申请使用机房
教师：审核学生的预约申请
管理员：给学生、教师创建账号

1.3 机房简介机房总共有3间

1号机房   —- 最大容量20人
2号机房   —- 最多容量50人
3号机房   —- 最多容量100人

1.4 申请简介
申请的订单每周由管理员负责清空。
学生可以预约未来一周内的机房使用，预约的日期为周一至周五，预约时需要选择预约时段（上午、下午）
教师来审核预约，依据实际情况审核预约通过或者不通过

1.5 系统具体需求
首先进入登录界面，可选登录身份有：
学生代表
老师
管理员
退出


每个身份都需要进行验证后，进入子菜单
学生需要输入 ：学号、姓名、登录密码
老师需要输入：职工号、姓名、登录密码
管理员需要输入：管理员姓名、登录密码


学生具体功能
申请预约    —-   预约机房
查看自身的预约    —-  查看自己的预约状态
查看所有预约   —-   查看全部预约信息以及预约状态
取消预约    —-   取消自身的预约，预约成功或审核中的预约均可取消
注销登录    —-   退出登录


教师具体功能
查看所有预约   —-   查看全部预约信息以及预约状态
审核预约    —-   对学生的预约进行审核
注销登录    —-   退出登录


管理员具体功能
添加账号    —-   添加学生或教师的账号，需要检测学生编号或教师职工号是否重复
查看账号    —-   可以选择查看学生或教师的全部信息
查看机房    —-   查看所有机房的信息
清空预约    —-   清空所有预约记录
注销登录    —-   退出登录




2、创建项目创建项目步骤如下：

创建新项目
添加文件

2.1 创建项目
打开vs2017后，点击创建新项目，创建新的C++项目

如图：


填写项目名称以及选取项目路径，点击确定生成项目


2.2 添加文件
右键源文件，进行添加文件操作



填写文件名称，点击添加



生成文件成功，效果如下图


3、创建主菜单功能描述：

设计主菜单，与用户进行交互

3.1 菜单实现
在主函数main中添加菜单提示，代码如下：

int main() &#123;	cout &lt;&lt; &quot;======================  欢迎来到传智播客机房预约系统  =====================&quot;          &lt;&lt; endl;	cout &lt;&lt; endl &lt;&lt; &quot;请输入您的身份&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;\t\t -------------------------------\n&quot;;	cout &lt;&lt; &quot;\t\t|                               |\n&quot;;	cout &lt;&lt; &quot;\t\t|          1.学生代表           |\n&quot;;	cout &lt;&lt; &quot;\t\t|                               |\n&quot;;	cout &lt;&lt; &quot;\t\t|          2.老    师           |\n&quot;;	cout &lt;&lt; &quot;\t\t|                               |\n&quot;;	cout &lt;&lt; &quot;\t\t|          3.管 理 员           |\n&quot;;	cout &lt;&lt; &quot;\t\t|                               |\n&quot;;	cout &lt;&lt; &quot;\t\t|          0.退    出           |\n&quot;;	cout &lt;&lt; &quot;\t\t|                               |\n&quot;;	cout &lt;&lt; &quot;\t\t -------------------------------\n&quot;;	cout &lt;&lt; &quot;输入您的选择: &quot;;	system(&quot;pause&quot;);	return 0;&#125;
运行效果如图：

3.2 搭建接口
接受用户的选择，搭建接口
在main中添加代码

int main() &#123;	int select = 0;	while (true)	&#123;		cout &lt;&lt; &quot;======================  欢迎来到传智播客机房预约系统  =====================&quot; &lt;&lt; endl;		cout &lt;&lt; endl &lt;&lt; &quot;请输入您的身份&quot; &lt;&lt; endl;		cout &lt;&lt; &quot;\t\t -------------------------------\n&quot;;		cout &lt;&lt; &quot;\t\t|                               |\n&quot;;		cout &lt;&lt; &quot;\t\t|          1.学生代表           |\n&quot;;		cout &lt;&lt; &quot;\t\t|                               |\n&quot;;		cout &lt;&lt; &quot;\t\t|          2.老    师           |\n&quot;;		cout &lt;&lt; &quot;\t\t|                               |\n&quot;;		cout &lt;&lt; &quot;\t\t|          3.管 理 员           |\n&quot;;		cout &lt;&lt; &quot;\t\t|                               |\n&quot;;		cout &lt;&lt; &quot;\t\t|          0.退    出           |\n&quot;;		cout &lt;&lt; &quot;\t\t|                               |\n&quot;;		cout &lt;&lt; &quot;\t\t -------------------------------\n&quot;;		cout &lt;&lt; &quot;输入您的选择: &quot;;		cin &gt;&gt; select; //接受用户选择		switch (select)		&#123;		case 1:  //学生身份			break;		case 2:  //老师身份			break;		case 3:  //管理员身份			break;		case 0:  //退出系统			break;		default:             cout &lt;&lt; &quot;输入有误，请重新选择！&quot; &lt;&lt; endl;		    system(&quot;pause&quot;);			system(&quot;cls&quot;);			break;		&#125;	&#125;	system(&quot;pause&quot;);	return 0;&#125;
测试，输入0、1、2、3会重新回到界面，输入其他提示输入有误，清屏后重新选择
效果如图：

至此，界面搭建完毕
4、 退出功能实现4.1 退出功能实现在main函数分支 0 选项中，添加退出程序的代码：
cout &lt;&lt; &quot;欢迎下一次使用&quot;&lt;&lt;endl;system(&quot;pause&quot;);return 0;

4.2 测试退出功能运行程序，效果如图：

至此，退出程序功能实现
5、 创建身份类5.1 身份的基类
在整个系统中，有三种身份，分别为：学生代表、老师以及管理员
三种身份有其共性也有其特性，因此我们可以将三种身份抽象出一个身份基类identity
在头文件下创建Identity.h文件

Identity.h中添加如下代码：
#pragma once#include&lt;iostream&gt;using namespace std;//身份抽象类class Identity&#123;public:	//操作菜单	virtual void operMenu() = 0;	string m_Name; //用户名	string m_Pwd;  //密码&#125;;
效果如图：

5.2 学生类5.2.1 功能分析
学生类主要功能是可以通过类中成员函数，实现预约实验室操作

学生类中主要功能有：

显示学生操作的菜单界面
申请预约
查看自身预约
查看所有预约
取消预约

​


5.2.2 类的创建
在头文件以及源文件下创建 student.h 和 student.cpp文件

student.h中添加如下代码：
#pragma once#include&lt;iostream&gt;using namespace std;#include &quot;identity.h&quot;//学生类class Student :public Identity&#123;public:	//默认构造	Student();	//有参构造(学号、姓名、密码)	Student(int id, string name, string pwd);	//菜单界面	virtual void operMenu(); 	//申请预约	void applyOrder(); 	//查看我的预约	void showMyOrder(); 	//查看所有预约	void showAllOrder(); 	//取消预约	void cancelOrder();		//学生学号	int m_Id;&#125;;
student.cpp中添加如下代码：
#include &quot;student.h&quot;//默认构造Student::Student()&#123;&#125;//有参构造(学号、姓名、密码)Student::Student(int id, string name, string pwd)&#123;&#125;//菜单界面void Student::operMenu()&#123;&#125;//申请预约void Student::applyOrder()&#123;&#125;//查看我的预约void Student::showMyOrder()&#123;&#125;//查看所有预约void Student::showAllOrder()&#123;&#125;//取消预约void Student::cancelOrder()&#123;&#125;
5.3 老师类5.3.1 功能分析
教师类主要功能是查看学生的预约，并进行审核

教师类中主要功能有：

显示教师操作的菜单界面

查看所有预约

审核预约
​




5.3.2 类的创建
在头文件以及源文件下创建 teacher.h 和 teacher.cpp文件

teacher.h中添加如下代码：
#pragma once#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;#include &quot;identity.h&quot;class Teacher :public Identity&#123;public:	//默认构造	Teacher();	//有参构造 (职工编号，姓名，密码)	Teacher(int empId, string name, string pwd);	//菜单界面	virtual void operMenu();	//查看所有预约	void showAllOrder(); 	//审核预约	void validOrder(); 	int m_EmpId; //教师编号&#125;;

teacher.cpp中添加如下代码:

#include&quot;teacher.h&quot;//默认构造Teacher::Teacher()&#123;&#125;//有参构造 (职工编号，姓名，密码)Teacher::Teacher(int empId, string name, string pwd)&#123;&#125;//菜单界面void Teacher::operMenu()&#123;&#125;//查看所有预约void Teacher::showAllOrder()&#123;&#125;//审核预约void Teacher::validOrder()&#123;&#125;
5.4 管理员类5.4.1 功能分析
管理员类主要功能是对学生和老师账户进行管理，查看机房信息以及清空预约记录

管理员类中主要功能有：

显示管理员操作的菜单界面

添加账号

查看账号

查看机房信息

清空预约记录
​




5.4.2 类的创建
在头文件以及源文件下创建 manager.h 和 manager.cpp文件

manager.h中添加如下代码：
#pragma once#include&lt;iostream&gt;using namespace std;#include &quot;identity.h&quot;class Manager :public Identity&#123;public:	//默认构造	Manager();	//有参构造  管理员姓名，密码	Manager(string name, string pwd);	//选择菜单	virtual void operMenu();	//添加账号  	void addPerson();	//查看账号	void showPerson();	//查看机房信息	void showComputer();	//清空预约记录	void cleanFile();&#125;;

manager.cpp中添加如下代码:

#include &quot;manager.h&quot;//默认构造Manager::Manager()&#123;&#125;//有参构造Manager::Manager(string name, string pwd)&#123;&#125;//选择菜单void Manager::operMenu()&#123;&#125;//添加账号  void Manager::addPerson()&#123;&#125;//查看账号void Manager::showPerson()&#123;&#125;//查看机房信息void Manager::showComputer()&#123;&#125;//清空预约记录void Manager::cleanFile()&#123;&#125;
至此，所有身份类创建完毕，效果如图：

6、  登录模块6.1 全局文件添加功能描述：

不同的身份可能会用到不同的文件操作，我们可以将所有的文件名定义到一个全局的文件中
在头文件中添加 globalFile.h 文件
并添加如下代码：

#pragma once //管理员文件#define ADMIN_FILE     &quot;admin.txt&quot;//学生文件#define STUDENT_FILE   &quot;student.txt&quot;//教师文件#define TEACHER_FILE   &quot;teacher.txt&quot;//机房信息文件#define COMPUTER_FILE  &quot;computerRoom.txt&quot;//订单文件#define ORDER_FILE     &quot;order.txt&quot;
并且在同级目录下，创建这几个文件

6.2  登录函数封装功能描述：

根据用户的选择，进入不同的身份登录

在预约系统的.cpp文件中添加全局函数 void LoginIn(string fileName, int type)
参数：

fileName  —- 操作的文件名
type      —-  登录的身份  （1代表学生、2代表老师、3代表管理员）

LoginIn中添加如下代码：
#include &quot;globalFile.h&quot;#include &quot;identity.h&quot;#include &lt;fstream&gt;#include &lt;string&gt;//登录功能void LoginIn(string fileName, int type)&#123;	Identity * person = NULL;	ifstream ifs;	ifs.open(fileName, ios::in);	//文件不存在情况	if (!ifs.is_open())	&#123;		cout &lt;&lt; &quot;文件不存在&quot; &lt;&lt; endl;		ifs.close();		return;	&#125;	int id = 0;	string name;	string pwd;	if (type == 1)	//学生登录	&#123;		cout &lt;&lt; &quot;请输入你的学号&quot; &lt;&lt; endl;		cin &gt;&gt; id;	&#125;	else if (type == 2) //教师登录	&#123;		cout &lt;&lt; &quot;请输入你的职工号&quot; &lt;&lt; endl;		cin &gt;&gt; id;	&#125;	cout &lt;&lt; &quot;请输入用户名：&quot; &lt;&lt; endl;	cin &gt;&gt; name;	cout &lt;&lt; &quot;请输入密码： &quot; &lt;&lt; endl;	cin &gt;&gt; pwd;	if (type == 1)	&#123;		//学生登录验证	&#125;	else if (type == 2)	&#123;		//教师登录验证	&#125;	else if(type == 3)	&#123;		//管理员登录验证	&#125;		cout &lt;&lt; &quot;验证登录失败!&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	system(&quot;cls&quot;);	return;&#125;

在main函数的不同分支中，填入不同的登录接口


6.3 学生登录实现在student.txt文件中添加两条学生信息，用于测试
添加信息:   
1 张三 1232 李四 123456
其中：

第一列  代表  学号
第二列  代表  学生姓名
第三列  代表  密码

效果图：

在Login函数的学生分支中加入如下代码，验证学生身份
//学生登录验证int fId;string fName;string fPwd;while (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)&#123;	if (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)	&#123;		cout &lt;&lt; &quot;学生验证登录成功!&quot; &lt;&lt; endl;		system(&quot;pause&quot;);		system(&quot;cls&quot;);		person = new Student(id, name, pwd);				return;	&#125;&#125;
添加代码效果图

测试：

6.4 教师登录实现在teacher.txt文件中添加一条老师信息，用于测试
添加信息:   
1 老王 123
其中：

第一列  代表  教师职工编号
第二列  代表  教师姓名
第三列  代表  密码

效果图：

在Login函数的教师分支中加入如下代码，验证教师身份
//教师登录验证int fId;string fName;string fPwd;while (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)&#123;	if (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)	&#123;		cout &lt;&lt; &quot;教师验证登录成功!&quot; &lt;&lt; endl;		system(&quot;pause&quot;);		system(&quot;cls&quot;);		person = new Teacher(id, name, pwd);		return;	&#125;&#125;
添加代码效果图

测试：

6.5 管理员登录实现在admin.txt文件中添加一条管理员信息，由于我们只有一条管理员，因此本案例中没有添加管理员的功能
添加信息:   
admin 123
其中：admin代表管理员用户名，123代表管理员密码
效果图：

在Login函数的管理员分支中加入如下代码，验证管理员身份
//管理员登录验证		string fName;		string fPwd;		while (ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)		&#123;			if (name == fName &amp;&amp; pwd == fPwd)			&#123;				cout &lt;&lt; &quot;验证登录成功!&quot; &lt;&lt; endl;				//登录成功后，按任意键进入管理员界面				system(&quot;pause&quot;);				system(&quot;cls&quot;);				//创建管理员对象				person = new Manager(name,pwd);				return;			&#125;		&#125;
添加效果如图：

测试效果如图：

至此，所有身份的登录功能全部实现！
7、 管理员模块7.1  管理员登录和注销7.1.1 构造函数
在Manager类的构造函数中，初始化管理员信息，代码如下：

//有参构造Manager::Manager(string name, string pwd)&#123;	this-&gt;m_Name = name;	this-&gt;m_Pwd = pwd;&#125;
7.1.2  管理员子菜单
在机房预约系统.cpp中，当用户登录的是管理员，添加管理员菜单接口
将不同的分支提供出来
添加账号
查看账号
查看机房
清空预约
注销登录


实现注销功能

添加全局函数 void managerMenu(Identity * &amp;manager)，代码如下：
//管理员菜单void managerMenu(Identity * &amp;manager)&#123;	while (true)	&#123;		//管理员菜单		manager-&gt;operMenu();		Manager* man = (Manager*)manager;		int select = 0;		cin &gt;&gt; select;        		if (select == 1)  //添加账号		&#123;			cout &lt;&lt; &quot;添加账号&quot; &lt;&lt; endl;			man-&gt;addPerson();		&#125;		else if (select == 2) //查看账号		&#123;			cout &lt;&lt; &quot;查看账号&quot; &lt;&lt; endl;			man-&gt;showPerson(); 		&#125;		else if (select == 3) //查看机房		&#123;			cout &lt;&lt; &quot;查看机房&quot; &lt;&lt; endl;			man-&gt;showComputer();		&#125;		else if (select == 4) //清空预约		&#123;			cout &lt;&lt; &quot;清空预约&quot; &lt;&lt; endl;			man-&gt;cleanFile();		&#125;		else		&#123;			delete manager;			cout &lt;&lt; &quot;注销成功&quot; &lt;&lt; endl;			system(&quot;pause&quot;);			system(&quot;cls&quot;);			return;		&#125;	&#125;&#125;
7.1.3 菜单功能实现
在实现成员函数void Manager::operMenu() 代码如下：

//选择菜单void Manager::operMenu()&#123;	cout &lt;&lt; &quot;欢迎管理员：&quot;&lt;&lt;this-&gt;m_Name &lt;&lt; &quot;登录！&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;\t\t ---------------------------------\n&quot;;	cout &lt;&lt; &quot;\t\t|                                |\n&quot;;	cout &lt;&lt; &quot;\t\t|          1.添加账号            |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                |\n&quot;;	cout &lt;&lt; &quot;\t\t|          2.查看账号            |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                |\n&quot;;	cout &lt;&lt; &quot;\t\t|          3.查看机房            |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                |\n&quot;;	cout &lt;&lt; &quot;\t\t|          4.清空预约            |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                |\n&quot;;	cout &lt;&lt; &quot;\t\t|          0.注销登录            |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                |\n&quot;;	cout &lt;&lt; &quot;\t\t ---------------------------------\n&quot;;	cout &lt;&lt; &quot;请选择您的操作： &quot; &lt;&lt; endl;&#125;
7.1.4 接口对接
管理员成功登录后，调用管理员子菜单界面
在管理员登录验证分支中，添加代码：

//进入管理员子菜单managerMenu(person);
添加效果如：

测试对接，效果如图：

登录成功

注销登录：

至此，管理员身份可以成功登录以及注销
7.2 添加账号功能描述：

给学生或教师添加新的账号

功能要求：

添加时学生学号不能重复、教师职工号不能重复

7.2.1 添加功能实现在Manager的addPerson成员函数中，实现添加新账号功能，代码如下：
//添加账号  void Manager::addPerson()&#123;	cout &lt;&lt; &quot;请输入添加账号的类型&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;1、添加学生&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;2、添加老师&quot; &lt;&lt; endl;	string fileName;	string tip;	ofstream ofs;	int select = 0;	cin &gt;&gt; select;	if (select == 1)	&#123;		fileName = STUDENT_FILE;		tip = &quot;请输入学号： &quot;;	&#125;	else	&#123;		fileName = TEACHER_FILE;		tip = &quot;请输入职工编号：&quot;;	&#125;	ofs.open(fileName, ios::out | ios::app);	int id;	string name;	string pwd;	cout &lt;&lt;tip &lt;&lt; endl;	cin &gt;&gt; id;	cout &lt;&lt; &quot;请输入姓名： &quot; &lt;&lt; endl;	cin &gt;&gt; name;	cout &lt;&lt; &quot;请输入密码： &quot; &lt;&lt; endl;	cin &gt;&gt; pwd;	ofs &lt;&lt; id &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; pwd &lt;&lt; &quot; &quot; &lt;&lt; endl;	cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	system(&quot;cls&quot;);	ofs.close();&#125;
测试添加学生：

成功在学生文件中添加了一条信息

测试添加教师：

成功在教师文件中添加了一条信息

7.2.2 去重操作功能描述：添加新账号时，如果是重复的学生编号，或是重复的教师职工编号，提示有误
7.2.2.1 读取信息
要去除重复的账号，首先要先将学生和教师的账号信息获取到程序中，方可检测
在manager.h中，添加两个容器，用于存放学生和教师的信息
添加一个新的成员函数  void initVector() 初始化容器

//初始化容器void initVector();//学生容器vector&lt;Student&gt; vStu;//教师容器vector&lt;Teacher&gt; vTea;
添加位置如图：

在Manager的有参构造函数中，获取目前的学生和教师信息
代码如下：
void Manager::initVector()&#123;	//读取学生文件中信息	ifstream ifs;	ifs.open(STUDENT_FILE, ios::in);	if (!ifs.is_open())	&#123;		cout &lt;&lt; &quot;文件读取失败&quot; &lt;&lt; endl;		return;	&#125;    	vStu.clear();     vTea.clear();    	Student s;	while (ifs &gt;&gt; s.m_Id &amp;&amp; ifs &gt;&gt; s.m_Name &amp;&amp;  ifs &gt;&gt; s.m_Pwd)	&#123;		vStu.push_back(s);	&#125;	cout &lt;&lt; &quot;当前学生数量为： &quot; &lt;&lt; vStu.size() &lt;&lt; endl;	ifs.close(); //学生初始化	//读取老师文件信息	ifs.open(TEACHER_FILE, ios::in);	Teacher t;	while (ifs &gt;&gt; t.m_EmpId &amp;&amp; ifs &gt;&gt; t.m_Name &amp;&amp;  ifs &gt;&gt; t.m_Pwd)	&#123;		vTea.push_back(t);	&#125;	cout &lt;&lt; &quot;当前教师数量为： &quot; &lt;&lt; vTea.size() &lt;&lt; endl;	ifs.close();&#125;
在有参构造函数中，调用初始化容器函数
//有参构造Manager::Manager(string name, string pwd)&#123;	this-&gt;m_Name = name;	this-&gt;m_Pwd = pwd;    	//初始化容器	this-&gt;initVector();&#125;
测试，运行代码可以看到测试代码获取当前学生和教师数量

7.2.2.2 去重函数封装在manager.h文件中添加成员函数bool checkRepeat(int id, int type);
//检测重复 参数:(传入id，传入类型) 返回值：(true 代表有重复，false代表没有重复)bool checkRepeat(int id, int type);
在manager.cpp文件中实现成员函数  bool checkRepeat(int id, int type);
bool Manager::checkRepeat(int id, int type)&#123;	if (type == 1)	&#123;		for (vector&lt;Student&gt;::iterator it = vStu.begin(); it != vStu.end(); it++)		&#123;			if (id == it-&gt;m_Id)			&#123;				return true;			&#125;		&#125;	&#125;	else	&#123;		for (vector&lt;Teacher&gt;::iterator it = vTea.begin(); it != vTea.end(); it++)		&#123;			if (id == it-&gt;m_EmpId)			&#123;				return true;			&#125;		&#125;	&#125;	return false;&#125;
7.2.2.3 添加去重操作在添加学生编号或者教师职工号时，检测是否有重复，代码如下：
string errorTip; //重复错误提示if (select == 1)&#123;	fileName = STUDENT_FILE;	tip = &quot;请输入学号： &quot;;	errorTip = &quot;学号重复，请重新输入&quot;;&#125;else&#123;	fileName = TEACHER_FILE;	tip = &quot;请输入职工编号：&quot;;	errorTip = &quot;职工号重复，请重新输入&quot;;&#125;ofs.open(fileName, ios::out | ios::app);int id;string name;string pwd;cout &lt;&lt;tip &lt;&lt; endl;while (true)&#123;	cin &gt;&gt; id;	bool ret = this-&gt;checkRepeat(id, 1);	if (ret) //有重复	&#123;		cout &lt;&lt; errorTip &lt;&lt; endl;	&#125;	else	&#123;		break;	&#125;&#125;
代码位置如图：

检测效果：

7.2.2.4 bug解决bug描述：

虽然可以检测重复的账号，但是刚添加的账号由于没有更新到容器中，因此不会做检测
导致刚加入的账号的学生号或者职工编号，再次添加时依然可以重复

解决方案：

在每次添加新账号时，重新初始化容器

在添加完毕后，加入代码：
//初始化容器this-&gt;initVector();
位置如图：

再次测试，刚加入的账号不会重复添加了！
7.3  显示账号功能描述：显示学生信息或教师信息
7.3.1 显示功能实现在Manager的showPerson成员函数中，实现显示账号功能，代码如下：
void printStudent(Student &amp; s)&#123;	cout &lt;&lt; &quot;学号： &quot; &lt;&lt; s.m_Id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; s.m_Name &lt;&lt; &quot; 密码：&quot; &lt;&lt; s.m_Pwd &lt;&lt; endl;&#125;void printTeacher(Teacher &amp; t)&#123;	cout &lt;&lt; &quot;职工号： &quot; &lt;&lt; t.m_EmpId &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t.m_Name &lt;&lt; &quot; 密码：&quot; &lt;&lt; t.m_Pwd &lt;&lt; endl;&#125;void Manager::showPerson()&#123;	cout &lt;&lt; &quot;请选择查看内容：&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;1、查看所有学生&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;2、查看所有老师&quot; &lt;&lt; endl;	int select = 0;	cin &gt;&gt; select;    	if (select == 1)	&#123;		cout &lt;&lt; &quot;所有学生信息如下： &quot; &lt;&lt; endl;		for_each(vStu.begin(), vStu.end(), printStudent);	&#125;	else	&#123;		cout &lt;&lt; &quot;所有老师信息如下： &quot; &lt;&lt; endl;		for_each(vTea.begin(), vTea.end(), printTeacher);	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
7.3.2 测试测试查看学生效果

测试查看教师效果

至此，显示账号功能实现完毕
7.4 查看机房7.4.1 添加机房信息案例需求中，机房一共有三个，其中1号机房容量20台机器，2号50台，3号100台
我们可以将信息录入到computerRoom.txt中

7.4.2 机房类创建在头文件下，创建新的文件 computerRoom.h
并添加如下代码：
#pragma once#include&lt;iostream&gt;using namespace std;//机房类class ComputerRoom&#123;public:	int m_ComId; //机房id号	int m_MaxNum; //机房最大容量&#125;;
7.4.3 初始化机房信息在Manager管理员类下，添加机房的容器,用于保存机房信息
//机房容器vector&lt;ComputerRoom&gt; vCom;
在Manager有参构造函数中，追加如下代码，初始化机房信息
//获取机房信息ifstream ifs;ifs.open(COMPUTER_FILE, ios::in);ComputerRoom c;while (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)&#123;	vCom.push_back(c);&#125;cout &lt;&lt; &quot;当前机房数量为： &quot; &lt;&lt; vCom.size() &lt;&lt; endl;ifs.close();
位置如图：

因为机房信息目前版本不会有所改动，如果后期有修改功能，最好封装到一个函数中，方便维护
7.4.4 显示机房信息在Manager类的showComputer成员函数中添加如下代码：
//查看机房信息void Manager::showComputer()&#123;	cout &lt;&lt; &quot;机房信息如下： &quot; &lt;&lt; endl;	for (vector&lt;ComputerRoom&gt;::iterator it = vCom.begin(); it != vCom.end(); it++)	&#123;		cout &lt;&lt; &quot;机房编号： &quot; &lt;&lt; it-&gt;m_ComId &lt;&lt; &quot; 机房最大容量： &quot; &lt;&lt; it-&gt;m_MaxNum &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
测试显示机房信息功能：

7.5 清空预约功能描述：
清空生成的order.txt预约文件
7.5.1 清空功能实现在Manager的cleanFile成员函数中添加如下代码：
//清空预约记录void Manager::cleanFile()&#123;	ofstream ofs(ORDER_FILE, ios::trunc);	ofs.close();	cout &lt;&lt; &quot;清空成功！&quot; &lt;&lt; endl;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
测试清空，可以随意写入一些信息在order.txt中，然后调用cleanFile清空文件接口，查看是否清空干净
8、 学生模块8.1 学生登录和注销8.1.1 构造函数
在Student类的构造函数中，初始化学生信息，代码如下：

//有参构造(学号、姓名、密码)Student::Student(int id, string name, string pwd)&#123;	//初始化属性	this-&gt;m_Id = id;	this-&gt;m_Name = name;	this-&gt;m_Pwd = pwd;&#125;
8.1.2  管理员子菜单
在机房预约系统.cpp中，当用户登录的是学生，添加学生菜单接口
将不同的分支提供出来
申请预约
查看我的预约
查看所有预约
取消预约
注销登录


实现注销功能

添加全局函数 void studentMenu(Identity * &amp;manager) 代码如下：
//学生菜单void studentMenu(Identity * &amp;student)&#123;	while (true)	&#123;		//学生菜单		student-&gt;operMenu();		Student* stu = (Student*)student;		int select = 0;		cin &gt;&gt; select;		if (select == 1) //申请预约		&#123;			stu-&gt;applyOrder();		&#125;		else if (select == 2) //查看自身预约		&#123;			stu-&gt;showMyOrder();		&#125;		else if (select == 3) //查看所有预约		&#123;			stu-&gt;showAllOrder();		&#125;		else if (select == 4) //取消预约		&#123;			stu-&gt;cancelOrder();		&#125;		else		&#123;			delete student;			cout &lt;&lt; &quot;注销成功&quot; &lt;&lt; endl;			system(&quot;pause&quot;);			system(&quot;cls&quot;);			return;		&#125;	&#125;&#125;
8.1.3 菜单功能实现
在实现成员函数void Student::operMenu() 代码如下：

//菜单界面void Student::operMenu()&#123;	cout &lt;&lt; &quot;欢迎学生代表：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;登录！&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;\t\t ----------------------------------\n&quot;;	cout &lt;&lt; &quot;\t\t|                                 |\n&quot;;	cout &lt;&lt; &quot;\t\t|          1.申请预约              |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                 |\n&quot;;	cout &lt;&lt; &quot;\t\t|          2.查看我的预约          |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                 |\n&quot;;	cout &lt;&lt; &quot;\t\t|          3.查看所有预约          |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                 |\n&quot;;	cout &lt;&lt; &quot;\t\t|          4.取消预约              |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                 |\n&quot;;	cout &lt;&lt; &quot;\t\t|          0.注销登录              |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                 |\n&quot;;	cout &lt;&lt; &quot;\t\t ----------------------------------\n&quot;;	cout &lt;&lt; &quot;请选择您的操作： &quot; &lt;&lt; endl;&#125;
8.1.4 接口对接
学生成功登录后，调用学生的子菜单界面
在学生登录分支中，添加代码：

//进入学生子菜单studentMenu(person);
添加效果如图：

测试对接，效果如图：
登录验证通过：

学生子菜单：

注销登录：

8.2 申请预约8.2.1 获取机房信息
在申请预约时，学生可以看到机房的信息，因此我们需要让学生获取到机房的信息

在student.h中添加新的成员函数如下：
//机房容器vector&lt;ComputerRoom&gt; vCom;
在学生的有参构造函数中追加如下代码：
//获取机房信息ifstream ifs;ifs.open(COMPUTER_FILE, ios::in);ComputerRoom c;while (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)&#123;	vCom.push_back(c);&#125;ifs.close();
追加位置如图：

至此，vCom容器中保存了所有机房的信息
8.2.2 预约功能实现在student.cpp中实现成员函数 void Student::applyOrder()
//申请预约void Student::applyOrder()&#123;	cout &lt;&lt; &quot;机房开放时间为周一至周五！&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;请输入申请预约的时间：&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;1、周一&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;2、周二&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;3、周三&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;4、周四&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;5、周五&quot; &lt;&lt; endl;	int date = 0;	int interval = 0;	int room = 0;	while (true)	&#123;		cin &gt;&gt; date;		if (date &gt;= 1 &amp;&amp; date &lt;= 5)		&#123;			break;		&#125;		cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;	&#125;	cout &lt;&lt; &quot;请输入申请预约的时间段：&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;1、上午&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;2、下午&quot; &lt;&lt; endl;	while (true)	&#123;		cin &gt;&gt; interval;		if (interval &gt;= 1 &amp;&amp; interval &lt;= 2)		&#123;			break;		&#125;		cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;	&#125;	cout &lt;&lt; &quot;请选择机房：&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;1号机房容量：&quot; &lt;&lt; vCom[0].m_MaxNum &lt;&lt; endl;	cout &lt;&lt; &quot;2号机房容量：&quot; &lt;&lt; vCom[1].m_MaxNum &lt;&lt; endl;	cout &lt;&lt; &quot;3号机房容量：&quot; &lt;&lt; vCom[2].m_MaxNum &lt;&lt; endl;	while (true)	&#123;		cin &gt;&gt; room;		if (room &gt;= 1 &amp;&amp; room &lt;= 3)		&#123;			break;		&#125;		cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;	&#125;	cout &lt;&lt; &quot;预约成功！审核中&quot; &lt;&lt; endl;	ofstream ofs(ORDER_FILE, ios::app);	ofs &lt;&lt; &quot;date:&quot; &lt;&lt; date &lt;&lt; &quot; &quot;;	ofs &lt;&lt; &quot;interval:&quot; &lt;&lt; interval &lt;&lt; &quot; &quot;;	ofs &lt;&lt; &quot;stuId:&quot; &lt;&lt; this-&gt;m_Id &lt;&lt; &quot; &quot;;	ofs &lt;&lt; &quot;stuName:&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; &quot;;	ofs &lt;&lt; &quot;roomId:&quot; &lt;&lt; room &lt;&lt; &quot; &quot;;	ofs &lt;&lt; &quot;status:&quot; &lt;&lt; 1 &lt;&lt; endl;	ofs.close();	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
运行程序，测试代码:

在order.txt文件中生成如下内容：

8.3 显示预约8.3.1 创建预约类功能描述：显示预约记录时，需要从文件中获取到所有记录，用来显示，创建预约的类来管理记录以及更新
在头文件以及源文件下分别创建orderFile.h 和 orderFile.cpp文件
orderFile.h中添加如下代码：
#pragma once#include&lt;iostream&gt;using namespace std;#include &lt;map&gt;#include &quot;globalFile.h&quot;class OrderFile&#123;public:	//构造函数	OrderFile();	//更新预约记录	void updateOrder();	//记录的容器  key --- 记录的条数  value --- 具体记录的键值对信息	map&lt;int, map&lt;string, string&gt;&gt; m_orderData;	//预约记录条数	int m_Size;&#125;;
构造函数中获取所有信息，并存放在容器中，添加如下代码：
OrderFile::OrderFile()&#123;	ifstream ifs;	ifs.open(ORDER_FILE, ios::in);	string date;      //日期	string interval;  //时间段	string stuId;     //学生编号	string stuName;   //学生姓名	string roomId;    //机房编号	string status;    //预约状态	this-&gt;m_Size = 0; //预约记录个数	while (ifs &gt;&gt; date &amp;&amp; ifs &gt;&gt; interval &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; roomId &amp;&amp;  ifs &gt;&gt; status)	&#123;		//测试代码		/*		cout &lt;&lt; date &lt;&lt; endl;		cout &lt;&lt; interval &lt;&lt; endl;		cout &lt;&lt; stuId &lt;&lt; endl;		cout &lt;&lt; stuName &lt;&lt; endl;		cout &lt;&lt; roomId &lt;&lt; endl;		cout &lt;&lt; status &lt;&lt; endl;		*/		string key;		string value;		map&lt;string, string&gt; m;		int pos = date.find(&quot;:&quot;);		if (pos != -1)		&#123;			key = date.substr(0, pos);			value = date.substr(pos + 1, date.size() - pos -1);			m.insert(make_pair(key, value));		&#125;		pos = interval.find(&quot;:&quot;);		if (pos != -1)		&#123;			key = interval.substr(0, pos);			value = interval.substr(pos + 1, interval.size() - pos -1 );			m.insert(make_pair(key, value));		&#125;		pos = stuId.find(&quot;:&quot;);		if (pos != -1)		&#123;			key = stuId.substr(0, pos);			value = stuId.substr(pos + 1, stuId.size() - pos -1 );			m.insert(make_pair(key, value));		&#125;		pos = stuName.find(&quot;:&quot;);		if (pos != -1)		&#123;			key = stuName.substr(0, pos);			value = stuName.substr(pos + 1, stuName.size() - pos -1);			m.insert(make_pair(key, value));		&#125;		pos = roomId.find(&quot;:&quot;);		if (pos != -1)		&#123;			key = roomId.substr(0, pos);			value = roomId.substr(pos + 1, roomId.size() - pos -1 );			m.insert(make_pair(key, value));		&#125;		pos = status.find(&quot;:&quot;);		if (pos != -1)		&#123;			key = status.substr(0, pos);			value = status.substr(pos + 1, status.size() - pos -1);			m.insert(make_pair(key, value));		&#125;		this-&gt;m_orderData.insert(make_pair(this-&gt;m_Size, m));		this-&gt;m_Size++;	&#125;	//测试代码	//for (map&lt;int, map&lt;string, string&gt;&gt;::iterator it = m_orderData.begin(); it != m_orderData.end();it++)	//&#123;	//	cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; endl;	//	for (map&lt;string, string&gt;::iterator mit = it-&gt;second.begin(); mit != it-&gt;second.end(); mit++)	//	&#123;	//		cout &lt;&lt; mit-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; mit-&gt;second &lt;&lt; &quot; &quot;;	//	&#125;	//	cout &lt;&lt; endl;	//&#125;        ifs.close();&#125;
更新预约记录的成员函数updateOrder代码如下：
void OrderFile::updateOrder()&#123;	if (this-&gt;m_Size == 0)	&#123;		return;	&#125;	ofstream ofs(ORDER_FILE, ios::out | ios::trunc);	for (int i = 0; i &lt; m_Size;i++)	&#123;		ofs &lt;&lt; &quot;date:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;date&quot;] &lt;&lt; &quot; &quot;;		ofs &lt;&lt; &quot;interval:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;interval&quot;] &lt;&lt; &quot; &quot;;		ofs &lt;&lt; &quot;stuId:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;stuId&quot;] &lt;&lt; &quot; &quot;;		ofs &lt;&lt; &quot;stuName:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;stuName&quot;] &lt;&lt; &quot; &quot;;		ofs &lt;&lt; &quot;roomId:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;roomId&quot;] &lt;&lt; &quot; &quot;;		ofs &lt;&lt; &quot;status:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;status&quot;] &lt;&lt; endl;	&#125;    ofs.close();&#125;
8.3.2 显示自身预约首先我们先添加几条预约记录，可以用程序添加或者直接修改order.txt文件
order.txt文件内容如下： 比如我们有三名同学分别产生了3条预约记录

在Student类的void Student::showMyOrder()成员函数中，添加如下代码
//查看我的预约void Student::showMyOrder()&#123;	OrderFile of;	if (of.m_Size == 0)	&#123;		cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl;		system(&quot;pause&quot;);		system(&quot;cls&quot;);		return;	&#125;	for (int i = 0; i &lt; of.m_Size; i++)	&#123;		if (atoi(of.m_orderData[i][&quot;stuId&quot;].c_str()) == this-&gt;m_Id)		&#123;			cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;];			cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;);			cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;];			string status = &quot; 状态： &quot;;  // 0 取消的预约   1 审核中   2 已预约 -1 预约失败			if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;)			&#123;				status += &quot;审核中&quot;;			&#125;			else if (of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;)			&#123;				status += &quot;预约成功&quot;;			&#125;			else if (of.m_orderData[i][&quot;status&quot;] == &quot;-1&quot;)			&#123;				status += &quot;审核未通过，预约失败&quot;;			&#125;			else			&#123;				status += &quot;预约已取消&quot;;			&#125;			cout &lt;&lt; status &lt;&lt; endl;		&#125;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
测试效果如图：

8.3.3 显示所有预约在Student类的void Student::showAllOrder()成员函数中，添加如下代码
//查看所有预约void Student::showAllOrder()&#123;	OrderFile of;	if (of.m_Size == 0)	&#123;		cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl;		system(&quot;pause&quot;);		system(&quot;cls&quot;);		return;	&#125;	for (int i = 0; i &lt; of.m_Size; i++)	&#123;		cout &lt;&lt; i + 1 &lt;&lt; &quot;、 &quot;;		cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;];		cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;);		cout &lt;&lt; &quot; 学号：&quot; &lt;&lt; of.m_orderData[i][&quot;stuId&quot;];		cout &lt;&lt; &quot; 姓名：&quot; &lt;&lt; of.m_orderData[i][&quot;stuName&quot;];		cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;];		string status = &quot; 状态： &quot;;  // 0 取消的预约   1 审核中   2 已预约 -1 预约失败		if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;)		&#123;			status += &quot;审核中&quot;;		&#125;		else if (of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;)		&#123;			status += &quot;预约成功&quot;;		&#125;		else if (of.m_orderData[i][&quot;status&quot;] == &quot;-1&quot;)		&#123;			status += &quot;审核未通过，预约失败&quot;;		&#125;		else		&#123;			status += &quot;预约已取消&quot;;		&#125;		cout &lt;&lt; status &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
测试效果如图：

8.4 取消预约在Student类的void Student::cancelOrder()成员函数中，添加如下代码
//取消预约void Student::cancelOrder()&#123;	OrderFile of;	if (of.m_Size == 0)	&#123;		cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl;		system(&quot;pause&quot;);		system(&quot;cls&quot;);		return;	&#125;	cout &lt;&lt; &quot;审核中或预约成功的记录可以取消，请输入取消的记录&quot; &lt;&lt; endl;	vector&lt;int&gt;v;	int index = 1;	for (int i = 0; i &lt; of.m_Size; i++)	&#123;		if (atoi(of.m_orderData[i][&quot;stuId&quot;].c_str()) == this-&gt;m_Id)		&#123;			if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot; || of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;)			&#123;				v.push_back(i);				cout &lt;&lt;  index ++  &lt;&lt; &quot;、 &quot;;				cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;];				cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;);				cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;];				string status = &quot; 状态： &quot;;  // 0 取消的预约   1 审核中   2 已预约  -1 预约失败				if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;)				&#123;					status += &quot;审核中&quot;;				&#125;				else if (of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;)				&#123;					status += &quot;预约成功&quot;;				&#125;				cout &lt;&lt; status &lt;&lt; endl;			&#125;		&#125;	&#125;	cout &lt;&lt; &quot;请输入取消的记录,0代表返回&quot; &lt;&lt; endl;	int select = 0;	while (true)	&#123;		cin &gt;&gt; select;		if (select &gt;= 0 &amp;&amp; select &lt;= v.size())		&#123;			if (select == 0)			&#123;				break;			&#125;			else			&#123;				//	cout &lt;&lt; &quot;记录所在位置： &quot; &lt;&lt; v[select - 1] &lt;&lt; endl;				of.m_orderData[v[select - 1]][&quot;status&quot;] = &quot;0&quot;;				of.updateOrder();				cout &lt;&lt; &quot;已取消预约&quot; &lt;&lt; endl;				break;			&#125;		&#125;		cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
测试取消预约：

再次查看个人预约记录：

查看所有预约

查看order.txt预约文件

至此，学生模块功能全部实现
9、 教师模块9.1 教师登录和注销9.1.1 构造函数
在Teacher类的构造函数中，初始化教师信息，代码如下：

//有参构造 (职工编号，姓名，密码)Teacher::Teacher(int empId, string name, string pwd)&#123;	//初始化属性	this-&gt;m_EmpId = empId;	this-&gt;m_Name = name;	this-&gt;m_Pwd = pwd;&#125;
9.1.2  教师子菜单
在机房预约系统.cpp中，当用户登录的是教师，添加教师菜单接口
将不同的分支提供出来
查看所有预约
审核预约
注销登录


实现注销功能

添加全局函数 void TeacherMenu(Person * &amp;manager) 代码如下：
//教师菜单void TeacherMenu(Identity * &amp;teacher)&#123;	while (true)	&#123;		//教师菜单		teacher-&gt;operMenu();		Teacher* tea = (Teacher*)teacher;		int select = 0;		cin &gt;&gt; select;		if (select == 1)		&#123;			//查看所有预约			tea-&gt;showAllOrder();		&#125;		else if (select == 2)		&#123;			//审核预约			tea-&gt;validOrder();		&#125;		else		&#123;			delete teacher;			cout &lt;&lt; &quot;注销成功&quot; &lt;&lt; endl;			system(&quot;pause&quot;);			system(&quot;cls&quot;);			return;		&#125;	&#125;&#125;
9.1.3 菜单功能实现
在实现成员函数void Teacher::operMenu() 代码如下：

//教师菜单界面void Teacher::operMenu()&#123;	cout &lt;&lt; &quot;欢迎教师：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;登录！&quot; &lt;&lt; endl;	cout &lt;&lt; &quot;\t\t ----------------------------------\n&quot;;	cout &lt;&lt; &quot;\t\t|                                  |\n&quot;;	cout &lt;&lt; &quot;\t\t|          1.查看所有预约          |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                  |\n&quot;;	cout &lt;&lt; &quot;\t\t|          2.审核预约              |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                  |\n&quot;;	cout &lt;&lt; &quot;\t\t|          0.注销登录              |\n&quot;;	cout &lt;&lt; &quot;\t\t|                                  |\n&quot;;	cout &lt;&lt; &quot;\t\t ----------------------------------\n&quot;;	cout &lt;&lt; &quot;请选择您的操作： &quot; &lt;&lt; endl;&#125;
9.1.4 接口对接
教师成功登录后，调用教师的子菜单界面
在教师登录分支中，添加代码：

//进入教师子菜单TeacherMenu(person);
添加效果如图：

测试对接，效果如图：
登录验证通过：

教师子菜单：

注销登录：

9.2 查看所有预约9.2.1 所有预约功能实现该功能与学生身份的查看所有预约功能相似，用于显示所有预约记录
在Teacher.cpp中实现成员函数 void Teacher::showAllOrder()
void Teacher::showAllOrder()&#123;	OrderFile of;	if (of.m_Size == 0)	&#123;		cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl;		system(&quot;pause&quot;);		system(&quot;cls&quot;);		return;	&#125;	for (int i = 0; i &lt; of.m_Size; i++)	&#123;		cout &lt;&lt; i + 1 &lt;&lt; &quot;、 &quot;;		cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;];		cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;);		cout &lt;&lt; &quot; 学号：&quot; &lt;&lt; of.m_orderData[i][&quot;stuId&quot;];		cout &lt;&lt; &quot; 姓名：&quot; &lt;&lt; of.m_orderData[i][&quot;stuName&quot;];		cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;];		string status = &quot; 状态： &quot;;  // 0 取消的预约   1 审核中   2 已预约 -1 预约失败		if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;)		&#123;			status += &quot;审核中&quot;;		&#125;		else if (of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;)		&#123;			status += &quot;预约成功&quot;;		&#125;		else if (of.m_orderData[i][&quot;status&quot;] == &quot;-1&quot;)		&#123;			status += &quot;审核未通过，预约失败&quot;;		&#125;		else		&#123;			status += &quot;预约已取消&quot;;		&#125;		cout &lt;&lt; status &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
9.2.2 测试功能运行测试教师身份的查看所有预约功能
测试效果如图：

9.3 审核预约9.3.1 审核功能实现功能描述：教师审核学生的预约，依据实际情况审核预约
在Teacher.cpp中实现成员函数 void Teacher::validOrder()
代码如下：
//审核预约void Teacher::validOrder()&#123;	OrderFile of;	if (of.m_Size == 0)	&#123;		cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl;		system(&quot;pause&quot;);		system(&quot;cls&quot;);		return;	&#125;	cout &lt;&lt; &quot;待审核的预约记录如下：&quot; &lt;&lt; endl;	vector&lt;int&gt;v;	int index = 0;	for (int i = 0; i &lt; of.m_Size; i++)	&#123;		if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;)		&#123;			v.push_back(i);			cout &lt;&lt; ++index &lt;&lt; &quot;、 &quot;;			cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;];			cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;);			cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;];			string status = &quot; 状态： &quot;;  // 0取消的预约   1 审核中   2 已预约  -1 预约失败			if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;)			&#123;				status += &quot;审核中&quot;;			&#125;			cout &lt;&lt; status &lt;&lt; endl;		&#125;	&#125;	cout &lt;&lt; &quot;请输入审核的预约记录,0代表返回&quot; &lt;&lt; endl;	int select = 0;	int ret = 0;	while (true)	&#123;		cin &gt;&gt; select;		if (select &gt;= 0 &amp;&amp; select &lt;= v.size())		&#123;			if (select == 0)			&#123;				break;			&#125;			else			&#123;				cout &lt;&lt; &quot;请输入审核结果&quot; &lt;&lt; endl;				cout &lt;&lt; &quot;1、通过&quot; &lt;&lt; endl;				cout &lt;&lt; &quot;2、不通过&quot; &lt;&lt; endl;				cin &gt;&gt; ret;				if (ret == 1)				&#123;					of.m_orderData[v[select - 1]][&quot;status&quot;] = &quot;2&quot;;				&#125;				else				&#123;					of.m_orderData[v[select - 1]][&quot;status&quot;] = &quot;-1&quot;;				&#125;				of.updateOrder();				cout &lt;&lt; &quot;审核完毕！&quot; &lt;&lt; endl;				break;			&#125;		&#125;		cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;	&#125;	system(&quot;pause&quot;);	system(&quot;cls&quot;);&#125;
9.3.2 测试审核预约测试 - 审核通过

审核通过情况

测试-审核未通过

审核未通过情况：

学生身份下查看记录：

审核预约成功！
至此本案例制作完毕！  ^_^
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O多路复用的三种机制（select、poll、epoll）</title>
    <url>/2025/03/03/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%88%B6%EF%BC%88select%E3%80%81poll%E3%80%81epoll%EF%BC%89/</url>
    <content><![CDATA[I/O多路复用的三种机制（select、poll、epoll）select、poll、epoll是用于I/O所路服用的三种机制，常见于Linux系统中，用于高效处理多个文件描述符的I/O事件。
selectselect是最早的I/O多路复用机制，允许程序监听多个文件描述符，等待其中一个或多个变为可读、可写或出现异常。

特点：

通过fd_set数据结构管理文件描述符。
支持的文件描述符数量有限（通常为1024）。
每次调用都需要将fd_set从用户空间拷贝到内核空间。
每次调用都需要遍历所有文件描述符，时间复杂度为O(n)。


优点：

跨平台支持，几乎所有操作系统都支持了select。


缺点：
文件描述符数量受限。
每次调用都需要拷贝fd_set，效率低。
需要遍历所有文件描述符，性能随文件描述符数量增加而下降。



常用API：int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);FD_ZERO(fd_set *set);          // 清空文件描述符集合FD_SET(int fd, fd_set *set);   // 将文件描述符添加到集合FD_CLR(int fd, fd_set *set);   // 从集合中移除文件描述符FD_ISSET(int fd, fd_set *set); // 检查文件描述符是否在集合中/*使用步骤：1、定义并初始化 fd_set 集合。2、使用 FD_SET 将需要监视的文件描述符添加到集合。3、调用 select 等待文件描述符就绪。4、使用 FD_ISSET 检查哪些文件描述符就绪。*/
poll poll是对`select的改进，使用pollfd结构体管理文件描述符

特点：

使用pollfd结构体管理文件描述符，没有数量上的限制，但是收到系统资源的限制。
每次调用仍然需要将pollfd数组从用户空间拷贝到内核空间。
每次调用都需要遍历所有文件描述符，时间复杂度为O(n)。


优点：

支持的文件描述符数量没有硬性限制。
相比于select更加灵活。


缺点：

每次调用都需要拷贝pollfd，效率低。
需要遍历所有文件描述符，性能随文件描述符数量增加而下降。



常用API：int poll(struct pollfd *fds, nfds_t nfds, int timeout);struct pollfd &#123;    int fd;         // 文件描述符    short events;   // 监视的事件（如 POLLIN、POLLOUT）    short revents;  // 实际发生的事件&#125;;/*使用步骤：1、定义 pollfd 数组，设置需要监视的文件描述符和事件。2、调用 poll 等待文件描述符就绪。3、检查 pollfd 中的 revents 字段，判断哪些文件描述符就绪。*/
epollepoll是Linux特有的高校I/O多路复用机制，解决了select和poll的性能问题。

特点：

使用红黑树和双链表管理文件描述符，支持高校的事件注册和通知。
支持边沿（ET）触发和水平（LT）触发模式。
每次调用不需要拷贝所有文件描述符，只需要返回就绪的事件。
时间复杂度为O(1)，性能不受文件描述符数量影响。


优点：

高效处理大量文件描述符，适合高并发场景。
事件驱动，只返回就绪的事件，无需便利所有的文件描述符。
支持边沿触发模式，减少事件通知次数。


缺点：
仅支持Linux系统，无法跨平台。



常用API：int epoll_create(int size); // 创建 epoll 实例 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 管理文件描述符 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); // 等待事件struct epoll_event &#123;        uint32_t events; // 事件类型（如 EPOLLIN、EPOLLOUT）        epoll_data_t data; // 用户数据 &#125;;/*使用步骤：1. 调用 epoll_create 创建 epoll 实例。2. 使用 epoll_ctl 添加、修改或删除需要监视的文件描述符。3. 调用 epoll_wait 等待文件描述符就绪。4. 处理就绪的事件。*/
事件通知模式/触发机制（LT，ET）水平触发（Level-Triggerred）和边沿触发（Eage_Triggerred）是I/O多路复用机制中的两种时间通知模式，他们决定了何时通知应用程序文件描述符的状态变化。
水平触发（LT）默认的事件通知模式，当文件描述符处于就绪状态时，会持续通知应用程序。
当被监控的Socket上有可读事件发生时，服务器端不断地从epoll_wait中苏醒，直到内核缓冲区被read函数读完才结束，没必要一次执行尽可能多的读写操作。

特点：
只要文件描述符处于就绪状态（例如可读或可写），就会重复通知应用程序。
应用程序可以在一次通知后不完全处理所有数据，下次调用时仍会收到通知。
适用于对事件处理逻辑要求不高的场景。



边沿触发（ET）高效的事件通知模式，只有当文件描述符的状态发生变化时（例如从不可读变为可读），才会通知应用程序。
当被监控的Socket上有可读事件发生时，服务器端只会从epoll_wait中苏醒一次，因此程序需要保证一次将内核缓冲区的数据读取完，因此需要循环的从文件描述符中读取数据，如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，因此，边沿触发模式一般搭配非阻塞I/O使用，程序会一直执行I/O操作。

特点：
只有当文件描述符的状态发生变化时（例如从不可读变为可读），才会通知应用程序。
应用程序需要一次性处理完所有数据，否则可能会丢失后续事件。
适用于高性能场景，但需要更复杂的逻辑。



LT和ET对比



特性
水平触发（LT）
边缘触发（ET）




通知时机
只要文件描述符就绪，就持续通知
只有当文件描述符状态变化时通知


事件处理
可以分多次处理数据
需要一次性处理完所有数据，否则会丢失事件


效率
可能频繁通知，效率较低
减少不必要的通知，效率较高


实现复杂度
简单易用
复杂，需要更精细的逻辑


适用场景
低并发、对性能要求不高的场景
高并发、对性能要求高的场景




三者对比



特性
select
poll
epoll




文件描述符数量限制
有限，通常为1024
无硬性限制
无硬性限制


事件通知机制
遍历所有文件描述符
遍历所有文件描述符
只返回就绪的事件


时间复杂度
O(n)
O(n)
O(1)


内存拷贝
每次调用拷贝fd_set
每次调用拷贝pollfd
不需要拷贝所有文件描述符


触发模式
LT
LT
LT和ET都支持


跨平台性
是
是
仅支持Linux




]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>操作系统</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>LinuxI/O高级函数</title>
    <url>/2025/02/20/LinuxI-O%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[linux 高级I/O函数1、open用于打开或创建文件、设备文件等。
#include &lt;fcntl.h&gt;// 用于打开已存在的文件int open(const char *pathname, int flags);// 用于打开或创建文件，当需要创建文件时使用int open(const char *pathname, int flags, mode_t mode);
pathname：这是一个字符串指针，指向要打开或创建的文件的路径名。可以是绝对路径（如 /home/user/test.txt），也可以是相对路径（如 test.txt）。flags：这是一个整数，用于指定打开文件的方式和一些额外的选项。常用的标志位如下：O_RDONLY：以只读模式打开文件。O_WRONLY：以只写模式打开文件。O_RDWR：以读写模式打开文件。O_CREAT：如果文件不存在，则创建该文件。使用此标志时，需要同时提供第三个参数 mode 来指定文件的权限。O_EXCL：与 O_CREAT 一起使用时，如果文件已经存在，则 open 函数会失败并返回 -1，可用于确保创建一个新文件。O_TRUNC：如果文件存在且以写模式打开，则将文件截断为长度为 0。O_APPEND：以追加模式打开文件，每次写操作都会将数据追加到文件末尾。mode：当使用 O_CREAT 标志时，需要提供此参数来指定新创建文件的权限。mode 是一个八进制数，通常使用 umask 来屏蔽一些权限位。例如，0644 表示文件所有者具有读写权限，而组用户和其他用户具有只读权限。
2、read/write用于执行文件 I/O（输入 / 输出）操作的基础函数，它们可以对文件、设备等进行数据的读取和写入。
#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);
fd：这是一个文件描述符，代表要读取数据的文件、设备等。文件描述符通常是通过 open、socket 等函数返回得到的。buf：这是一个指向缓冲区的指针，用于存储从文件中读取的数据。读取的数据会被存储到这个缓冲区中。count：这是一个 size_t 类型的整数，表示要读取的最大字节数。
返回值正数：表示实际成功读取的字节数。0：表示已经到达文件末尾，没有更多数据可供读取。-1：表示读取操作失败，此时 errno 会被设置为具体的错误码，可以通过 perror 或 strerror 函数来获取错误信息。
3、lseek用于移动文件读写指针的位置。
#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence);
fd：文件描述符，代表要操作的文件。这个文件描述符通常是通过 open 函数打开文件后返回得到的。offset：偏移量，它是一个 off_t 类型的整数，用于指定从 whence 参数所指定的位置开始移动的字节数。可以是正数（表示向文件末尾方向移动）、负数（表示向文件开头方向移动）或 0。whence：指定偏移量的起始位置，它有以下三种取值：SEEK_SET：从文件的开头开始计算偏移量，即 offset 是相对于文件开头的字节数。SEEK_CUR：从文件的当前读写位置开始计算偏移量，offset 是相对于当前位置的字节数。SEEK_END：从文件的末尾开始计算偏移量，offset 是相对于文件末尾的字节数，通常 offset 取负数表示向文件开头方向移动。
返回值成功：返回从文件开头到新的文件读写指针位置的字节数，类型为 off_t。失败：返回 -1，并设置 errno 变量来指示具体的错误原因。常见的错误包括无效的文件描述符、不支持随机访问的设备等。
4、stat/lstat用于获取文件或文件系统对象的状态信息，例如文件的权限、大小、创建时间、修改时间等。不过，它们在处理符号链接时有一些差异。
stat#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int stat(const char *pathname, struct stat *buf);
pathname：一个指向字符串的指针，代表要获取状态信息的文件或目录的路径名。可以是绝对路径（如 /home/user/test.txt），也可以是相对路径（如 test.txt）。buf：一个指向 struct stat 结构体的指针，用于存储获取到的文件状态信息。
struct stat 结构体定义如下：
struct stat &#123;    dev_t     st_dev;         /* 文件所在设备的 ID */    ino_t     st_ino;         /* 文件的 inode 编号 */    mode_t    st_mode;        /* 文件的类型和权限 */    nlink_t   st_nlink;       /* 硬链接的数量 */    uid_t     st_uid;         /* 文件所有者的用户 ID */    gid_t     st_gid;         /* 文件所有者的组 ID */    dev_t     st_rdev;        /* 设备文件的设备 ID */    off_t     st_size;        /* 文件的大小（字节） */    blksize_t st_blksize;     /* 文件系统的块大小 */    blkcnt_t  st_blocks;      /* 文件占用的块数 */    time_t    st_atime;       /* 最后访问时间 */    time_t    st_mtime;       /* 最后修改时间 */    time_t    st_ctime;       /* 最后状态改变时间 */&#125;;
返回值成功：返回 0。失败：返回 -1，并设置 errno 变量来指示具体的错误原因，例如文件不存在、权限不足等。
lstat#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int lstat(const char *pathname, struct stat *buf);
与 stat 函数的参数相同，pathname 是要获取状态信息的文件或目录的路径名，buf 是用于存储文件状态信息的 struct stat 结构体指针。
区别当 pathname 是一个符号链接时，lstat 函数不会跟随符号链接，而是返回符号链接本身的状态信息。这意味着 lstat 函数可以用来判断一个文件是否为符号链接，因为符号链接的 st_mode 字段会有特定的标志位。
如果你需要获取符号链接所指向的目标文件的状态信息，应该使用 stat 函数。如果你需要获取符号链接本身的状态信息，或者判断一个文件是否为符号链接，应该使用 lstat 函数。
5、pipe主要用于在进程间进行通信，创建的管道是一种半双工的通信机制，即数据只能在一个方向上流动
#include&lt;unistd.h&gt;int pipe(int fd[2]);
pipefd是一个包含两个整数的数组，用于存储管道的文件描述符。具体如下：pipefd[0]：表示管道的读端文件描述符，进程可以通过这个文件描述符从管道中读取数据。pipefd[1]：表示管道的写端文件描述符，进程可以通过这个文件描述符向管道中写入数据。
返回值成功：返回 0，并且 pipefd 数组会被正确填充为管道的读端和写端文件描述符。失败：返回 -1，并设置 errno 变量来指示具体的错误原因，常见的错误包括 EMFILE（当前进程已经打开了太多的文件描述符）、ENFILE（系统范围内的文件描述符已经用尽）等。
6、dup/dup2dup用于复制现有的文件描述符。
#include &lt;unistd.h&gt;int dup(int oldfd);
oldfd：需要被复制的现有文件描述符。返回值成功：返回一个新的文件描述符，这个新的文件描述符与 oldfd 指向同一个文件表项。失败：返回 -1，并设置 errno 变量来指示具体的错误原因，例如 EBADF 表示 oldfd 不是一个有效的文件描述符。
dup2dup2 函数同样用于复制文件描述符，但它允许用户指定新的文件描述符的值。
#include &lt;unistd.h&gt;int dup2(int oldfd, int newfd);
oldfd：需要被复制的现有文件描述符。newfd：指定的新文件描述符的值。
返回值成功：返回新的文件描述符（即 newfd）。失败：返回 -1，并设置 errno 变量来指示具体的错误原因，例如 EBADF 表示 oldfd 或 newfd 不是有效的文件描述符。
7、fcntl用于对已打开的文件描述符进行各种控制操作，比如改变文件的访问模式、获取或设置文件状态标志等。
#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* arg */ );
fd：需要进行操作的文件描述符，通常是通过 open、pipe、socket 等函数返回得到的。cmd：指定要执行的操作命令，不同的命令会有不同的功能，并且可能需要额外的参数。常见的命令有以下几类：复制文件描述符：F_DUPFD、F_DUPFD_CLOEXEC。获取 / 设置文件状态标志：F_GETFL、F_SETFL。获取 / 设置文件锁：F_GETLK、F_SETLK、F_SETLKW。获取 / 设置文件描述符标志：F_GETFD、F_SETFD。…：这是一个可变参数，根据 cmd 的不同，可能需要提供额外的参数。例如，当 cmd 为 F_DUPFD 时，需要提供一个整数作为新文件描述符的最小值；当 cmd 为 F_SETFL 时，需要提供一个整数表示要设置的文件状态标志。
返回值成功：返回值取决于具体的 cmd。例如，当 cmd 为 F_DUPFD 时，返回一个新的文件描述符；当 cmd 为 F_GETFL 时，返回文件的状态标志。失败：返回 -1，并设置 errno 变量来指示具体的错误原因，常见的错误包括 EBADF（无效的文件描述符）、EINVAL（无效的 cmd 命令）等。
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Delving into the Trajectory Long-tail Distribution for Muti-object Tracking 总结</title>
    <url>/2024/04/17/Long-tail/</url>
    <content><![CDATA[贴一个原文链接
代码链接

Abstract多目标跟踪一直以来都集中于跟踪算法的的发展和后处理技术的增强，没有对跟踪数据本身的性质进行探索，作者对跟踪数据的分布模式进行探索，发现现有的MOT数据集存在显著的长尾分布问题。作者根据这一发现引入了数据增强策略略————包括静止相机视图数据增强(SVA)和动态相机视图数据增强(DVA)，这两种策略分别针对视点状态和组Softmax (GS)模块设计用于Re-ID。
Introduction作者进行了一项分析实验，对MOTChallenge数据集中不同身份的行人帧数进行统计。如图1所示，作者观察到不同行人身份的帧数差异很大。由于长尾分布的特征是头类具有大量实例而尾类只有少量实例，因此作者得出行人身份的数量服从长尾分布的结论。
长尾分布数据有一个共同的问题：在长尾分布数据上训练的网络通常会导致偏向于学习与流行的头类相关的特征，而忽略了那些较少代表性的尾类。
对于目前多目标跟踪器的Re-ID分支，大多将Re-ID作为分类问题，使用softmax模块计算分类概率。但是softmax模块有一个巨大的缺陷:权值大的类的权值变大，权值小的类的权值变小，这将加剧长尾分布数据上的长尾分布效应。
针对这一问题，作者从信息增强和模块改进两个方向提出解决方案。
对于信息增强，作者根据相机运动状态将摄像机数据分为静态摄像机视图和动态摄像机视图。对于静止摄像机视图，作者提出了静态摄像机视图数据增强(SVA)策略，该策略包括回溯延拓和预测延拓两种技术。对训练序列数据中间帧的尾类行人进行回溯延拓，对训练序列数据最后帧的尾类行人进行预测延拓。该策略可以促进网络对尾类行人轨迹的学习。针对动态摄像机视图数据，提出了动态摄像机视图数据增强(DVA)策略。该策略利用扩散模型对场景背景进行风格转换，提高了网络对行人区域特征的关注。
在模块增强方面，作者设计了Group Softmax (GS)模块。GS将训练样本数量相近的行人分组在一起，然后分别计算每组的softmax和交叉熵损失，避免了头部类权重对尾部类的显著抑制，提高了网络提取尾部类外观特征的能力。
Method作者选择JDE范式，整体流程图如下所示：
Camera View Data Augmentation作者将相机数据分为静态相机数据和动态相机数据，分别采用了不同的数据增强方法。
定义了如下所示的类别划分公式，采用该公式将行人类别划分为头部和尾部。

C_i = 
\begin{cases}
C_i^{tail},  & {\frac{1}{R_i} \ge T_j} \\\\
C_i^{head}, & {\frac{1}{R_i} \lt T_j}
\end{cases}其中 $C_i$ 表示类别i所属的类别， $R_i$ 表示类别 $i$ 的数量与 $j$ 序列中所有类别的数量之比， $T_j$ 表示 $j$ 序列中判断类别是否为尾的类别阈值。
Stationary Camera View Data Augmentation专门针对尾部类别的行人进行数量增强。SVA包括回溯延拓和预测延拓，如图三所示。回溯延续是在原轨迹结束后的后续帧中加入反向的原轨迹，应用于训练序列数据中间帧的尾部类行人。预测延拓是在原轨迹开始的前一帧中加入利用原轨迹位置信息预测的未来轨迹，用于训练序列数据的最后一帧中尾类行人。
Backtracking continuation（回溯延拓）对于一个共有 $F_{total}$ 帧的训练视频，如果尾部类别的行人轨迹在第 $m$ 帧出现，在第 $n$ 帧消失，且满足 $n \lt F_{total}$ 的条件，则使用Segment Anything Model (SAM)算法对第 $m$ 到 $n$ 帧出现的行人图像区域进行分割，然后将这些图像区域以相反的顺序叠加到第 $n$ 帧之后的帧上。回溯延拓可表示为：

BP_j^k = P_i^k(m \le i \le n, n+1 \le j \le BF_{end})其中，$BP_k^j$ 表示训练数据中第 $k$ 个行人在第 $j$ 帧的回溯图像位置， $P_i^k$ 表示训练数据中第 $k$ 个行人在第 $i$ 帧的图像位置， $BF_{end}$ 为训练数据中回溯延拓的截止帧，其值为 $F_{total}$ 和 $(2n−m)$ 的最小值。
Prediction continuation（预测延拓）对于总共有 $F_{total}$ 帧的训练视频，如果尾类的行人轨迹出现在最后一帧，我们将从第 $m$ 帧到第 $F_{total}$ 帧出现的行人的 $x$ 和 $y$ 图像坐标输入到卡尔曼滤波器中，以预测行人后续的 $x$ 和 $y$ 图像坐标，同时确保预测的图像坐标落在图像大小范围内。在该行人轨迹中，我们随机选择能见度不小于能见度阈值 $T_v$ 的行人，其中 $0 \le T_v \le 1$ ，使用SAM算法对行人进行分割。根据从预测图像坐标中随机选择的预测 $x$ 和 $y$ 图像坐标，将分割后的图像区域叠加在行人轨迹出现前的帧上。预测延拓可表示为:

KP_j^k = R(KF \big (P_i^k\big)) (m \le i \le F_{total}, KF_{start} \le j \le m)其中，$KP_j^k$ 表示卡尔曼滤波预测训练数据中第 $k$ 个行人在第 $j$ 帧的图像位置， $R()$ 表示随机选择图像位置的函数，$KF \big (P_i^k\big)$ 表示卡尔曼滤波利用训练数据中第 $i$ 个行人从第 $m$ 帧到 $F_{total}$ 的图像坐标预测的图像位置， $P_i^k$ 表示训练数据中第 $k$ 个行人在第 $i$ 帧的图像位置。 $KF_{start}$ 为训练数据中预测延拓的起始帧，其值为1和 $(2n−m)$ 的最大值。
Dynamic Camera View Data Augmentation动态相机捕获的数据具有场景和主体尺寸变化明显的特点，为了解决这个问题，我们提出了动态摄像机视图数据增强(DVA)策略，如图4所示。该策略包括四个主要步骤:图像分割、图像修复、图像扩散和图像合并。首先使用图像分割算法SAM对序列导出的输入图像中的行人进行分离，得到不包含行人的图像、带有行人遮挡的图像和仅包含行人区域的图像。接下来，使用图像补绘算法Navier-Stokes对去除了行人的图像进行修复，得到修复后的图像。然后，使用稳定扩散对修复后的图像进行处理，得到扩散图像。最后，将前一步分割得到的带有行人遮挡的图像和仅包含行人区域的图像与扩散后的图像合并，生成输出图像。
图像分割SAM是Segment Anything Model的缩写，是Meta迄今为止发布的最大的细分模型。该模型通过将提示和图像作为输入来分割对象。考虑到多目标跟踪数据集提供了边界框注释，但缺乏行人的掩码标签，我们利用图像及其相应的行人边界框标签作为SAM的输入来分割图像中的行人。
图像修复在本文中，用于图像绘制的算法是基于Navier-Stokes方程。
该算法从待修补区域的边缘开始对图像进行修复，沿轮廓线传播图像的平滑度，待所有信息传播完毕后得到修复后的图像。
图像扩散稳定扩散是潜扩散模型(Latent Diffusion Model, LDM)的一种，潜扩散模型是一类能够生成新图像的去噪扩散概率模型。
原则上，稳定扩散可以模拟条件分布。这可以通过输入文本、语义映射或其他图像到图像转换任务信息来控制条件去噪自动编码器来实现。在本文中，作者利用输入图像通过调整提示系数和增强系数来生成新图像。
图像合并我们对带有行人掩模的图像与扩散图像进行位与运算，有效地将扩散图像中与原始行人区域对应的像素值设置为0，而保持行人区域外区域的像素值不变。这就产生了后处理的扩散图像。然后，我们在后处理的扩散图像和仅包含行人的图像之间执行位或操作。实际上，该操作涉及将扩散图像中与原始行人区域对应的像素值设置为仅包含行人的图像的相应像素值，从而得到输出图像。
在使用扩散模型生成的增强数据训练模型时，常常存在过度强调伪特征的风险。为了解决这一问题，常见的解决方案是为原始数据和增强数据分配不同的采样概率，以此来管理数据的不平衡性。我们采用了类似的方法来平衡原始图像和由DVA（动态相机视角数据增强）生成的增强图像。从数学角度，这一方法可以表述为：

I_i^n = 
\begin{cases}
I_i,  & {P_i^n \le T_s} \\\\
\tilde{I_i}, & {P_i^n \gt T_s}
\end{cases}其中 $I_i^n$ 表示第 $n$ 个训练周期中索引为 $i$ 的图像,  $I_i$ 表示索引为 $i$ 的原始图像， $ \tilde{I_i}$ 表示索引为 $i$ 的增强图像。 $P_i^n$ 表示在第 $n$ 个训练周期中索引为 $i$ 的图像被采选为原始图像的概率。 $T_s$ 表示每次图像选择时调用原始图像的阈值。给定索引 $i$ ，将原始图像  $I_i$ 以概率 $T_s$ 加到第 $n$ 个训练周期中，否则将其增广图像 $ \tilde{I_i}$ 加到第 $n$ 个训练周期中。
Group Softmax ModuleRe-ID对不同数量的行人类别有不同程度的特征学习，对于数量较多的类别(头部类)，它往往表现得更好，而对于数量较少的类别(尾部类)，它的效率较低，这可能会对Re-ID的性能产生负面影响。为了解决这个问题，作者提出了Group Softmax (GS)模块。
GS将行人类别划分为若干不相交的组，并对每组分别进行softmax操作。这样，数量相近的行人类别就可以在同一组中竞争。因此，GS可以隔离数量差异显著的类别，防止尾部类别的权重受到头部类别的严重抑制。
具体来说，作者将训练数据集中 $M$ 类行人根据其在训练数据集中的数量分成 $K$ 个不同的组，划分规则为： $T_j^l \le N(i) \le T_j^h i \in (1,M), j \in (1,K)$ ，$N(i)$ 为训练数据集中第 $i$ 类行人的数量， $T_j^l$ 为第 $j$ 组的最低数量阈值， $T_j^h$ 为第 $j$ 组的最高数量阈值。为了保证每类行人只分配给一个组，指定 $T_{j+1}^l = T_j^h+1$。

T_j^h = \frac{j}{K}max(N(i))(1 \le i \le M, 1 \le j \le K)此外，对每个组分别做softmax处理，并利用交叉熵损失计算组损失，并将组损失的均值记为Re-ID损失：

Loss_{Re-ID} = -\frac{1}{K} \sum_{j=1}^K \sum_{i \in G_j }y_ilog(p_i)其中 $G_j$ 表示第 $j$ 组，$y_j$ 表示 $G_j$ 中的标签， $p_j$ 表示 $G_j$ 中的概率。
Experiment

]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>UncertaintyTrack Exploiting Detection and Localization Uncertainty in Multi-Object Tracking</title>
    <url>/2024/04/15/UncertaintyTrack%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[贴一个原文链接这篇文章的代码依旧没有开源

Abstract近年来，大多数多目标跟踪都遵循TbD范式，盲目的相信检测器的检测，而没有意识到可能存在的定位不确定性，会给下游的检测任务带来误差。作者引入了Uncertainty Track，以解释来自概率对象检测器的定位不确定性估计。
IntroductionTbD跟踪器的性能受检测器性能的影响很大，尽管在分布内的数据上有较高的准确性，但对于分布外（out-of-distribution）的数据，则会出现很多错误。但是在自动驾驶领域，处理分布外数据十分重要，因此明确的量化预测输出的潜在不确定性，并且根据不确定性信息进行及时的干预，可以提高跟踪器的性能。
作者的贡献：
1）作者提出了检测不确定性的感知卡尔曼滤波、置信度椭圆滤波、边界框扩展以及基于熵的贪婪匹配。
2）研究了由于使用不同的数据集和检测器而导致的不确定性估计的变化如何影响MOT性能。
3）表明定位不确定性分布的显式参数化为MOT中的人类可解释性和错误来源的识别提供了有意义的见解。
MethodPredicting Bounding Box DistributionsProb-YOLOX Architecture作者在YOLOX的基础上开发了预测边界框的定位不确定性的Prob-YOLOX。
具体来说，作者在预测均值的边界框回归头旁边添加了一个回归头，用于学习对角协方差的对数尺度。然后，这两个头的输出——均值和协方差，共同参数化了一个代表边界框分布的多元高斯分布。通过计算从该分布中抽取的边界框增量样本的样本统计量，模拟了 MC-Dropout 抽样，如下所示：

\begin{aligned}
&\mu_s = \frac{1}{N}\sum_{i=1}^N x_i\\
&{\sum} _s = \frac{1}{N-1}\sum_{i=1}^N (x_i - \mu_s)(x_i - \mu_s)^{\top}\\
\end{aligned}其中$x_i$是第$i$个边界盒样本。然后，将边界框聚在一起，执行NMS来确定集群中心。采用改进的快速协方差相交,以融合相关测量。
Losses在YOLOX中，回归分支使用IoU Loss和L1 Loss进行训练。为了让probi - yolox学习多元高斯分布的参数，我们使用Energy Score loss代替L1 loss：

\begin{aligned}
ES = \frac{1}{N}(\frac{1}{M}\sum^M_{j=1}||z_{n,j}, z_n||)-\frac{1}{2M-1}\sum^{M-1}_{j=1}||z_{n,j}, z_{n,j+1}||)
\end{aligned}开发了Sample-IoU Loss来代替IoU Loss:

\begin{aligned}
Sample - IoU = \frac{1}{N}\sum^M_{n=1}\left(\frac{1}{M}\sum^M_{j=1}IoU(z_{n,j}^*, z_n^*)-\frac{1}{2M-1}\sum^{M-1}_{j=1}IoU(z_{n,j}^*, z_{n,j+1}^*)\right)
\end{aligned}其中 $z_n$ 是gt的边界框，从 $N(\hat{\mu}(x_n,\omega),\hat{\sum}(x_n,\omega))$ 这一概率分布中独立同分布地抽取了M个样本， $z_{n,j}$ 表示第n个gt边界框对应的第j个抽取样本。
其中 $z_n^{\ast}$ 是解码后的gt的边界框，从 $N(\hat{\mu}(x_n,\omega),\hat{\sum}(x_n,\omega))$ ，这一概率分布中独立同分布地抽取了M个解码样本， $z_{n,j}^{\ast}$  表示第n个gt边界框对应的第j个解码样本。
Extending Existing Trackers To Leverage Uncertainty提出四种可能方法来扩展现有的跟踪器。
Detection Uncertainty-Aware Kalman Filter将物体的状态建模为：

\mathbf{x} 
=[ \mathit{x},y,a,h,\dot{x},\dot{y},\dot{a},\dot{h}]^{\top}在目前的MOT中，KF测量不确定度是通过缩放宽高比来计算的，这些系数无法适应检测或跟踪的变化。事实上，这种方法对于较宽的物体比较高的物体产生更大的不确定性。因此，作者建议用Prob-YOLOX预测的协方差矩阵代替测量不确定度。
对于单个物体的检测，Prob-YOLOX输出 $\mu_{box} = [x_1,y_1,x_2,y_2]^{\top}$ ， ${\sum}_{box} \in \Bbb{R}^{4\times4}$ ，表示测量协方差，然后将预测噪声转换为 $[c_x,c_y,a,h]$ 格式后，将其送入卡尔曼滤波的更新。
Confidence Ellipse Filtering（这一部分单看文章不是很懂，还是需要结合代码）
作者建议放弃空间不确定性高于预定阈值的检测。首先，根据95%置信区间为每个边界框的左上角和右下角定义误差椭圆。然后，我们计算它们的轴长和框尺寸之间的比率，并将其与百分比阈值进行比较。数学上，如果箱体宽度为$w_{box}$，高度为 $h_{box}$ ，左上角和右下角误差椭圆的长、短轴长度分别由 $a_{tl}$、$b_{tl}$、$a_{br}$ 和 $b_{br}$ 给出，则只保留满足以下条件的误差椭圆检测：

max(a_{tl},a_{br})\le {\tau_{(i)} \times w_{box}}
\&
  max(b_{tl},b_{br})\le {\tau_{(i)} \times h_{box}}其中 $\tau_{(i)}$ 是预先定义的百分比阈值。
Bounding Box Relaxation在与边界框一起绘制误差椭圆后，作者发现许多ID切换是由检测和轨迹之间的交集不足引起的。有趣的是，其中一些案例的误差椭圆与最后观测到的轨迹重叠。因此，作者建议在最后的匹配步骤中加入根据误差椭圆的极值放大的边界框。更具体地说，计算左上角误差椭圆的 $(x_{min}, y_{min})$ 和右下角误差椭圆的 $(x_{max}, y_{max})$ 。然后用 $[x_{min}, y_{min}x_{max}, y_{max}]$ 定义放大后的边界框。
作者将这种基于不确定性的放大应用于前一步的新检测和跟踪检测，并使用GIoU距离度量对它们进行匹配。此外，为了限制放大量，作者在最后的匹配步骤之前第二次应用椭圆滤波器。
整体流程如图：
Entropy-Based Greedy Matching最后，在与扩展后的检测框的最后匹配步骤中，我们采用基于预测框分布的高斯熵的贪婪匹配来优先考虑不确定性较低(更自信的预测)的检测关联。
Experiment





]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>OC-SORT总结</title>
    <url>/2024/03/15/OC-SORT%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[贴一下原文链接参考：https://blog.csdn.net/wjpwjpwjp0831/article/details/124767905https://blog.csdn.net/weixin_48292639/article/details/124358924

Abstract作者提出了SORT算法中的三个问题，并给出了解决方案。将自己的方法命名为OC-SORT，在保持原有SORT在线、简洁、实时的同时，提高了面对非线性运动和遮挡的鲁棒性。
Introduction作者回顾了SORT算法的问题，表示在面对非线性运动与遮挡时，表现出跟踪鲁棒性不足，且在更新滤波后验参数时无观测值可用。
Three limitations of SORT1）高频帧（足够短的时间间隔）放大了噪声的影响。
2）在KF更新阶段，没有观测值的时候，KF状态估计的噪声会随时间累积。
3）SORT是以目标估计为中心的，所以非常依赖卡尔曼滤波器的的估计，而检测的结果只作为辅助。但是随着目标检测算法的发展，作者认为检测的结果比卡尔曼滤波器的估计结果更加准确，所以在mot中应该更加以检测为中心。
Method为了解决以上三个问题，作者提出了三个解决方案：OOS（Observation-centric Online Smoothing）：减少KF带来的累积误差OCM（Observation-centric Momentum）：在代价矩阵中加入轨迹的方向一致性，更好地实现匹配OCR（Observation-centric Recovery）：恢复由于遮挡造成的跟丢问题
OOS（Observation-centric Online Smoothing）该部分为了解决的问题是: 如果一个目标在untracked状态一段时间后要恢复, 如何减少误差的累积。
具体的做法是建立了一个虚拟轨迹, 轨迹的开始是目标最后一次的位置, 结束是目标再次被发现的位置。 以往的算法是直接根据当前位置预测什么的, 然而作者做的是结合当前的位置和最后一次被发现的位置做一个平滑。
最后一次观测记为z $_{t1} $，再次连接到的轨迹记为z $_{t2} $，则虚拟轨迹为：

作者运用匀速运动模型建立的虚拟轨迹，即：$\hat{z}$ $_t$ = z $_{t1} $ + $\frac{t-t_1}{t_2-t_1}$ (z $_{t2} $-z $_{t1} $)
代入卡尔曼更新的式子：
$\hat{x}$ $_{t|t}$=$\hat{x}$ $_{t|t-1}$+K $_t$($\hat{z}$ $_t$-H $_t$ $\hat{x}$ $_{t|t-1}$)
=F $_t$ $\hat{x}$ $_{t-1|t-1}$ + K $_t$($\hat{z}$ $_t$-H $_t$ F $_t$ $\hat{x}$ $_{t-1|t-1}$ )
OCM（Observation-centric Momentum）线性运动模型假定速度方向一致。然而，由于物体的非线性运动和状态噪声，这种假设往往不成立。在很短时间内，运动轨迹可以近似为线性，但噪声的存在阻止利用速度方向的一致性。于是作者提出了OCM——一种降低噪声的方法，并将速度一致性（动量）项添加到成本矩阵中。给定N条存在的轨迹和M个检测框，关联成本为：
OCR（Observation-centric Recovery）：恢复由于遮挡造成的跟丢问题一旦一条轨迹在正常关联阶段之后仍然没有被跟踪，我们尝试将这条轨迹的最后一次观测与新到来的时间步上的观测进行关联。

]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>BoostTrack：boosting the similarity measure and detection confidence for improved multiple object tracking 总结</title>
    <url>/2024/08/07/boosttrack/</url>
    <content><![CDATA[文章收录于ISCV2023
贴一个原文链接
代码链接
Abstract理想情况下，MOT算法应该只使用真正阳性的检测，避免在实时工作中出现身份切换。为了接近所描述的理想状况，作者提出了BoostTrack，设计了几个轻量化即插即用的模块来提高MOT性能。
Introduction现有的大多数检测方法，为了减少误报（false positive），通常将低置信度的检测过滤，使用置信度较高的检测进行关联。然而并不是所有的低置信度检测都应被过滤。ByteTrack采用两阶段匹配，第一阶段使用高置信度检测，第二阶段使用剩余的检测和不相关的轨迹。
但是使用两阶段甚至多阶段的检测，可能会导致身份转换（ID Switch）。在第一阶段，轨迹错误的与高置信度检测相关联，在第二阶段或者后续阶段也会强制低分检测进行错误的关联。但是如果在第一阶段就同时使用这两种检测，则可以正确匹配它们。
为了同时保证不使用两级关联并利用低置信度检测，作者提出要增强两类检测框：①我们预测一个物体应该存在的边界框；②目前跟踪的物体不应该存在的边界框。
听起来有点抽象，简单来说，就是：
1、增强预测物体存在的边界框：当物体被部分遮挡时，其检测到的边界框置信度可能较低，但预测位置与边界框之间的IoU可能较高。作者建议增加此类检测的检测置信度。
2、增强目前跟踪的物体不应存在的边界框：这听起来有些矛盾，但实际上是说，对于那些出现在不太可能有物体存在的位置上的低置信度检测结果，它们可能是误报（噪声），但也可能是新出现的物体，这些物体可能只有一部分进入了视野。为了识别这些特殊情况，作者采用了Mahalanobis距离度量来找出这些异常值。提高这些检测结果的置信度有助于改进系统的整体性能。
总的来说，为了利用多阶段匹配的优点并规避他的缺点，作者提出了三个模块：
1、利用检测-轨迹点置信度得分对IoU进行缩放，增加高置信度检测轨迹点对的相似度。高方差预测赋予高IoU (或其他任何相似性度量)且置信度相对较低的检测不应与低方差预测、高置信度检测有相同的权重重叠。
2、马氏距离可以作为一种相似性度量来解释估计的轨迹方差。可接受的值取决于轨道的维数和所选择的置信区间，任何变化都需要不同的缩放参数。作者介绍了一种更稳健的使用马氏距离作为相似性度量的方法。
3、为了降低拥挤场景中身份切换的可能性，引入了形状相似度，这是由于移动对象的IoU重叠度过高会导致不匹配的发生。尽管如此，物体(即宽度和高度)的形状应该在短时间内保持相对恒定。

Method作者提出的相似矩阵增强技术与现有方法都可以进行叠加，以提高分配性能。
Detection-tracklet confidence similarity boost为了避免多级匹配且在一级匹配中利用低分检测信息，作者设计该环节来提高低分检测的置信度，将其提高到阈值之上，与高分检测同时进行匹配。
if detection_confidence is not None and track_confidence is not None:    conf = np.multiply(detection_confidence.reshape((-1, 1)), track_confidence.reshape((1, -1)))    conf[iou_matrix &lt; iou_threshold] = 0    cost_matrix += lambda_iou * conf * iou_matrixelse:    warnings.warn(&quot;Detections or tracklet confidence is None and detection-tracklet confidence cannot be computed!&quot;)    conf = None
增强后的代价函数为：

S_{boost} = S_{base}  + \lambda_{IoU}·C \odot IoU(D,T)Mahalanobis distance similarity boost这一部分基于检测与跟踪器之间的马氏距离，增强可能被误认为是噪声的检测框。
伪代码如下：
增强后的代价函数为：

S_{boost} = S_{base}  + \lambda_{MhD}·S^{MhD}(D,T)代码片段：
if mahalanobis_distance is not None and mahalanobis_distance.size &gt; 0: limit = 13.2767  # 99% conf interval https://www.mathworks.com/help/stats/chi2inv.html mask = mahalanobis_distance &gt; limit mahalanobis_distance[mask] = limit mahalanobis_distance = limit - mahalanobis_distance mahalanobis_distance = np.exp(mahalanobis_distance) / np.exp(mahalanobis_distance).sum(0).reshape((1, -1)) mahalanobis_distance = np.where(mask, 0, mahalanobis_distance) cost_matrix += lambda_mhd * mahalanobis_distance
Shape similarity boost在物体高度重叠的情况下，IoU可能会出现歧义，但物体的长宽比在一定时间内保持恒定，可以减少歧义的产生。
但是不应过度依赖于最近未更新的轨迹的形状，因为未更新的时间内目标的高度和宽度都可能发生了变化。
# 计算形状相似度def shape_similarity(detects: np.ndarray, tracks: np.ndarray) -&gt; np.ndarray:    if detects.size == 0 or tracks.size == 0:        return np.zeros((0, 0))    dw = (detects[:, 2] - detects[:, 0]).reshape((-1, 1))    dh = (detects[:, 3] - detects[:, 1]).reshape((-1, 1))    tw = (tracks[:, 2] - tracks[:, 0]).reshape((1, -1))    th = (tracks[:, 3] - tracks[:, 1]).reshape((1, -1))    return np.exp(-(np.abs(dw - tw)/np.maximum(dw, tw) + np.abs(dh - th)/np.maximum(dw, tw)))# 代价函数        if conf is not None:            cost_matrix += lambda_shape * conf * shape_similarity(detections, trackers)
最后的代价矩阵为：

\begin{alignat*}{}
S_{boost} = S_{base}  &+ \lambda_{IoU}·C \odot IoU(D,T) \nonumber \\
                      &+ \lambda_{MhD}·S^{MhD}(D,T)\\
                      &+ \lambda_{shape}·S^{shape}(D,T).
\end{alignat*}Detection confidence boosting techniques# Detecting likely objects    def do_iou_confidence_boost(self, detections: np.ndarray) -&gt; np.ndarray:        iou_matrix = self.get_iou_matrix(detections) # 得到现有检测器和跟踪器之间的IoU        ids = np.zeros(len(detections), dtype=np.bool_)        if iou_matrix.size &gt; 0 and self.frame_count &gt; 1:            max_iou = iou_matrix.max(1)            coef = self.dlo_boost_coef # 一个增强系数            ids[(detections[:, 4] &lt; self.det_thresh) &amp; (max_iou * coef &gt;= self.det_thresh)] = True             # 如果该检测置信度低于阈值，但与某个跟踪器之间的IoU乘以增强系数又高于阈值，则该检测的置信度将被增强。            detections[:, 4] = np.maximum(detections[:, 4], max_iou * coef)        return detections# Detecting “unlikely&quot; objects    def do_mh_dist_confidence_boost(self, detections: np.ndarray) -&gt; np.ndarray:        n_dims = 4        limit = 13.2767          mahalanobis_distance = self.get_mh_dist_matrix(detections, n_dims)        if mahalanobis_distance.size &gt; 0 and self.frame_count &gt; 1:            min_mh_dists = mahalanobis_distance.min(1)            mask = (min_mh_dists &gt; limit) &amp; (detections[:, 4] &lt; self.det_thresh)            # 用布尔索引标记马氏距离大于limit但置信度低于阈值的检测结果            boost_detections = detections[mask]            boost_detections_args = np.argwhere(mask).reshape((-1,))            # 得到需要增强的检测以及他的索引            iou_limit = 0.3            if len(boost_detections) &gt; 0:                bdiou = iou_batch(boost_detections, boost_detections) - np.eye(len(boost_detections))                # 计算所有需要增强的检测结果之间的IoU，并除去对角线元素（对角线上的IoU总为1）                bdiou_max = bdiou.max(axis=1)                remaining_boxes = boost_detections_args[bdiou_max &lt;= iou_limit]                args = np.argwhere(bdiou_max &gt; iou_limit).reshape((-1,))                # 保存所有IoU值大于阈值的边框的索引                for i in range(len(args)):                    boxi = args[i]                    tmp = np.argwhere(bdiou[boxi] &gt; iou_limit).reshape((-1,))                    args_tmp = np.append(np.intersect1d(boost_detections_args[args], boost_detections_args[tmp]), boost_detections_args[boxi])                    # 遍历args中的每个边界框索引。对于每一个索引，找到与该边界框IoU大于iou_limit的其他边界框的索引，并将这些索引与当前边界框的索引合并。                    conf_max = np.max(detections[args_tmp, 4])                    if detections[boost_detections_args[boxi], 4] == conf_max:                        remaining_boxes = np.array(remaining_boxes.tolist() + [boost_detections_args[boxi]])                    # 计算上述边界框集合中最大的置信度值，并检查当前边界框的置信度是否等于这个最大值。如果是，则将该边界框添加到remaining_boxes列表中。                mask = np.zeros_like(detections[:, 4], dtype=np.bool_)                mask[remaining_boxes] = True            detections[:, 4] = np.where(mask, self.det_thresh + 1e-4, detections[:, 4])        return detections
Experiment

]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>boot引导程序的实现</title>
    <url>/2025/06/06/boot%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[boot引导程序的实现上一篇博客有提到过采用二级加载模式，因为boot的容量限制，所以boot引导程序只负责loader的加载，由loader来实现具体的初始化工作和内核的加载。
采用平坦模式，首先将所有的段寄存器指向0，直接用偏移地址进行寻址，根据x86实模式的存储映射情况，将0x7c00之前的空间用作栈空间。
_start:    mov $0, %ax	mov %ax, %ds	mov %ax, %ss	mov %ax, %es	mov %ax, %fs	mov %ax, %gs	// 使用0x7c00之前的空间作栈，大约有30KB的RAM，足够boot 和loader使用	mov $_start, %esp
BIOS通过软中断，自动从中断向量表中取相应的地址进行执行，通过寄存器来传递参数，这样可以避免和硬件直接交互。这里用INT 10, AH=0xE也就是显示字符功能来测试引导程序是否正常运行，正常运行后显示的是字符 ‘L’。
int $0x10这个中断函数作用是显示字符，同时光标前移，其中AL = 想要显示的字符、BL = 前景色，BH＝页码，这里考虑字符即可。
// 显示字符&#x27;W&#x27;来进行测试mov $0xe, %ahmov $&#x27;L&#x27;, %alint $0x10
qemu显示如下：

接下来用BIOS提供的软中断服务从磁盘中读取loader，没有考虑磁盘、磁头等。之前boot程序和栈的指针esp是被加载到了0x7c00位置处，本来0x7c00之后的位置是boot的程序，虽然boot程序占用的内存小，但是为了简单起见，还是直接将loader程序放到0x8000位置处，目前只在boot程序中写一段代码，从磁盘的第一个扇区读取指定位置的几个扇区，然后加载到内存中。

read_loader:    mov $0x8000, %bx      //ES:BX = 0x0000:0x8000 = 物理地址0x8000    mov $0x2, %ah         //功能号：读扇区    mov $0x2, %cx         //柱面号=0，扇区号=2（注意：扇区从1开始编号）    mov $64, %al          //读取扇区数量    mov $0x0080, %dx      //驱动器号=0x80（硬盘），磁头号=0    int $0x13             //调用BIOS磁盘服务        jc read_error         //如果进位标志置位，表示读取失败    jmp read_success      //读取成功，继续执行read_error:    mov $0xe, %ah         //显示字符功能    mov $&#x27;E&#x27;, %al         //显示字符&#x27;E&#x27;表示错误    int $0x10             //调用BIOS显示服务    jmp read_loader       //重试读取read_success:    mov $0xe, %ah         //显示字符功能    mov $&#x27;R&#x27;, %al         //显示字符&#x27;R&#x27;表示读取成功    int $0x10             //调用BIOS显示服务    jmp boot_entry        //跳转到内核入口点
用-exec x /20xb 0x8000查看20字节的数据，磁盘文件初始的内容在0x8000处为全0，为了便于观察是否正确读取，可以提前将disk1.vhd中一些值进行修改

后面将先实现loader程序，写入刚才分配的磁盘的位置，然后在boot中跳到0x8000的位置进行运行，那么就实现了boot到loader的跳转。现在先实现进入C环境：直接用jmp就可以进入，其中boot_entry是在另一个.c程序中定义的
#define	LOADER_START_ADDR	0x8000		// loader加载的地址void boot_entry(void) &#123;	((void (*)(void))LOADER_START_ADDR)();&#125; //只完成一项功能，即从磁盘找到loader文件然后加载到内容中，并跳转过去
]]></content>
      <categories>
        <category>x86操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>x86操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】如何在终端进行debug调试</title>
    <url>/2024/05/17/debug/</url>
    <content><![CDATA[
参考这个方法

进入Debug模式python -m pdb xxx.py
命令列表l —&gt; list 显示当前代码
n —&gt; next 向下执行一行代码
c —&gt; continue 继续执行代码
b —&gt; break 添加断点 
clear —&gt; 清除断点 
s —&gt; step 进入一个函数
p —&gt; print 打印一个变量的值 
a —&gt; args 打印所有的形参语句
q —&gt; quit 退出调试
r —&gt; return 快速执行到函数的最后一行
实例def func(a, b):    rest = a + b    return resta = 10b = 20rest = func(a, b)print(&quot;rest=&quot;,rest)
实例效果

以后终端调试可能会用上
]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用Mathjax时常用的字体设置</title>
    <url>/2024/05/22/latex%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[主要介绍 LATEX，MathJax 语法的字体美化，包括字体种类，字体大小，字体特效，字体颜色等。

字体种类设置\字体种类{文本}




字体种类
表示方法
预览




默认字体
ABCDEFGHIJKLMNOPQRSTUVWXYZ
ABCDEFGHIJKLMNOPQRSTUVWXYZ



abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz


数学斜体
\${ABCDEFGHIJKLMNOPQRSTUVWXYZ}\$
${ABCDEFGHIJKLMNOPQRSTUVWXYZ}$



\${abcdefghijklmnopqrstuvwxyz}\$
$ {abcdefghijklmnopqrstuvwxyz}$


意大利体
\it{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
$ \it{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$



\it{abcdefghijklmnopqrstuvwxyz}
$ \it{abcdefghijklmnopqrstuvwxyz}$


罗马体
\rm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
$\rm{ABCDEFGHIJKLMNOPQRSTUVWXYZ }$



\rm{abcdefghijklmnopqrstuvwxyz }
$\rm{abcdefghijklmnopqrstuvwxyz}$


花体
\cal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
$\cal{ABCDEFGHIJKLMNOPQRSTUVWXYZ }$



\cal{abcdefghijklmnopqrstuvwxyz}
$\cal{abcdefghijklmnopqrstuvwxyz}$


打字机体
\tt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
$\tt{ABCDEFGHIJKLMNOPQRSTUVWXYZ }$



\tt{abcdefghijklmnopqrstuvwxyz}
$\tt{abcdefghijklmnopqrstuvwxyz}$


粗体
\bf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
$\bf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$



\bf{abcdefghijklmnopqrstuvwxyz}
$\bf{abcdefghijklmnopqrstuvwxyz} $


黑板粗体
\Bbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
$\Bbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ }$



\Bbb{abcdefghijklmnopqrstuvwxyz}
$\Bbb{abcdefghijklmnopqrstuvwxyz}$


等线体
\sf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
$\sf{ABCDEFGHIJKLMNOPQRSTUVWXYZ } $



\sf{abcdefghijklmnopqrstuvwxyz}
$\sf{abcdefghijklmnopqrstuvwxyz} $


旧德式体
\frak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
$\frak{ABCDEFGHIJKLMNOPQRSTUVWXYZ }$



\frak{abcdefghijklmnopqrstuvwxyz}
$\frak{abcdefghijklmnopqrstuvwxyz} $


手写体
\scr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
$\frak{ABCDEFGHIJKLMNOPQRSTUVWXYZ }$



\scr{abcdefghijklmnopqrstuvwxyz}
$\scr{abcdefghijklmnopqrstuvwxyz} $




字体大小设置\字体大小{文本}




字体大小
字宽(pt)
表示方法
预览




小初
36pts
\Huge{小初字体(36pts)}
$\Huge{小初字体(36pts)}$


一号
27.5pts
\huge{一号字体(27.5pts)}
$\huge{一号字体(27.5pts)}$


二号
21pts
\LARGE{二号字体(21pts)}
$\LARGE{二号字体(21pts)}$


三号
15.75pts
\Large{三号字体(15.75pts)}
$\Large{三号字体(15.75pts)}$


四号
13.75pts
\large{四号字体(13.75pts)}
$\large{四号字体(13.75pts)}$


小四
12pts
\normalsize{小四字体(12pts)}
$\normalsize{小四字体(12pts)}$


默认
12pts
默认字体(12pts)
默认字体(12pts)


五号
10.5pts
\small{五号字体(10.5pts)}
$\small{五号字体(10.5pts)}$


六号
7.875pts
\scriptsize{六号字体(7.875pts)}
$\scriptsize{六号字体(7.875pts)}$


七号
5.25pts
\tiny{七号字体(5.25pts)}
$\tiny{七号字体(5.25pts)}$




字体特效设置\color{颜色}{文本}




颜色
表示方法
预览




黑色(black)
\color{black}{黑色(\text{black})}
$\color{black}{黑色(\text{black})}  $


红色(red)
\color{red}{红色(\text{red})}
$\color{red}{红色(\text{red})}       $


黄色(yellow)
\color{yellow}{黄色(\text{yellow})}
$\color{yellow}{黄色(\text{yellow})}$


蓝色(blue)
\color{blue}{蓝色(\text{blue})}
$\color{blue}{蓝色(\text{blue})}   $


灰色(grey)
\color{grey}{灰色(\text{grey})}
$\color{grey}{灰色(\text{grey})}   $


白色(white)
\color{white}{白色(\text{white})}
$\color{white}{白色(\text{white})}$


绿色(green)
\color{green}{绿色(\text{green})}
$\color{green}{绿色(\text{green})}    $


紫色(green)
\color{purple}{紫色(\text{purple})}
$\color{purple}{紫色(\text{purple})} $


紫红色(maroon)
\color{maroon}{紫红色(\text{maroon})}
$\color{maroon}{紫红色(\text{maroon})} $


橄榄绿(olive)
\color{olive}{橄榄绿(\text{olive})}
$\color{olive}{橄榄绿(\text{olive})}   $


蓝绿色(teal)
\color{teal}{蓝绿色(\text{teal})}
$\color{teal}{蓝绿色(\text{teal})}    $


银色(silver)
\color{silver}{银色(\text{silver})}
$\color{silver}{银色(\text{silver})} $


浅绿色(lime)
\color{lime}{浅绿色(\text{lime})}
$\color{lime}{浅绿色(\text{lime})}  $


藏青色(navy)
\color{navy}{藏青色(\text{navy})}
$\color{navy}{藏青色(\text{navy})} $





记录一下以后就不费劲找了
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>latex常用集合运算符</title>
    <url>/2024/06/05/latex%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[



latex
显示效果




\emptyset
∅


\in
∈


\notin
∉


\subset
⊂


\supset
⊃


\subseteq
⊆


\nsubseteq
⊈


\nsupseteq
⊉


\nsubseteqq
$\nsubseteqq$


\nsupseteqq
$\nsupseteqq$


\subsetneq
⊊


\supsetneq
⊋


\subsetneqq
⫋


\supsetneqq
⫌


\varsubsetneq
$\varsubsetneq$


\varsupsetneq
$\varsupsetneq $


\varsubsetneqq
$\varsubsetneqq $


\varsupsetneqq
$\varsupsetneqq$


\bigcap
⋂


\bigcup
⋃


\bigvee
⋁


\bigwedge
⋀


\biguplus
⨄


\bigsqcup
⨆


\Subset
⋐


\Supset
⋑


\subseteqq
⫅


\supseteqq
⫆


\sqsubset
⊏


\sqsupset
⊐




]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Fairmot代码复现问题记录（已解决）</title>
    <url>/2023/11/29/fairmot/</url>
    <content><![CDATA[最近在学习多目标跟踪的经典文章，顺便记录一下自己复现Fairmot代码时的问题以及解决方案。贴一下原作的代码
前期准备创建环境以及依赖项的安装：conda create -n FairMOTconda activate FairMOTconda install pytorch==1.7.0 torchvision==0.8.0 cudatoolkit=10.2 -c pytorchcd $&#123;FAIRMOT_ROOT&#125;pip install cythonpip install -r requirements.txt
这里一定要注意自己的cuda版本和pytorch版本的对应我的cuda版本是10.2，安装的pytorch版本是1.7.0
DNCv2的安装刚开始的时候我是直接按照原作者给的链接进行安装：git clone -b pytorch_1.7 https://github.com/ifzhang/DCNv2.gitcd DCNv2./make.sh但是在编译时会出现gcc版本不能大于8的提示，在安装了低于版本8的gcc后又会提示找不到gcc：）以防有人需要还是贴一下如何安装低版本gcc的链接其实作者提供了pytorch1.7对应的DCNv2的链接下载好按照步骤完成编译并没有提示gcc版本的问题
demo运行然后就是下载对应的预训练权重文件根据作者给的指示跑一跑demo：cd srcpython demo.py mot --load_model ../models/fairmot_dla34.pth --conf_thres 0.4然而我下载了这么多的权重文件，其实能用的只有一个
可能是代码更新了，不管使用哪个文件都会报错，而且不少文件的链接已经失效了Fix size testing.training chunk_sizes: [3, 3]The output will be saved to  /home/vip/anaconda3/envs/NXH/FairMOT-master/src/lib/../../exp/mot/defaultheads &#123;&#x27;hm&#x27;: 1, &#x27;wh&#x27;: 4, &#x27;id&#x27;: 128, &#x27;reg&#x27;: 2&#125;2023-11-23 11:12:12 [INFO]: Starting tracking...Lenth of the video: 1500 framesCreating model...=&gt; loading pretrained model ../models/hrnetv2_w18_imagenet_pretrained.pthloaded ../models/all_hrnet_v2_w18.pth, epoch 60Drop parameter last_layer.0.weight.If you see this, your model does not fully load the pre-trained weight. Please make sure you have correctly specified --arch xxx or set the correct --num_classes for your own dataset.Drop parameter last_layer.0.bias.If you see this, your model does not fully load the pre-trained weight. Please make sure you have correctly specified --arch xxx or set the correct --num_classes for your own dataset.上网查了一下，也有人遇到了这个问题，原作者回复了一个新的权重文件我下载试了一下，没问题，可以跑了，效果非常不错python demo.py mot --load_model ../models/fairmot_hrnet_w18.pth --arch hrnet_18 --reid_dim 128 --conf_thres 0.4ok下一步的学习计划就是试一试训练。

Fairmot学习
]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>latex常用微积分运算符</title>
    <url>/2024/06/05/latex%E5%B8%B8%E7%94%A8%E5%BE%AE%E7%A7%AF%E5%88%86%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[



latex
显示效果




\partial
∂


\nabla
∇


\infty
∞


\int
∫


\iint
∬


\iiint
∭


\iiiint
∬∬


\oint
∮


\triangle
△




]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Hexo部署博客时图片无法加载的问题</title>
    <url>/2024/02/28/hexo%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[解决图片在Markdown编辑器中正常显示，但是部署后网页无法加载的问题 

首先确认根目录_config.yml文件将文件中post_asset_folder这一行设置为true
post_asset_folder: true
然后打开git bash输入这行命令：
npm install https://github.com/CodeFalling/hexo-asset-image --save
最后一步，修改插件代码打开博客根目录中node_modules —&gt; hexo-asset-image —&gt; index.js修改第58行代码$(this).attr(&#x27;src&#x27;, config.root + link + src);将它改为：$(this).attr(&#x27;src&#x27;, src);确定自己本地图片的位置正确然后就完美解决了图片加载问题
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>文献《MotionTrack:Learning Robust Short-term and Long-term Motions for Multi-Object Tracking》总结</title>
    <url>/2024/02/29/motiontrack-reading/</url>
    <content><![CDATA[
贴一下原文链接
以及代码链接

1.Abstract作者认为多目标跟踪的主要挑战在于为每一个目标保持一条连续的轨迹。现有的方法往往通过运动特征与外观信息进行进行匹配，但是这两种特征容易受到密集人群和极端遮挡的影响。因此作者提出一个跟踪器名为Motion Track，在统一的框架中学习鲁棒的长期和短期轨迹。构建了新的交互模块与重寻模块，并在MOT指标中达到了SOTA。
2.Introduction现有的MOT方法主要遵循两种范式：TbD与TbR。TbD（Tracking by Detection）：首先在每个视频帧中检测目标，然后在相邻帧之间进行关联检测。TbR（Tracking by Regression）：目标检测器不仅提供逐帧检测，而且将数据关联替换为每个轨迹点对新位置的连续回归。但是这两种方法都要面对短期轨迹与长期轨迹的关联问题。即如何在短时间内将活跃的轨迹与检测进行关联，以及如何将长时间后即将丢失的轨迹片段与检测进行重新识别。
对于短期关联： 通常会学习具有判别性的运动特征和外观特征进行相邻帧之间的数据关联。但是密集人群中很难学习到具有判别性的特征。一是因为bbox太小，无法通过外观区分；二是人群会改变运动轨迹以避免碰撞，使得运动特征十分复杂。对于长期关联： 通常会学习具有判别性的外观特征对丢失的目标进行重新识别，但是低光照、低分辨率、不同姿态会对这一特征产生巨大的影响。为了缓解这一问题，使用了内存技术存储每个目标的不同特征，以多查询的方式匹配不同的目标。但是存储模块和多查询机制占用大量内存和时间，不利于实时跟踪。因此作者提出了Motion Track，对于短期关联，学习目标之间的交互作用，用于预测密集人群下的复杂运动，对于长期关联，通过相关计算和误差补偿两个步骤，对丢失的轨迹和未匹配的检测进行相关性计算，之后进一步采取误差补偿对遮挡轨迹进行修正。
3.Method
3.1.1 短期关联给定的视频帧t，首先获得检测结果Dt，截止至t-1帧共有M个轨迹T的集合，其中有S个丢失的轨迹Tlost。计算迭代偏移Ot $\in$ RM $\times$ 4，其中每一行包含t-2帧到t-1帧的中心坐标与宽高的偏移量。将绝对坐标与偏移量串联得到It $\in$ RM $\times$ 8作为交互模块的输入。
3.1.2 交互模块
利用自注意力机制得到注意矩阵Aatte，用于测量每对轨迹之间的交互幅度：其中$\phi$（·，·）表示线性变换，Et是由It映射出的高维嵌入。Qt $\in$ RM $\times$ D和Kt $\in$ RM $\times$ D是自我关注机制的查询和密钥。WE，WQ，WK是线性变换的权重。$\sqrt{d}$和$\sqrt{D}$ 是缩放因子。注意力矩阵Aatte中的 (i,j) -th 用于表示轨迹i对轨迹j的影响。为了更好的表示群体行为，作者通过非对称卷积模拟一群轨迹对单个轨迹的影响：最后只保留Aadjc中大于 $\xi$ 的元素：
其中 sgn 是符号函数，$\delta$表示PReLU，⊙表示哈达玛积，即逐元素乘积。最后将Aadjc所有非零元素进行归一化。提取轨迹之间的交互作用后，使用图卷积对每个轨迹的交互进行融合，然后使用多层感知器（MLP）进行预测：其中WG是线性变换的权重。预测值Poffs $\in$ RS $\times$ U将与Dt一起用于IoU的关联。
3.2.1 长期关联假设短期关联后有S个丢失的轨迹和U个未匹配的检测。作者根据轨迹的空间分布和速度-时间关系，计算S个丢失的轨迹和U个未匹配的检测之间的相关性，得到相关性矩阵Icorre $\in$ R[0，1]S $\times$ U。然后保留高度相关的轨迹-检测对，并利用误差补偿来完善轨迹。
3.2.2 重寻模块将预测的轨迹的位置与检测进行IoU匹配，如果匹配结束还有S个丢失的轨迹和U个未匹配的检测则进入重寻模块。剩余的检测集合记为Drest $\in$ RU $\times$ 5，其中五个元素分别是（t，x，y，w，h），保留30帧的历史轨迹的信息，于是仍未匹配的轨迹记为Tlost $\in$ RS $\times$ 30 $\times$ 5。首先在最后一个维度上对Drest和Tlost进行规范化，然后分别从中提取特征。作者分别在第二和第三维对Tlost进行非对称卷积，然后将它们汇集成特征向量Ftraj $\in$ RS $\times$ D：对于计算的结果，计算与最后存活的位置的差值，并与检测结果联合起来，得到 $\hat{D}$ rest $\in$ RU $\times$ 10，然后将其映射到高维特征Fdete $\in$ RU $\times$ D：其中WD是线性变换的权重。随后将Ftraj和Fdete结合在一起形成F $\in$ R（S  $\times$ U） $\times$ 2D，应用一个全连接层和sigmoid函数，就可以得到轨迹和检测之间的相似度得分Ccorr $\in$ RS $\times$ U，最后，作者使用贪心算法挑选出相关度高的匹配对，并将剩余的不匹配检测初始化为新的轨迹。
在用匹配检测重新识别丢失的轨迹后，作者使用误差补偿修正了预测的轨迹：
4.Training对交互模块，根据偏移量的预测计算出绝对坐标，使用IoU损失的形式：取了连续三帧作为一个sample，前两帧是网络的输入，最后一帧作为监督Pgt。对于重寻模块，在一段完整视频中提取所有的帧，将他们随机配对作为训练集，对于每个训练集，我们对轨迹和检测进行采样，并根据它们是否来自相同的轨迹标记为正或负。然后，我们用一个二元交叉熵损失函数来监督Refind模块中的相关计算:最终效果：

]]></content>
      <categories>
        <category>R&amp;D</category>
      </categories>
      <tags>
        <tag>MOT</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>loader与kernel功能的实现</title>
    <url>/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[显示字符串和内存检测显示字符串显示字符串其实就是反复调用BIOS显示字符风方式来显示一个完整的字符串，用于loader加载程序在初始化过程中显示进度、错误信息等。
具体代码采用内联汇编的形式，在C代码中嵌入汇编语句，使用__asm__关键字，加上__volatile__关键字避免编译器优化内联汇编语句（和C++非常像）
static void show_message(const char* message) &#123;    char c;    while((c=*message++)!=&#x27;\0&#x27;) &#123;  //在没有遇到结束符&#x27;\0&#x27;前循环显示指定字符        //在c中使用汇编指令需要采取内联汇编的形式        __asm__ __volatile__( //使用volatile关键字避免编译器对汇编语句的优化            &quot;mov $0xe, %%ah\n\t&quot;            &quot;mov %[ch], %%al\n\t&quot;            &quot;int $0x10&quot;::[ch]&quot;r&quot;(c)        );    &#125;&#125;
内存容量检测使用的方法为INT 0x15, EAX = 0xE820
具体原理不是关注重点，因此直接忽略，
static void detect_memory(void) &#123;  //检测内存容量，应该有128M    uint32_t contID=0;    uint32_t signature, bytes;    SMAP_entry_t smap_entry;    show_message(&quot;try to detect memory:&quot;);    boot_info.ram_region_count=0;    for(int i=0;i&lt;BOOT_RAM_REGION_MAX;i++) &#123;        SMAP_entry_t* entry=&amp;smap_entry;        __asm__ __volatile__(&quot;int  $0x15&quot; 				: &quot;=a&quot;(signature), &quot;=c&quot;(bytes), &quot;=b&quot;(contID)				: &quot;a&quot;(0xE820), &quot;b&quot;(contID), &quot;c&quot;(24), &quot;d&quot;(0x534D4150), &quot;D&quot;(entry));        if(signature != 0x534D4150) &#123;            show_message(&quot;failed\r\n&quot;);            return;        &#125;		if (bytes &gt; 20 &amp;&amp; (entry-&gt;ACPI &amp; 0x0001) == 0) &#123;			// ignore this entry            continue;		&#125;        if(entry-&gt;Type == 1) &#123; //ram中有一部分内存被硬件或其他设备占用，因此需要判断类型，type为1可以被操作系统使用             boot_info.ram_region_cfg[boot_info.ram_region_count].start=entry-&gt;BaseL; //操作系统为32位操作系统，只需要读取低32位            boot_info.ram_region_cfg[boot_info.ram_region_count].size=entry-&gt;LengthL; //同样只读低32位            boot_info.ram_region_count++;        &#125;        if(contID == 0) &#123;  //如果contID为0，说明整个读取已经结束            break;        &#125;    &#125;    show_message(&quot;detect finish!\r\n&quot;);&#125;
切换保护模式实模式
x86在上电启动后自动进入实模式，即16位工作模式，这种模式是最早期的8086芯片所使用的工作模式。早期的芯片设计得较简单、工作模式也较简单，所以有诸多限制：

最大只能访问1MB的内存：采用段值：偏移的方式访问，内核寄存器最大为16位宽。如段寄存器CS, DS, ES, FS, GS,  SS均为16位宽，AX, BX, CX DX, SI, DI, SP等也均为16位宽
所有的操作数最大为16位宽，出栈入栈也以16位为单位
没有任何保护机制，意味着应用程序可以读写内存中的任意位置
没有特权级支持，意味着应用程序可以随意执行任何指令，例如停机指令、关中断指令
没有分页机制和虚拟内存的支持

保护模式在后续的芯片设计中，intel为处理器增加了一些新的功能，可以实现某些保护功能，即保护模式。具体的特点如下：

寄存器位宽扩展至==32位==，例如AX扩展至32位的EAX，最大可访问4GB内存
所有操作数最大为32位宽，出入栈也为32位
提供4种特权级。==操作系统可以运行在最高特权级，可执行任意指令；应用程序可运行于最低特权级，避免其执行某些特权指令，例如停机指令、关中断指令==
==支持虚拟内存，可以开启分页机制==，以隔离不同的应用程序

切换至保护模式要切换至保护模式，需要遵循以下流程。

禁用中断，防止中途发生中断导致程序运行发生异常
打开A20 地址线（为了保证后续的cpu可以兼容以前的程序运行：在早期的 IBM PC 中，地址线 A20 被硬连线到逻辑 0，导致 CPU 无法访问超过 1MB 的内存（2^20 = 1MB）。这是为了与旧版软件兼容。当切换到保护模式时，我们需要启用 A20 地址线，以便访问完整的 4GB 地址空间。）
加载GDT表（GDT 是保护模式下的核心数据结构，定义了内存段的访问权限和基址。）
设置CR0，开启保护模式使能位（也就是PE位）
远跳转，清空流水线（当我们将 CR0 寄存器的 PE 位置 1 后，CPU 立即进入保护模式，但此时的指令流水线中仍然是按照实模式解释的指令。如果不清除这些指令，会导致严重的错误。）

函数如下：
static void enter_protect_mode(void) &#123;  //进入保护模式    cli();  //关中断    //启用A20地址线    uint8_t v=inb(0x92);    outb(0x92, v | 0x2);  //将读取的值与 0x2 进行按位或操作，设置第 2 位    lgdt((uint32_t)gdt_table, sizeof(gdt_table));  //加载GDT表    uint32_t cr0 = read_cr0(); //将CR0寄存器的PE位置为1，开启保护模式使能位    write_cr0(cr0 | (1&lt;&lt;0));  //1&lt;&lt;0：生成值 0x00000001，与CR0或，将第0位设置为1    //清空流水线    far_jump(8, (uint32_t)protect_mode_entry);&#125;
使用lgdt进行GDT表加载时，需要注意qemu上的gdt表是否成功写入，以及gdt_table的地址与qemu上的registers地址是否一致


磁盘读取loader还需要从硬盘中读取数据（如解析文件系统，加载操作系统内核等）加载到内存中执行
在实模式是，是采用软中断的方式读取磁盘，进入保护模式之后就需要重新设置磁盘读取的方式。这里采用的是LBA48模式
LBA48模式将硬盘上所有的扇区看成线性排列，没有磁盘、柱面等概念，因此访问起来更加简单，扇区序号从0开始。其访问序列如下：
static void read_disk(uint32_t sector, int sector_count, uint8_t * buf) &#123;    //设置设备选择寄存器0x1F6    outb(0x1F6, 0xE0); //选择硬盘：主盘或从盘    //0x1F6寄存器每位设置，1110 0000     // - 位7: 1（固定为1，表示启用LBA模式）    // - 位6: 1（LBA模式标志位）    // - 位5: 1（固定为1，可能用于兼容性）    // - 位4: 0（选择主盘Master，若为1则选择从盘Slave）    // - 位3-0: 0（LBA地址的高4位，此处为0）    //发送扇区数量的高八位    outb(0x1F2, (uint8_t)(sector_count &gt;&gt; 8));    //发送LBA地址的高4字节（分四次发送，每次一字节）    outb(0x1F3, (uint8_t)(sector &gt;&gt; 24));    outb(0x1F4, 0);    outb(0x1F5, 0);    // 发送扇区数量的低8位和完整LBA地址（覆盖之前的部分设置）    outb(0x1F2, (uint8_t)sector_count);    outb(0x1F3, (uint8_t)sector);    outb(0x1F4, (uint8_t)(sector &gt;&gt; 8));    outb(0x1F5, (uint8_t)(sector &gt;&gt; 16));    // 发送读取命令（0x24 = READ SECTORS EXT，扩展读取命令）    outb(0x1F7, 0x24);    uint16_t * data_buf = (uint16_t *)buf;    while(sector_count--) &#123;        // 等待硬盘就绪（轮询状态寄存器0x1F7）        // 状态寄存器的位7=1表示硬盘忙，位3=1表示数据就绪        // 当状态为0x08（即0000 1000）时，表示数据就绪且不忙        while((inb(0x1F7) &amp; 0x88) != 0x8) &#123;&#125;         // 读取当前扇区数据（每扇区通常为512字节 = 256个16位字）        for(int i=0 ; i&lt;SECTOR_SIZE / 2 ; i++) &#123;            *data_buf++=inw(0x1F0);        &#125;    &#125;&#125;
这里的outb、intb、inw都是由内联汇编定义的函数，分别是按照8位写数据、读数据，还有按照16位读数据，具体就不赘述了。
完成这些步骤后磁盘的空间使用情况如下：
（实际上，上述位置的确定并不唯一，可自行选择合适的地址，只要保证loader能够正确加载即可。可以看到，在第100扇区之前预留了比较大的空间，目的是以后loader代码量增大时，有足够的空间存放，不必再临时调整kernel的位置。）

完成以上步骤后，loader加载程序就大体实现了，后面就需要将从loader中获取的启动信息（如内存容量）传递给内核。
内核工程的创建创建kernel文件夹与init子文件夹，创建好相应的头文件等，然后从loader跳转到kernel工程中来，将kernel代码放在第100扇区的位置，然后在loader中跳转到0x100000的位置。
void load_kernel(void) &#123;    // 从第100个扇区开始，大小是500KB，放到1Mb以上的内存位置，因为是保护模式，可以使用1MB以上的内存空间    read_disk(100, 500, (uint8_t *)SYS_KERNEL_LOAD_ADDR);     // kernel的跳转代码    ((void (*)(void))SYS_KERNEL_LOAD_ADDR)();    for (;;) &#123;&#125;&#125;
向内核传递启动信息定义一个kernel_init函数，并且传入启动信息，这里涉及到了一些调用函数的函数栈的变化。
举一个例子：
void kernel_init(boot_info_t * boot_info) &#123;    int a = 1, b = 2;    test(a, b);    for(;;) &#123;&#125;&#125;int test (int a, int b) &#123;    return a + b;&#125;
在32位系统下，调用上述函数时，就会是这样的过程：
void kernel_init(boot_info_t *boot_info) &#123;    // 1. 函数开头：建立栈帧    push %ebp        // 保存调用者（父函数）的 ebp    mov %esp, %ebp   // 让 kernel_init 的 ebp 指向当前栈顶（刚压入的旧 ebp 位置）。    sub $0x10, %esp  // 分配 16 字节空间给 kernel_init 的局部变量（a、b 等）。            /*栈帧状态：        栈底（高地址） →  旧ebp（父函数的ebp）                          返回地址（父函数调用kernel_init的返回地址，图里未画全）                          局部变量空间（16字节，未初始化）  		栈顶（低地址） ←  kernel_init的esp（sub $0x10后，esp指向这里）      */            // 2. 定义局部变量    int a = 1, b = 2;     // 对应汇编：    // movl $0x1, -0x4(%ebp)  → a = 1（存在 ebp-4）    // movl $0x2, -0x8(%ebp)  → b = 2（存在 ebp-8）    /*栈帧状态：        栈底 →  旧ebp（父函数）                  返回地址（父函数）                  局部变量a=1（ebp-4）                  局部变量b=2（ebp-8）                  剩余局部变量空间（8字节，图里简化了）          栈顶 ←  kernel_init的esp      */        // 3. 调用 test(a, b)    test(a, b);     // 对应汇编：    // push -0x8(%ebp)  → 压入 b（从右往左传参）    // push -0x4(%ebp)  → 压入 a    // call 1000c &lt;test&gt; → 压入返回地址    /*栈帧状态：    	栈底 →  旧ebp（父函数）                  返回地址（父函数）                  局部变量a=1                  局部变量b=2                  参数b=2（刚压入的）                  参数a=1（刚压入的）                  返回地址（kernel_init → test的返回地址）  		栈顶 ←  kernel_init的esp（call后，esp指向这里）      */        // 4. 死循环（省略细节）    for (;;) &#123;&#125;&#125;int test(int a, int b) &#123;    // 1. 函数开头：建立栈帧    push %ebp        // 保存旧ebp（kernel_init的ebp）    mov %esp, %ebp   // 新ebp = 旧esp        // 2. 计算返回值 a + b    return a + b;     // 对应汇编：    // mov 0x8(%ebp), %edx  → a = ebp+8    // mov 0xc(%ebp), %eax  → b = ebp+c    // add %edx, %eax       → 返回值 = a + b        // 3. 函数结尾：销毁栈帧    pop %ebp         // 恢复旧ebp（kernel_init的ebp）    ret              // 弹出返回地址，回到kernel_init            /*test栈帧状态：    	栈底 →  旧ebp（父函数）                  返回地址（父函数）                  局部变量a=1                  局部变量b=2                  参数b=2                  参数a=1                  返回地址（kernel_init → test）                  旧ebp（kernel_init的ebp）  → test的ebp指向这里！  		栈顶 ←  test的esp（push %ebp后，esp指向这里）      */&#125;
实操将以上栈帧变化反映到项目中就是将loader中读取到的相关配置信息（比如存储内存容量信息的结构体boot_info）传递给内核，采取的就是调用函数的方式
_start:    # 第一种方法    # push %ebp    # mov %esp, %ebp    # mov 0x8(%ebp), %eax    # push %eax    # 第二种方法    # mov 4(%esp), %eax    # push %eax    # 第三种方法    push 4(%esp)    # kernel_init(boot_info)    call kernel_init            /*    	流程相当于：    	从start的栈中取出参数boot_info并放入eax寄存器中 --&gt; eax寄存器入栈 --&gt; 执行call指令（调用函数）    */
代码/数据段与链接脚本GCC工具链默认以.text, .rodata, .data, .bss存储代码和数据。具体来说是：
.text: 存储编译后可执行代码（机器指令），如函数体、条件判断、循环逻辑等
.rodata: 存储程序中声明的只读数据 
.data: 存储程序中已初始化的全局变量和静态变量
.bss: 存储程序中未初始化的全局变量和静态变量（初始化为0）
也可以自定义链接脚本（lds文件），此时的Cmakelist.txt的配置需要修改成自定义的链接脚本：
SECTIONS&#123;    . = 0x100000; // 起始地址，这里可以修改为别的地址	.text : &#123;		*(.text) // 将所有的目标文件的.text文件都放到一个.text文件中，下同	&#125; 	.rodata : &#123;		*(.rodata)	&#125;	.data : &#123;		*(.data)	&#125;	.bss : &#123;		*(.bss)	&#125;&#125;
加载内核映像文件linux的可执行文件通常为.elf结尾的文件格式，该文件中包含了上面提到的.text, .rodata, .data, .bss隔断的信息，通常解析该文件，找到program header table，并从该表中读取出相应的代码、数据段等相关信息，并将代码和数据加载到对应的内存中，完成整个加载过程。
文件具体的格式就不需要很细致的了解了，具体的加载过程如下：

初步检查elf header的合法性（检查开头的格式）
通过elf header-&gt;e_phoff定位到programe header table，遍历elf header-&gt;e_phnum次，加载各个段
从文件位置p_offset处读取filesz大小的数据，写入到内存中paddr的位置处
如果p_filesz &lt; p_memsz，则将部分内存清零（bss区初始化）


取elf header-&gt;e_entry，跳转到该地址运行。

static uint32_t reload_elf_file (uint8_t * file_buffer) &#123;    Elf32_Ehdr * elf_hdr = (Elf32_Ehdr *)file_buffer;    /*检查传入的文件是否是elf文件*/    if ((elf_hdr-&gt;e_ident[0] != 0x7F) || (elf_hdr-&gt;e_ident[1] != &#x27;E&#x27;) ||        (elf_hdr-&gt;e_ident[2] != &#x27;L&#x27;) ||(elf_hdr-&gt;e_ident[3] != &#x27;F&#x27;) ) &#123;            return 0;    &#125;    // 从文件中加载程序头，将内容拷贝到相应的位置，提取相应的数据    for(int i = 0;i &lt; elf_hdr-&gt;e_phnum; i++) &#123;        Elf32_Phdr * phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;        if (phdr-&gt;p_type != PT_LOAD) &#123;            continue;        &#125;                uint8_t * src = file_buffer + phdr-&gt;p_offset;  //起始地址        uint8_t * dst = file_buffer + phdr-&gt;p_paddr;  //目的地址        // 复制操作，传输text和rodata段是没问题的，但是在elf文件中data和bss段是存放在一起的，没办法通过这种方式读取        // 并且bss段存放未初始化的数据，也就是全零，只需要知道全零的区域有多大就够了        for(int j = 0; j&lt;phdr-&gt;p_filesz; j++) &#123;            *dst++ = *src++;        &#125;        /*获取结束地址*/        dst = (uint8_t *)phdr-&gt;p_paddr + phdr-&gt;p_filesz;                // memsz和filesz不相等时，后续要填0        for(int j = 0; j &lt; phdr-&gt;p_memsz - phdr-&gt;p_filesz; j++) &#123;            *dst++ = 0;        &#125;        return elf_hdr-&gt;e_entry;    &#125;&#125;/*最终从磁盘上加载内核的代码如下*/void load_kernel(void) &#123;    read_disk(100, 500, (uint8_t *)SYS_KERNEL_LOAD_ADDR);    /*用于解析在1Mb内存处存放的elf文件，提取代码和数据，放在64Kb（0x10000）开始的位置*/    reload_elf_file((uint8_t *)SYS_KERNEL_LOAD_ADDR);     /*跳转到kernel入口处的地址，与1Mb地址0x100000注意区分，那里是放置kernel.lef文件的地址*/    uint32_t kernel_entry = reload_elf_file((uint8_t *)SYS_KERNEL_LOAD_ADDR);    if(kernel_entry == 0) &#123;  //获取错误直接死机        die(-1);    &#125;    ((void (*)(boot_info_t *))kernel_entry)(&amp; boot_info);      for (;;) &#123;&#125;&#125;
]]></content>
      <categories>
        <category>x86操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>x86操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>互斥锁与相关函数</title>
    <url>/2025/02/25/%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[互斥锁与相关函数互斥锁（Mutex，Mutual Exclusion） 是一种用于多线程编程的同步机制，用于保护共享资源，防止多个线程同时访问导致数据竞争（Race Condition）。
初始化互斥锁#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
mutex：指向互斥锁的指针。
attr：互斥锁的属性，通常设置为 NULL（使用默认属性）。
返回值：成功返回 0，失败返回错误码。
销毁互斥锁销毁互斥锁，释放相关资源。
#include &lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex);
加锁对互斥锁加锁。如果锁已被其他线程持有，则当前线程会阻塞，直到锁被释放。
int pthread_mutex_lock(pthread_mutex_t *mutex);
mutex：指向互斥锁的指针。返回值：成功返回 0，失败返回错误码。
尝试加锁尝试对互斥锁加锁。如果锁已被其他线程持有，则立即返回错误，不会阻塞。
int pthread_mutex_trylock(pthread_mutex_t *mutex);
mutex：指向互斥锁的指针。返回值：成功返回 0，失败返回错误码。
解锁对互斥锁解锁。
int pthread_mutex_unlock(pthread_mutex_t *mutex);
mutex：指向互斥锁的指针。返回值：成功返回 0，失败返回错误码。
使用示例/*    互斥量的类型 pthread_mutex_t    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);        - 初始化互斥量        - 参数 ：            - mutex ： 需要初始化的互斥量变量            - attr ： 互斥量相关的属性，NULL        - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。            pthread_mutex_t *restrict mutex = xxx;            pthread_mutex_t * mutex1 = mutex;    int pthread_mutex_destroy(pthread_mutex_t *mutex);        - 释放互斥量的资源    int pthread_mutex_lock(pthread_mutex_t *mutex);        - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待    int pthread_mutex_trylock(pthread_mutex_t *mutex);        - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。    int pthread_mutex_unlock(pthread_mutex_t *mutex);        - 解锁*/#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;// 全局变量，所有的线程都共享这一份资源。int tickets = 1000;// 创建一个互斥量pthread_mutex_t mutex;void * sellticket(void * arg) &#123;    // 卖票    while(1) &#123;        // 加锁        pthread_mutex_lock(&amp;mutex);        if(tickets &gt; 0) &#123;            usleep(6000);            printf(&quot;%ld 正在卖第 %d 张门票\n&quot;, pthread_self(), tickets);            tickets--;        &#125;else &#123;            // 解锁            pthread_mutex_unlock(&amp;mutex);            break;        &#125;        // 解锁        pthread_mutex_unlock(&amp;mutex);    &#125;        return NULL;&#125;int main() &#123;    // 初始化互斥量    pthread_mutex_init(&amp;mutex, NULL);    // 创建3个子线程    pthread_t tid1, tid2, tid3;    pthread_create(&amp;tid1, NULL, sellticket, NULL);    pthread_create(&amp;tid2, NULL, sellticket, NULL);    pthread_create(&amp;tid3, NULL, sellticket, NULL);    // 回收子线程的资源,阻塞    pthread_join(tid1, NULL);    pthread_join(tid2, NULL);    pthread_join(tid3, NULL);    pthread_exit(NULL); // 退出主线程    // 释放互斥量资源    pthread_mutex_destroy(&amp;mutex);    return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>操作系统</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>代价函数，损失函数，目标函数详解</title>
    <url>/2024/06/17/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%EF%BC%8C%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[总结一下机器学习中的代价函数、损失函数、目标函数的概念以及一些典型的函数。
概念代价函数：代价函数是用来衡量模型预测输出与实际标签之间差异的一个数学表达式。在机器学习中，它的目的是最小化模型的预测误差，以找到最佳的模型参数。
损失函数：损失函数本质上与代价函数是同一个概念，也是用来度量模型预测错误的程度。可以用来表述单个样本的损失，也可以表征整个训练集的损失的平均。
目标函数：目标函数是优化问题中想要最小化或最大化的函数，它定义了模型学习的目标。尤其是在监督学习任务中，我们的目标就是最小化模型的损失，即损失函数或代价函数。不过，目标函数的定义可以更宽泛，它也可以包含正则化项（如L1、L2正则化），用以防止模型过拟合，此时的目标函数就不仅仅是简单的损失函数了。
典型函数均方差损失（Mean Squared Error Loss）均方差 Mean Squared Error (MSE) 损失是机器学习、深度学习回归任务中最常用的一种损失函数，也称为 L2 Loss。其基本形式如下：

J_{MSE}=\frac{1}{N} \sum^N_{i=1}(y_i-\hat{y}_i)^2从直觉上理解均方差损失，这个损失函数的最小值为 0（当预测等于真实值时），最大值为无穷大。下图是对于真实值  ，不同的预测值  的均方差损失的变化图。横轴是不同的预测值，纵轴是均方差损失，可以看到随着预测与真实值绝对误差  的增加，均方差损失呈二次方地增加。在模型输出与真实值的误差服从高斯分布的假设下，在这个假设能被满足的场景中（比如回归），均方差损失是一个很好的损失函数选择；当这个假设没能被满足的场景中（比如分类），均方差损失不是一个好的选择。
平均绝对误差损失（Mean Absolute Error Loss）平均绝对误差 Mean Absolute Error (MAE) 是另一类常用的损失函数，也称为 L1 Loss。其基本形式如下：

J_{MAE}=\frac{1}{N} \sum^N_{i=1}|y_i-\hat{y}_i|^2对这个损失函数进行可视化如下图，MAE 损失的最小值为 0（当预测等于真实值时），最大值为无穷大。可以看到随着预测与真实值绝对误差  的增加，MAE 损失呈线性增长：
MSE损失收敛快但容易受outlier影响，MAE对outlier更加健壮但是收敛慢。
交叉熵损失（Cross-Entropy Loss）交叉熵损失常用于分类问题，特别是多分类问题中。它衡量的是两个概率分布之间的差异，一个是由模型预测得到的概率分布，另一个是真实标签的概率分布（通常是独热编码）。交叉熵损失的公式如下：

L_{CE}=-\sum_{i=1}^Cy_ilog(p_i)其中， $𝑦_𝑖$ 表示第𝑖类的真是标签（0或1，如果是独热编码）， $𝑝_𝑖$ 是模型预测第𝑖类的概率。
这个公式表达了真实标签下的对数似然的负值，目标是最大化似然，即最小化损失。
二元交叉熵损失（Binary Cross-Entropy Loss）在二分类问题中，二元交叉熵损失被广泛应用，公式为：

L_{BCE}=-\sum_{i=1}^N[y_ilog(p_i)+(1-y_i)log(1-p_i)]下图是对二分类的交叉熵损失函数的可视化，蓝线是目标值为 0 时输出不同输出的损失，黄线是目标值为 1 时的损失。可以看到约接近目标值损失越小，随着误差变差，损失呈指数增长。
多元交叉熵损失（Multiclass Cross-Entropy Loss）多元交叉熵损失（Multiclass Cross-Entropy Loss）是用于多分类问题的一种损失函数，特别适用于神经网络和其他机器学习模型的训练过程。公式如下：

L_{MCE}(\hat{y},y)=-\sum y_{j}log(\hat{y}_j)其中$\hat{y}$为预测值，${y}$为监督值。
三元组损失（Triplet Loss）主要是用于训练差异性小的样本，比如人脸等。公式如下：

L_{T}=max(d_p-d_n+ \alpha, 0)其中，$d_p$ $d_n$ 分别是正对（同一身份的两个实例）和负对（不同身份的实例对）之间的距离，𝛼是一个超参数，即边际。
其中样本可以分为三类：
easy triplets： $L=0$，即 $d_p+ \alpha &lt;d_n$ 这种情况不需要优化，如下图:
hard triplets： $L&gt;𝛼$，即 $d_p &lt; d_n$ ，这种情况损失最大，需要优化，如下图:
semi-hard triplets： $L&lt;𝛼$，即 $d_p &lt; d_n &lt; d_p+ \alpha $ ，这种情况存在损失，但损失比hard triplets要小，也需要优化，如下图：
中心损失（Center Loss）中心损失的基本思想是为每个类别学习一个中心（或称为类别原型），然后在训练过程中，除了传统的分类损失（如交叉熵损失）外，还加入一个额外的惩罚项，以减小每个样本特征向量与对应类别中心之间的距离。这样做可以提升模型的识别能力，特别是在面对类别间相似度高或类别内差异大的情况时。
中心损失它仅仅用来减少类内（比如说同一表情）的差异，而不能有效增大类间（比如说不同表情）的差异性，公式如下：

L_{C}=\frac{1}{N}\sum_{i=1}^N ||f_i-C_{y_i}||^2其中$N$是样本总数，$f_i$ 表示特征提取网络输出的特征向量， $C_{y_i}$ 表示对应的类别中心， $||·||$ 表示欧氏距离。
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>套接字函数</title>
    <url>/2025/03/01/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[套接字函数socket()创建套接字描述符，指定协议族、套接字类型和协议类型。
#include&lt;sys/types.h&gt;#include&lt;sys/socker.h&gt;#include&lt;arpa/inet.h&gt;//包含这个头文件就不需要包含上面两个int socket(int domain, int type, int protocol);

参数：
domain：协议族，如AF_INET（IPv4）、AF_INET6（IPv6）、AF_UNIX（本地通信）。
type：套接字类型，如SOCK_STREAM（TCP流）、SOCK_DGRAM（UDP数据报）、SOCK_RAW（原始套接字）。
protocol：协议类型，通常设为0，由系统根据前两个参数自动选择。


返回值：成功返回套接字描述符（非负整数），失败返回-1，错误码存入errno。

bind()将套接字与本地IP地址和端口绑定（服务端常用）。
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

参数：
sockfd：由socket()创建的套接字描述符。
addr：指向sockaddr结构体的指针（需转换为特定地址结构体，如IPv4用sockaddr_in）。
addrlen：地址结构体的长度（如sizeof(struct sockaddr_in)）。


返回值：成功返回0，失败返回-1，错误码存入errno。

listen()将套接字设为监听状态。
int listen(int sockfd, int backlog);

参数：
sockfd：已绑定的套接字描述符。
backlog：等待连接队列的最大长度（通常不超过128）。


返回值：成功返回0，失败返回-1，错误码存入errno。

accept()服务端接受客户端连接请求，返回新套接字用于数据传输。
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

参数：

sockfd：监听套接字描述符。
addr：存储客户端地址的结构体指针（传出参数）。
addrlen：地址结构体长度的指针（传入时指定缓冲区大小，传出时返回实际大小）。


返回值：成功返回新套接字描述符，失败返回-1，错误码存入errno。


connect()客户端主动发起TCP连接请求。
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

参数：
sockfd：客户端套接字描述符。
addr：指向服务端地址结构体的指针（如sockaddr_in）。
addrlen：地址结构体长度。


返回值：成功返回0，失败返回-1，错误码存入errno。

send()在已连接的TCP套接字上发送数据。
ssize_t send(int sockfd, const void *buf, size_t len, int flags);

参数：
sockfd：连接成功的套接字描述符。
buf：数据缓冲区指针。
len：数据长度。
flags：控制标志（如MSG_WAITALL阻塞直到数据接收完整）。


返回值：成功返回实际发送的字节数，失败返回-1，错误码存入errno。

recv()在已连接的TCP套接字上接收数据。
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

参数：
sockfd：连接成功的套接字描述符。
buf：数据缓冲区指针。
len：数据长度。
flags：控制标志（如MSG_WAITALL阻塞直到数据接收完整）。


返回值：成功返回实际接收的字节数，失败返回-1，错误码存入errno。

sendto()用于无连接的UDP套接字发送数据。
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);

参数：
dest_addr：目标地址结构体指针。
addrlen：地址结构体长度。


返回值：成功返回实际发送的字节数，失败返回-1，错误码存入errno。

recvfrom()用于无连接的UDP套接字接收数据。
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);

参数：
src_addr：来源地址结构体指针（传出参数）。


返回值：成功返回实际接收的字节数，失败返回-1，错误码存入errno。

close()关闭套接字并释放资源。
int close(int sockfd);

参数：
sockfd：套接字描述符。


返回值：成功返回0，失败返回-1，错误码存入errno

shutdown()半关闭连接。
int shutdown(int sockfd, int how);

参数：
how：关闭方式，如SHUT_RD（关闭读）、SHUT_WR（关闭写）、SHUT_RDWR（关闭读写）。


返回值：成功返回0，失败返回-1，错误码存入errno。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>操作系统</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>孤儿进程和僵尸进程</title>
    <url>/2025/02/23/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[孤儿进程与僵尸进程在操作系统中，孤儿进程（Orphan Process） 和 僵尸进程（Zombie Process） 是两种特殊的进程状态，它们通常与进程的生命周期和父子进程关系有关。
孤儿进程（1）定义：孤儿进程是指 父进程已经终止，但子进程仍在运行 的进程。
（2）产生原因：父进程先于子进程终止。
操作系统会将孤儿进程的父进程设置为 init 进程（PID 为 1 的进程），由 init 进程负责回收孤儿进程的资源。
僵尸进程（1）定义：僵尸进程是指子进程已经终止，但其父进程尚未回收其资源的进程。
（2）产生原因：子进程终止后，父进程没有调用 wait 或 waitpid 回收子进程的资源。子进程的进程描述符仍然保存在系统中，占用进程表项。
特点孤儿进程：不会对系统造成危害，init进程会定期检查并回收孤儿进程的资源
僵尸进程：不占用CPU资源，但是会占用进程ID和进程表项，如果大量僵尸进程积累，会导致系统资源耗尽。
如何避免僵尸进程？为了避免僵尸进程，父进程需要及时回收子进程的资源。
使用wait()函数用于等待任意一个子进程终止，并回收其资源。
#include &lt;sys/wait.h&gt;pid_t wait(int* status);
status：指向一个整数的指针，用于存储子进程的退出状态。如果不需要状态信息，可以传入 NULL。
返回值：
成功：返回终止的子进程的 PID。
失败：返回 -1，并设置 errno。
使用waitpid()函数用于等待指定的子进程终止，并回收其资源。相比wait，waitpid提供了更多的控制选项。
#include &lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int* status, int options);
pid：
$&gt;$ 0：等待指定 PID 的子进程。
-1：等待任意子进程（类似于 wait）。
0：等待与调用进程同组的任意子进程。
$&lt;$ -1：等待组 ID 等于 |pid| 的任意子进程。
status：指向一个整数的指针，用于存储子进程的退出状态。
options：控制函数行为的选项，常用的有：
WNOHANG：如果没有子进程终止，立即返回，而不是阻塞。
WUNTRACED：如果子进程被暂停，也返回。
返回值：
成功：返回终止的子进程的 PID。
失败：返回 -1，并设置 errno。
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>信号相关函数</title>
    <url>/2025/02/23/%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[信号相关部分函数信号发送函数kill向指定进程发送信号。#include &lt;signal.h&gt;int kill(pid_t pid, int sig);pid：目标进程ID。pid &gt; 0 发送给指定进程；pid == 0 发送给同一进程组的所有进程；pid == -1 发送给有权限的所有进程；pid &lt; -1 发送给进程组ID为 -pid 的所有进程。
sig：要发送的信号。
返回值：成功返回0，失败返回-1并设置 errno。
raise向当前进程发送信号。
#include &lt;signal.h&gt;int raise(int sig);
sig：要发送的信号。
返回值：成功返回0，失败返回非0。
abort使当前进程异常终止。
#include &lt;stdlib.h&gt;void abort(void);
无返回值
定时器函数alarm设置一个定时器，在指定时间后发送 SIGALRM 信号。
#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);
seconds：定时器时间（秒）。
返回值：返回之前定时器的剩余时间。
self timer设置和管理定时器。
#include &lt;sys/time.h&gt;int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
which：定时器类型（ITIMER_REAL, ITIMER_VIRTUAL, ITIMER_PROF）。
new_value：新定时器值。
old_value：旧定时器值。
返回值：成功返回0，失败返回-1。
信号处理函数signal设置信号处理函数。#include &lt;signal.h&gt;void (*signal(int sig, void (*func)(int)))(int);
sig：信号编号。
func：信号处理函数。
返回值：返回之前的信号处理函数。
sigaction设置信号处理行为。
#include &lt;signal.h&gt;int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);
sig：信号编号。
act：新信号处理行为。
oldact：旧信号处理行为。
返回值：成功返回0，失败返回-1。
信号集操作函数操作信号集。
信号集（Signal Set）是一个用于表示一组信号的数据结构，通常用于在进程中对多个信号进行批量操作。
#include &lt;signal.h&gt;int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set, int signo);int sigdelset(sigset_t *set, int signo);int sigismember(const sigset_t *set, int signo);
set：信号集。
signo：信号编号。
返回值：sigemptyset, sigfillset, sigaddset, sigdelset 成功返回0，失败返回-1；sigismember 返回1（是成员）或0（不是成员）。
sigprocmask设置或修改进程的信号屏蔽字。
#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
how：操作类型（SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK）。
set：新信号集。
oldset：旧信号集。
返回值：成功返回0，失败返回-1。
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>守护进程</title>
    <url>/2025/02/24/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[守护进程是一种在后台运行的特殊进程，通常用于执行系统任务或服务，不需要和用户交互。它在操作系统系董事运行，并在整个系统运行期间持续工作。
守护进程特点①后台运行：守护进程在后台运行，不与任何终端关联，因此用户无法通过终端直接与其交互。②独立于用户会话：守护进程通常与用户登录回话无关，即使所有用户注销，守护进程仍然继续运行。③生命周期长：在系统启动时启动，在系统关闭时终止，生命周期与系统运行时间一致。④无控制终端：守护进程没有控制终端，因此不会接受来自终端的信号（如SIGHUP）。⑤通常以root权限运行：许多守护进程需要访问系统资源或执行特权操作，因此以root用户权限运行。
守护进程的用途守护进程通常用于提供系统服务或执行后台任务，如系统服务、日志记录、任务调度、消息队列等
守护进程的创建步骤创建子进程并退出父进程使用fork()创建子进程，然后退出父进程，使其变成一个孤儿进程，并被init进程接管。pid_t pid=fork();if(pid&gt;0)&#123;    exit(0); //退出父进程&#125;
创建新会话使用setid()闯进新会话，是子进程成为会话组长，并脱离控制终端。
setid();
改变工作目录将工作目录改为根目录，以避免占用可卸载文件系统。chdir(&#x27;/&#x27;);
重设文件权限掩码使用umask(0)重设文件权限掩码，以确保守护进程创建的文件具有预期的权限。
umask(0);
关闭文件描述符关闭从父进程集成的文件描述符，以释放资源。
for (int i=sysconf(_SC_OPEN_MAX);i&gt;=0;i++)&#123;    close(i);&#125;
重定向标准输入/输出/错误将标准输入、输出、错误重定向到/dev/null，以避免守护进程与终端交互。
freopen(&quot;/dev/null&quot;, &quot;r&quot;, stdin);freopen(&quot;/dev/null&quot;, &quot;w&quot;, stdout);freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>常用STL容器特性</title>
    <url>/2025/03/04/%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[常用STL容器特性



容器
操作
底层实现
特点
是否自动排序
能否使用迭代器
元素能否重复




Vector
构造: vector&lt;T&gt; v; 插入: v.push_back(val);, v.insert(pos, val); 删除: v.pop_back();, v.erase(pos); 访问头尾: v.front(), v.back() 其他: v.size(), v.empty(), v.clear()
动态数组
动态数组，支持快速随机访问，尾部插入/删除高效，中间插入/删除较慢。
否
是
是


String
构造: string s; 插入: s.push_back(c);, s.insert(pos, str); 删除: s.pop_back();, s.erase(pos, len); 访问头尾: s.front(), s.back() 其他: s.size(), s.empty(), s.clear(), s.substr(pos, len)
动态数组
专门用于存储字符序列，支持字符串操作（如子串、查找、替换等）。
否
是
是


Deque
构造: deque&lt;T&gt; dq; 插入: dq.push_back(val);, dq.push_front(val); 删除: dq.pop_back();, dq.pop_front(); 访问头尾: dq.front(), dq.back() 其他: dq.size(), dq.empty(), dq.clear()
分段连续空间（双端队列）
双端队列，支持头部和尾部高效插入/删除，随机访问性能略低于 vector。
否
是
是


Queue
构造: queue&lt;T&gt; q; 插入: q.push(val); 删除: q.pop(); 访问头尾: q.front(), q.back() 其他: q.size(), q.empty()
基于 deque 或 list
先进先出（FIFO）容器，只允许在尾部插入，头部删除。
否
否
是


Stack
构造: stack&lt;T&gt; st; 插入: st.push(val); 删除: st.pop(); 访问头尾: st.top() 其他: st.size(), st.empty()
基于 deque 或 vector
后进先出（LIFO）容器，只允许在顶部插入/删除。
否
否
是


List
构造: list&lt;T&gt; lst; 插入: lst.push_back(val);, lst.push_front(val); 删除: lst.pop_back();, lst.pop_front(); 访问头尾: lst.front(), lst.back() 其他: lst.size(), lst.empty(), lst.clear(), lst.remove(val)
双向链表
双向链表，支持高效插入/删除，不支持随机访问，内存占用较高。
否
是
是


Set
构造: set&lt;T&gt; s; 插入: s.insert(val); 删除: s.erase(val); 访问头尾: *s.begin(), *s.rbegin() 其他: s.size(), s.empty(), s.clear(), s.find(val)
红黑树
基于红黑树实现，元素唯一且自动排序，查找效率高。
是
是
否（multiset可以重复）


Map
构造: map&lt;K, V&gt; m; 插入: m.insert(&#123;key, val&#125;); 删除: m.erase(key); 访问头尾: m.begin()-&gt;second, m.rbegin()-&gt;second 其他: m.size(), m.empty(), m.clear(), m.find(key)
红黑树
基于红黑树实现，键值对存储，键唯一且自动排序，查找效率高。
是
是
否（multimap可以重复）




]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>latex常用希腊字母</title>
    <url>/2024/06/05/%E5%B8%B8%E7%94%A8%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[latex列展示的是小写，如果需要大写只需要将首字母大写即可。




小写
大写
latex




α
A
\alpha


β
B
\beta


γ
Γ
\gamma


δ
Δ
\delta


ϵ
E
\epsilon                     


ζ
Z
\zeta


ν
N
\nu


ξ
Ξ
\xi


ο
O
\omicron


π
Π
\pi


ρ
P
\rho


σ
Σ
\sigma


η
H
\eta


θ
Θ
\theta


ι
I
\iota


κ
K
\kappa


λ
Λ
\lambda


μ
M
\mu


τ
T
\tau


$\upsilon$
$\Upsilon$
\upsilon


ϕ
Φ
\phi


χ
X
\chi


ψ
Ψ
\psi


ω
Ω
\omega




]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>构建一个简易x86系统的准备</title>
    <url>/2025/06/06/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93x86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[构建一个简易x86系统的准备环境配置：win10+cmake-3.23.1-windows-i386+x86_64-elf-tools-windows
（强烈建议使用网课提供的工具链版本，否则会有很多问题）
前置知识计算机的启动流程

上电启动后，CPU处于16位运行的实模式，分页机制禁止，此时只有1MB内存可用，没有特权级

CPU跳转到BIOS的入口 (地址为0XFFFF0，也就是说，BIOS程序的第一条指令就设计在这个位置)开始执行

BIOS进行硬件自检(POST)，主板、硬盘、显卡、内存等自检，并保存一些配置数据到特定内存地址处(如硬盘的数量)
根据配置的启动顺序(光驱、U盘、硬盘等)，加载引导代码运行。例，从硬盘启动时，将硬盘的第1扇区(主引导纪录)读取到0x7c00处并且跳转到该地址处运行
引导代码对操作系统的运行初始环境进行配置，并加载操作系统到内存中
跳转到操作系统运行。

实模式实模式是计算机处理器（例如x86架构处理器）的一种工作模式，也是x86处理器最基础的操作模式，主要用于兼容早期的操作系统和软件，其目的是直接访问物理内存并提供简单的硬件控制机制。实模式在现代计算机中主要作为启动过渡模式存在，其核心功能已被保护模式和长模式（Long Mode，x86-64 架构的 64 位模式）取代。
实模式的主要特点
内存寻址方式

采用分段寻址（Segmented Addressing），通过 “段寄存器（如 CS、DS、ES、SS）+ 偏移地址” 的组合来生成 20 位物理地址（早期 8086 处理器），最大可访问内存空间为 1MB（地址范围：0x00000~0xFFFFF）。
物理地址计算方式：物理地址 = 段寄存器值 × 16（左移 4 位） + 偏移地址例如：段寄存器值为0x1000，偏移地址为0x2000，则物理地址为 0x1000×16 + 0x2000 = 0x12000。


处理器权限

实模式下，处理器处于特权级 0（最高权限），程序可以直接访问硬件资源（如 I/O 端口、内存等），缺乏内存保护机制。这意味着应用程序可能因错误操作导致系统崩溃（例如覆盖操作系统代码）。


兼容性

实模式是 x86 处理器加电启动后的默认模式，用于加载和初始化操作系统，随后切换到保护模式（Protected Mode）以支持更大的内存空间和更安全的内存管理。
现代操作系统（如 Windows、Linux）在启动初期会短暂运行在实模式，完成硬件检测、初始化寄存器等操作后，再切换到保护模式。



保护模式保护模式是现代计算机处理器的一种工作模式，与早期的实模式宪兵队，他是为了解决实模式的局限性（内存寻址空间小，缺乏内存保护机制等）设计的，是现代操作系统的运行基础。
整体的操作流程
在VSCode中编写C源文件、汇编文件、链接脚本；

CMake根据配置脚本，调用GCC对源文件进行编译和汇编，调用LD进行链接生成可执行的ELF文件；

CMake还会调用OBJCOPY将ELF文件进行缩小，或者转换成BIN文件；
调试前，Visual Studio Code调用一些小工具将ELF、BIN文件写入磁盘映像；
调试时，QEMU加载磁盘映像文件，然后等待GDB连接，这里主要是在tasks.json和launch.json中进行编写；
GDB连接上QEMU，开始正式的调试过程。

我们要实现的是自己的引导代码和操作系统，引导程序的作用如下：采用二级加载模式，boot只完成loader加载工作，再有loader完成具体的初始化工作和内核的加载。也就是Boot-&gt;loader-&gt;kernel的流程。

]]></content>
      <categories>
        <category>x86操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>x86操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>文件属性与目录操作函数</title>
    <url>/2025/02/20/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[文件属性与目录操作函数文件属性操作函数access用于检查调用进程是否具有对指定文件的某种访问权限，或者文件是否存在。
#include &lt;unistd.h&gt;int access(const char *pathname, int mode);
pathname：指向要检查的文件或目录的路径名的字符串指针。mode：指定要检查的访问权限模式，它可以是以下几个常量的按位或组合：R_OK：检查是否有读权限。W_OK：检查是否有写权限。X_OK：检查是否有执行权限。F_OK：检查文件是否存在。返回值成功：如果进程具有指定的访问权限或者文件存在（根据 mode 参数），则返回 0。失败：返回 -1，并设置 errno 来指示具体的错误，例如 EACCES 表示没有相应的权限，ENOENT 表示文件不存在。
chmod用于修改文件或目录的权限。
#include &lt;sys/stat.h&gt;int chmod(const char *pathname, mode_t mode);
pathname：指向要修改权限的文件或目录的路径名的字符串指针。mode：指定新的权限模式，通常使用八进制数表示，例如 0644 表示文件所有者有读写权限，组用户和其他用户有只读权限。也可以使用一些常量的按位或组合，如 S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH 与 0644 是等价的。返回值成功：返回 0。失败：返回 -1，并设置 errno 来指示具体的错误，例如 EACCES 表示没有足够的权限来修改文件权限，ENOENT 表示文件不存在。
truncate用于将文件截断为指定的长度。
#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int truncate(const char *path, off_t length);
path：指向要截断的文件的路径名的字符串指针。length：指定的文件新长度，类型为 off_t。返回值成功：返回 0。失败：返回 -1，并设置 errno 来指示错误原因，如 EACCES 表示无权限修改文件，ENOENT 表示文件不存在。
目录操作函数chdir用于改变当前工作目录，也就是让程序后续的文件操作（如相对路径的文件读写）基于新指定的目录来执行。
#include &lt;unistd.h&gt;int chdir(const char *path);
path：一个指向字符串的指针，代表要切换到的目标目录的路径。可以是绝对路径（如 /home/user/documents），也可以是相对路径（如 ./subdir）。返回值成功：返回 0，表示当前工作目录已成功切换到指定路径。失败：返回 -1，同时会设置 errno 变量来指示具体的错误原因。常见的错误包括 ENOENT（指定的目录不存在）、EACCES（没有权限访问该目录）等。
mkdir用于创建一个新的目录。
#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int mkdir(const char *pathname, mode_t mode);
pathname：指向要创建的目录的路径名的字符串指针。mode：指定新创建目录的权限模式，通常用八进制数表示，例如 0755 表示目录所有者具有读、写、执行权限，组用户和其他用户具有读和执行权限。返回值成功：返回 0，表示目录创建成功。失败：返回 -1，并设置 errno 变量。可能的错误有 EEXIST（指定路径的目录已经存在）、EACCES（没有权限在指定位置创建目录）等。
rename可用于重命名文件或目录，也可以将文件或目录从一个位置移动到另一个位置（前提是目标位置在同一文件系统中）。
#include &lt;stdio.h&gt;int rename(const char *oldpath, const char *newpath);
oldpath：指向要重命名或移动的文件或目录的当前路径名的字符串指针。newpath：指向文件或目录的新路径名的字符串指针。返回值成功：返回 0，表示重命名或移动操作成功完成。失败：返回 -1，同时设置 errno 变量。常见错误包括 ENOENT（旧路径的文件或目录不存在）、EEXIST（新路径的文件或目录已经存在且不能被覆盖）等。
目录遍历函数opendir用于打开一个目录，并返回一个指向 DIR 类型对象的指针，该对象表示已打开的目录流。
#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR *opendir(const char *name);
readdir从 opendir 打开的目录流中读取下一个目录项，并返回一个指向 struct dirent 类型对象的指针，该对象包含了目录项的相关信息，如文件名等。当没有更多目录项时，返回 NULL。
#include &lt;dirent.h&gt;struct dirent *readdir(DIR *dirp);
struct dirent结构体通常包含以下成员：
struct dirent &#123;    ino_t          d_ino;       /* inode 编号 */    off_t          d_off;       /* 目录项在目录文件中的偏移量 */    unsigned short d_reclen;    /* 目录项的长度 */    unsigned char  d_type;      /* 目录项的类型 */    char           d_name[256]; /* 目录项的名称 */&#125;;
closedir关闭由 opendir 打开的目录流，释放相关资源。
#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;int closedir(DIR *dirp);
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——沙漠面积</title>
    <url>/2024/02/24/%E6%B2%99%E6%BC%A0%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[题目：我们获得了一幅陆地和水域情况的卫星照片，照片可以看成是一个 n 行 m 列的矩形，矩形中的每个格子要么是陆地（用半角点号 . 表示），要么是水域（用井号 #表示）。
虽然卫星照片可以清楚的辨别出陆地和水域，但陆地的具体类型却并不明确。现在我们了解到，对于一块是水域的方格，它向上、下、左、右四个方向 k 步之内可达的陆地格子，均会形成沙滩。例如，下图展示了 k=2 的情况，蓝色的格子代表水域，标为黄色的陆地格子是沙滩。你的任务是根据卫星照片计算出属于“沙滩”格子的数量。注意：卫星照片只拍摄了包含水域的部分，水域附近的沙滩可能出现在卫星照片边界之外。你可以假设卫星照片之外不存在任何水域。输入输入的第一行是空格分隔的三个整数 n,m 和k，代表拍摄的卫星照片共有 n 行 m 列，以及形成沙滩的范围k。
接下来 n 行，每行一个字符串。字符串的长度恰好是m，代表卫星照片的一行，其中：
井号#表示一片水域；半角点号.表示一片陆地。
输出
输出一行一个整数，代表沙滩格子的数量。


样例输入1
2 4 2
##.#
…#



样例输出1
26


样例输入2
5 10 3
…#

…########

…#

#…###.#

…####…#



样例输出2
103


提示
对于 40% 的数据，满足 n=m=1；

对于 100% 的数据，满足 1≤n,m≤100，1≤k≤10。



题解#include &lt;bits/stdc++.h&gt;using namespace std;char a[500][500];int ans;int n,m,k;void dfs(int x, int y, int step)&#123;    if (a[x][y] != &#x27;#&#x27;) a[x][y] = &#x27;?&#x27;; //如果当前位置字符不是#，将其修改为？，表示经过该位置    if (step == k) return;  //如果步数达到了k，则递归结束    dfs(x+1,y,step+1);    dfs(x,y+1,step+1);    dfs(x-1,y,step+1);    dfs(x,y-1,step+1); //对该位置的上下左右分别调用dfs，行数或列数每变换一次步数+1&#125;int main()&#123;     cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for (int i = 1+249; i &lt;= n+249; i++)        for (int j = 1+249; j &lt;= m+249; j++)            cin &gt;&gt; a[i][j]; //读取数组a[i][j]    for (int i = 1+249; i &lt;= n+249; i++)        for (int j = 1+249; j &lt;= m+249; j++)            if (a[i][j] == &#x27;#&#x27;) dfs(i,j,0); //遍历数组的每个位置，对于存在水源的地方调用dfs    for (int i = 1; i &lt;= 500; i++)        for (int j = 1; j &lt;= 500; j++)            if (a[i][j] == &#x27;?&#x27;) ans++;//统计所有标记的地点    cout &lt;&lt; ans &lt;&lt; endl; //输出    return 0;&#125;
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>c++</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>进程创建常用函数</title>
    <url>/2025/02/23/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[进程创建常用函数forkfork() 系统调用的主要功能是创建一个新的进程，这个新进程被称为子进程，而调用 fork() 的进程则被称为父进程。子进程是父进程的一个副本，它会复制父进程的大部分状态，包括内存空间、文件描述符、程序计数器等。
#include &lt;unistd.h&gt;pid_t fork(void);
在父进程中：fork() 调用会返回子进程的进程 ID（PID），这是一个正整数。通过这个 PID，父进程可以对特定的子进程进行管理，比如等待子进程结束、向子进程发送信号等。在子进程中：fork() 调用返回 0。子进程可以根据这个返回值来判断自己是子进程，并执行相应的操作。出错时：fork() 调用返回 -1，并设置 errno 来指示具体的错误原因，常见的错误包括系统资源不足等。
exec()函数族主要功能是用一个新的程序替换当前进程的映像。也就是说，调用 exec() 后，当前进程会放弃原来执行的程序，转而执行新的程序。注意，exec() 调用不会创建新的进程，它只是在当前进程的上下文中加载并执行新的程序。
#include &lt;unistd.h&gt;int execl(const char *path, const char *arg, ... /* (char  *) NULL */);int execv(const char *path, char *const argv[]);int execle(const char *path, const char *arg, ... /*, (char *) NULL, char * const envp[] */);int execve(const char *filename, char *const argv[], char *const envp[]);int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);
返回值exec() 系列函数只有在出错时才会返回 -1，并设置 errno 来指示具体的错误原因，比如文件不存在、权限不足等。如果调用成功，exec() 函数不会返回，因为当前进程已经被新的程序所替换。

在实际应用中，fork() 和 exec() 通常会组合使用。一般的做法是先使用 fork() 创建一个子进程，然后在子进程中调用 exec() 来执行新的程序，而父进程可以继续执行其他任务，或者等待子进程结束。这种组合方式可以实现多任务处理，例如在一个程序中启动另一个程序来完成特定的任务。
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞和非阻塞，同步、异步I/O</title>
    <url>/2025/03/04/%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5I-O/</url>
    <content><![CDATA[阻塞和非阻塞，同步、异步I/O阻塞和非阻塞，同步和异步是描述I/O操作行为的两组概念，从不同的角度买哦输了程序如何处理任务和数据传输。
阻塞和非阻塞阻塞I/O（Blocking）当用户程序执行read时，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序缓冲区中，当这两个过程完成read才会返回。


特点：
程序在执行 I/O 操作时会挂起，无法执行其他任务。
简单易用，适合单任务场景。



非阻塞I/O(Non-blocking)非阻塞的read请求在数据为准备好的情况下会立刻返回，可以继续向下执行，此时应用程序会不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read调用才可以获取到结果。

注意：这里的最后一次read调用获取数据的过程，是一个同步的过程，是需要等待的过程。

特点：
程序不会挂起，可以继续执行其他任务。
需要轮询或事件驱动机制来检查操作是否完成。
适合多任务或高并发场景。



同步和异步同步程序发起一个 I/O 操作后，必须等待操作完成才能继续执行后续代码。
这里的等待指的是从内核缓冲区将数据拷贝到应用程序的过程，无论read或send是阻塞I/O还是非阻塞I/O，都是同步的过程。
异步程序发起一个 I/O 操作后，不需要等待操作完成，而是通过回调、信号或事件通知机制在操作完成后得到通知。
真正的异步I/O是内核数据准备好和数据从内核缓冲区拷贝到应用程序缓冲区的过程都不需要等待。
调用 aio_read()（异步I/O） 读取数据时，程序会立即返回，数据到达后通过回调函数通知程序。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>操作系统</tag>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
</search>
