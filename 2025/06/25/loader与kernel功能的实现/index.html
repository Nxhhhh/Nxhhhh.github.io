<!DOCTYPE html>
<html  lang="zh-CN" >
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <title>loader与kernel功能的实现 | 小牛学习日记</title>
    <meta name="description" content="显示字符串和内存检测显示字符串显示字符串其实就是反复调用BIOS显示字符风方式来显示一个完整的字符串，用于loader加载程序在初始化过程中显示进度、错误信息等。 具体代码采用内联汇编的形式，在C代码中嵌入汇编语句，使用__asm__关键字，加上__volatile__关键字避免编译器优化内联汇编语句（和C++非常像） 1234567891011static void show_message(c">
<meta property="og:type" content="article">
<meta property="og:title" content="loader与kernel功能的实现">
<meta property="og:url" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="小牛学习日记">
<meta property="og:description" content="显示字符串和内存检测显示字符串显示字符串其实就是反复调用BIOS显示字符风方式来显示一个完整的字符串，用于loader加载程序在初始化过程中显示进度、错误信息等。 具体代码采用内联汇编的形式，在C代码中嵌入汇编语句，使用__asm__关键字，加上__volatile__关键字避免编译器优化内联汇编语句（和C++非常像） 1234567891011static void show_message(c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/2.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/3.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/before.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/after.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/image0330.png">
<meta property="article:published_time" content="2025-06-25T15:22:16.000Z">
<meta property="article:modified_time" content="2025-06-25T15:26:57.322Z">
<meta property="article:author" content="Xinhang Niu">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png">

    
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

    
<link rel="stylesheet" href="/css/common.min.css">



    
        <link href="//cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" rel="stylesheet">
    
    
    
    
        <link href="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/css/lightgallery.min.css" rel="stylesheet">
    
    
    
<link rel="stylesheet" href="/css/iconfont.min.css">

    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

    <body>
        <header class="header header-fixture">
    <div class="profile-search-wrap flex sm:block">
        
        
        <div class="profile sm:text-center md:px-1 lg:px-3 sm:pb-4 sm:pt-6">
            <a id="avatar" role="link" href="" class="inline-block lg:w-16 lg:h-16 w-8 h-8 m-2" target="_blank" rel="noopener" rel="noreferrer" >
                <img src="https://www.gravatar.com/avatar/2f602fee60513793a9d9ce0b4f3e0d3b?s=128" class="rounded-full" alt="avatar">
            </a>
            <h2 id="name" class="hidden lg:block">Niuxinhang</h2>
            <h3 id="title" class="hidden lg:block">Student &amp; Coder</h3>
            
        </div>
        
        
<div class="search flex-1 flex lg:inline-block sm:hidden lg:px-4 lg:mt-2 lg:mb-4 lg:w-full">
    <form id="search-form" class="my-auto flex-1 lg:border lg:border-solid lg:border-gray-200">
        <div class="input-group table bg-gray-100 lg:bg-white w-full">
            <input id="search-input" type="text" placeholder="搜索" class="inline-block w-full bg-gray-100 lg:bg-white p-1">
            <span class="table-cell">
                <button name="search tigger button" disabled>
                    <i class="iconfont icon-search m-2"></i>
                </button>
            </span>
        </div>
    </form>
        
<div id="content-json" data-placeholder="搜索" class="invisible hidden">/content.json</div>
<script id="search-teamplate" type="text/html" data-path="/content.json">
    <div>
        <div class="search-header bg-gray-400">
            <input id="actual-search-input" model="keyword" ref="input" class="inline-block w-full h-10 px-2 py-1" placeholder="搜索" type="text">
        </div>
        <div class="search-result bg-gray-200">
            {{#each searchPosts}}
            <a href="/{{ path }}" class="result-item block px-2 pb-3 mb-1 pt-1 hover:bg-indigo-100">
                <i class="iconfont icon-file"></i>
                <h1 class="result-title inline font-medium text-lg">{{ title }}</h1>
                <p class="result-content text-gray-600 text-sm">{{{ text }}}</p>
            </a>
            {{/each}}
        </div>
    </div>
</script>

</div>


        <button name="menu toogle button" id="menu-toggle-btn" class="block sm:hidden p-3" role="button" aria-expanded="false">
            <i class="iconfont icon-hamburger"></i>
        </button>
    </div>
    <nav id="menu-nav" class="hidden sm:flex flex-col">
        
        
            <div class="menu-item menu-home" role="menuitem">
                <a href="/.">
                    <i class="iconfont icon-home" aria-hidden="true"></i>
                    <span class="menu-title">首页</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-archives" role="menuitem">
                <a href="/archives">
                    <i class="iconfont icon-archive" aria-hidden="true"></i>
                    <span class="menu-title">归档</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-categories" role="menuitem">
                <a href="/categories">
                    <i class="iconfont icon-folder" aria-hidden="true"></i>
                    <span class="menu-title">分类</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-tags" role="menuitem">
                <a href="/tags">
                    <i class="iconfont icon-tag" aria-hidden="true"></i>
                    <span class="menu-title">标签</span>
                </a>
            </div>
        
        

    </nav>
</header>

        <section class="main-section">
            
    <main class="flex-1 px-4 py-14 md:px-5 lg:px-8 lg:py-4 relative min-h-screen">
    

    <article class="content article article-archives article-type-list" itemscope="">
        <header class="article-header">
            
    
        <h1 class="article-title text-lg" itemprop="name">
            loader与kernel功能的实现
        </h1>
    



            <p class="article-meta mb-3 text-xs">
                <span class="article-date">
    <i class="iconfont icon-calendar-check"></i>
	<a href="/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
	  <time datetime="2025-06-25T15:22:16.000Z" itemprop="datePublished">6月 25</time>
	</a>
</span>

                
    <span class="article-category">
    <i class="iconfont icon-folder"></i>
    <a class="article-category-link" href="/categories/C/">C++</a>
  </span>


                
    <span class="article-tags">
    <i class="iconfont icon-tag"></i>
    <a class="article-tag-none-link" href="/tags/Linux/" rel="tag">Linux</a>, <a class="article-tag-none-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a>
  </span>


                <span class="_partial/post-comment"><i class="icon icon-comment"></i>
                    <a href="/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/#comments" class="article-comment-link">
                        评论
                    </a>
                </span>
                
    
        <span class="post-wordcount" itemprop="wordCount">字数统计: 3.7k(字)</span>
    
    
        <span class="post-readcount" itemprop="timeRequired">阅读时长: 15(分)</span>
    


            </p>
        </header>
        <div class="marked-body article-body">
            <h2 id="显示字符串和内存检测"><a href="#显示字符串和内存检测" class="headerlink" title="显示字符串和内存检测"></a>显示字符串和内存检测</h2><h3 id="显示字符串"><a href="#显示字符串" class="headerlink" title="显示字符串"></a>显示字符串</h3><p>显示字符串其实就是反复调用BIOS显示字符风方式来显示一个完整的字符串，用于loader加载程序在初始化过程中显示进度、错误信息等。</p>
<p>具体代码采用内联汇编的形式，在C代码中嵌入汇编语句，使用<code>__asm__</code>关键字，加上<code>__volatile__</code>关键字避免编译器优化内联汇编语句（和C++非常像）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_message</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=*message++)!=<span class="string">&#x27;\0&#x27;</span>) &#123;  <span class="comment">//在没有遇到结束符&#x27;\0&#x27;前循环显示指定字符</span></span><br><span class="line">        <span class="comment">//在c中使用汇编指令需要采取内联汇编的形式</span></span><br><span class="line">        __asm__ __volatile__( <span class="comment">//使用volatile关键字避免编译器对汇编语句的优化</span></span><br><span class="line">            <span class="string">&quot;mov $0xe, %%ah\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;mov %[ch], %%al\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;int $0x10&quot;</span>::[ch]<span class="string">&quot;r&quot;</span>(c)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存容量检测"><a href="#内存容量检测" class="headerlink" title="内存容量检测"></a>内存容量检测</h3><p>使用的方法为<code>INT 0x15, EAX = 0xE820</code></p>
<p>具体原理不是关注重点，因此直接忽略，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">detect_memory</span><span class="params">(<span class="type">void</span>)</span> &#123;  <span class="comment">//检测内存容量，应该有128M</span></span><br><span class="line">    <span class="type">uint32_t</span> contID=<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> signature, bytes;</span><br><span class="line">    SMAP_entry_t smap_entry;</span><br><span class="line">    show_message(<span class="string">&quot;try to detect memory:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    boot_info.ram_region_count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;BOOT_RAM_REGION_MAX;i++) &#123;</span><br><span class="line">        SMAP_entry_t* entry=&amp;smap_entry;</span><br><span class="line"></span><br><span class="line">        __asm__ __volatile__(<span class="string">&quot;int  $0x15&quot;</span> </span><br><span class="line">				: <span class="string">&quot;=a&quot;</span>(signature), <span class="string">&quot;=c&quot;</span>(bytes), <span class="string">&quot;=b&quot;</span>(contID)</span><br><span class="line">				: <span class="string">&quot;a&quot;</span>(<span class="number">0xE820</span>), <span class="string">&quot;b&quot;</span>(contID), <span class="string">&quot;c&quot;</span>(<span class="number">24</span>), <span class="string">&quot;d&quot;</span>(<span class="number">0x534D4150</span>), <span class="string">&quot;D&quot;</span>(entry));</span><br><span class="line">        <span class="keyword">if</span>(signature != <span class="number">0x534D4150</span>) &#123;</span><br><span class="line">            show_message(<span class="string">&quot;failed\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bytes &gt; <span class="number">20</span> &amp;&amp; (entry-&gt;ACPI &amp; <span class="number">0x0001</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// ignore this entry</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(entry-&gt;Type == <span class="number">1</span>) &#123; <span class="comment">//ram中有一部分内存被硬件或其他设备占用，因此需要判断类型，type为1可以被操作系统使用 </span></span><br><span class="line">            boot_info.ram_region_cfg[boot_info.ram_region_count].start=entry-&gt;BaseL; <span class="comment">//操作系统为32位操作系统，只需要读取低32位</span></span><br><span class="line">            boot_info.ram_region_cfg[boot_info.ram_region_count].size=entry-&gt;LengthL; <span class="comment">//同样只读低32位</span></span><br><span class="line">            boot_info.ram_region_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(contID == <span class="number">0</span>) &#123;  <span class="comment">//如果contID为0，说明整个读取已经结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    show_message(<span class="string">&quot;detect finish!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切换保护模式"><a href="#切换保护模式" class="headerlink" title="切换保护模式"></a>切换保护模式</h2><h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><p><img src="1.png" alt="1"></p>
<p>x86在上电启动后自动进入实模式，即16位工作模式，这种模式是最早期的8086芯片所使用的工作模式。早期的芯片设计得较简单、工作模式也较简单，所以有诸多限制：</p>
<ol>
<li>最大只能访问1MB的内存：采用段值：偏移的方式访问，内核寄存器最大为16位宽。如段寄存器CS, DS, ES, FS, GS,  SS均为16位宽，AX, BX, CX DX, SI, DI, SP等也均为16位宽</li>
<li>所有的操作数最大为16位宽，出栈入栈也以16位为单位</li>
<li>没有任何保护机制，意味着应用程序可以读写内存中的任意位置</li>
<li>没有特权级支持，意味着应用程序可以随意执行任何指令，例如停机指令、关中断指令</li>
<li>没有分页机制和虚拟内存的支持</li>
</ol>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p><img src="2.png" alt="2">在后续的芯片设计中，intel为处理器增加了一些新的功能，可以实现某些保护功能，即保护模式。具体的特点如下：</p>
<ul>
<li>寄存器位宽扩展至==32位==，例如AX扩展至32位的EAX，最大可访问4GB内存</li>
<li>所有操作数最大为32位宽，出入栈也为32位</li>
<li>提供4种特权级。==操作系统可以运行在最高特权级，可执行任意指令；应用程序可运行于最低特权级，避免其执行某些特权指令，例如停机指令、关中断指令==</li>
<li>==支持虚拟内存，可以开启分页机制==，以隔离不同的应用程序</li>
</ul>
<h3 id="切换至保护模式"><a href="#切换至保护模式" class="headerlink" title="切换至保护模式"></a>切换至保护模式</h3><p><img src="3.png" alt="3">要切换至保护模式，需要遵循以下流程。</p>
<ul>
<li>禁用中断，防止中途发生中断导致程序运行发生异常</li>
<li>打开A20 地址线（为了保证后续的cpu可以兼容以前的程序运行：在早期的 IBM PC 中，地址线 A20 被硬连线到逻辑 0，导致 CPU 无法访问超过 1MB 的内存（2^20 = 1MB）。这是为了与旧版软件兼容。当切换到保护模式时，我们需要启用 A20 地址线，以便访问完整的 4GB 地址空间。）</li>
<li>加载GDT表（GDT 是保护模式下的核心数据结构，定义了内存段的访问权限和基址。）</li>
<li>设置CR0，开启保护模式使能位（也就是PE位）</li>
<li>远跳转，清空流水线（当我们将 CR0 寄存器的 PE 位置 1 后，CPU 立即进入保护模式，但此时的指令流水线中仍然是按照实模式解释的指令。如果不清除这些指令，会导致严重的错误。）</li>
</ul>
<p>函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">enter_protect_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;  <span class="comment">//进入保护模式</span></span><br><span class="line">    cli();  <span class="comment">//关中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//启用A20地址线</span></span><br><span class="line">    <span class="type">uint8_t</span> v=inb(<span class="number">0x92</span>);</span><br><span class="line">    outb(<span class="number">0x92</span>, v | <span class="number">0x2</span>);  <span class="comment">//将读取的值与 0x2 进行按位或操作，设置第 2 位</span></span><br><span class="line"></span><br><span class="line">    lgdt((<span class="type">uint32_t</span>)gdt_table, <span class="keyword">sizeof</span>(gdt_table));  <span class="comment">//加载GDT表</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> cr0 = read_cr0(); <span class="comment">//将CR0寄存器的PE位置为1，开启保护模式使能位</span></span><br><span class="line">    write_cr0(cr0 | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>));  <span class="comment">//1&lt;&lt;0：生成值 0x00000001，与CR0或，将第0位设置为1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空流水线</span></span><br><span class="line">    far_jump(<span class="number">8</span>, (<span class="type">uint32_t</span>)protect_mode_entry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用lgdt进行GDT表加载时，需要注意qemu上的gdt表是否成功写入，以及gdt_table的地址与qemu上的registers地址是否一致</p>
<p><img src="before.png" alt="3"></p>
<p><img src="after.png" alt="3"></p>
<h2 id="磁盘读取"><a href="#磁盘读取" class="headerlink" title="磁盘读取"></a>磁盘读取</h2><p>loader还需要从硬盘中读取数据（如解析文件系统，加载操作系统内核等）加载到内存中执行</p>
<p>在实模式是，是采用软中断的方式读取磁盘，进入保护模式之后就需要重新设置磁盘读取的方式。这里采用的是LBA48模式</p>
<p>LBA48模式将硬盘上所有的扇区看成线性排列，没有磁盘、柱面等概念，因此访问起来更加简单，扇区序号从0开始。其访问序列如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_disk</span><span class="params">(<span class="type">uint32_t</span> sector, <span class="type">int</span> sector_count, <span class="type">uint8_t</span> * buf)</span> &#123;</span><br><span class="line">    <span class="comment">//设置设备选择寄存器0x1F6</span></span><br><span class="line">    outb(<span class="number">0x1F6</span>, <span class="number">0xE0</span>); <span class="comment">//选择硬盘：主盘或从盘</span></span><br><span class="line">    <span class="comment">//0x1F6寄存器每位设置，1110 0000 </span></span><br><span class="line">    <span class="comment">// - 位7: 1（固定为1，表示启用LBA模式）</span></span><br><span class="line">    <span class="comment">// - 位6: 1（LBA模式标志位）</span></span><br><span class="line">    <span class="comment">// - 位5: 1（固定为1，可能用于兼容性）</span></span><br><span class="line">    <span class="comment">// - 位4: 0（选择主盘Master，若为1则选择从盘Slave）</span></span><br><span class="line">    <span class="comment">// - 位3-0: 0（LBA地址的高4位，此处为0）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送扇区数量的高八位</span></span><br><span class="line">    outb(<span class="number">0x1F2</span>, (<span class="type">uint8_t</span>)(sector_count &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    <span class="comment">//发送LBA地址的高4字节（分四次发送，每次一字节）</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, (<span class="type">uint8_t</span>)(sector &gt;&gt; <span class="number">24</span>));</span><br><span class="line">    outb(<span class="number">0x1F4</span>, <span class="number">0</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送扇区数量的低8位和完整LBA地址（覆盖之前的部分设置）</span></span><br><span class="line">    outb(<span class="number">0x1F2</span>, (<span class="type">uint8_t</span>)sector_count);</span><br><span class="line">    outb(<span class="number">0x1F3</span>, (<span class="type">uint8_t</span>)sector);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, (<span class="type">uint8_t</span>)(sector &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (<span class="type">uint8_t</span>)(sector &gt;&gt; <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送读取命令（0x24 = READ SECTORS EXT，扩展读取命令）</span></span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x24</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> * data_buf = (<span class="type">uint16_t</span> *)buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(sector_count--) &#123;</span><br><span class="line">        <span class="comment">// 等待硬盘就绪（轮询状态寄存器0x1F7）</span></span><br><span class="line">        <span class="comment">// 状态寄存器的位7=1表示硬盘忙，位3=1表示数据就绪</span></span><br><span class="line">        <span class="comment">// 当状态为0x08（即0000 1000）时，表示数据就绪且不忙</span></span><br><span class="line">        <span class="keyword">while</span>((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0x88</span>) != <span class="number">0x8</span>) &#123;&#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取当前扇区数据（每扇区通常为512字节 = 256个16位字）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;SECTOR_SIZE / <span class="number">2</span> ; i++) &#123;</span><br><span class="line">            *data_buf++=inw(<span class="number">0x1F0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>outb、intb、inw</code>都是由内联汇编定义的函数，分别是按照8位写数据、读数据，还有按照16位读数据，具体就不赘述了。</p>
<p>完成这些步骤后磁盘的空间使用情况如下：</p>
<p>（实际上，上述位置的确定并不唯一，可自行选择合适的地址，只要保证loader能够正确加载即可。<br>可以看到，在第100扇区之前预留了比较大的空间，目的是以后loader代码量增大时，有足够的空间存放，不必再临时调整kernel的位置。）</p>
<p><img src="image0330.png" alt="image0330"></p>
<p>完成以上步骤后，loader加载程序就大体实现了，后面就需要将从loader中获取的启动信息（如内存容量）传递给内核。</p>
<h2 id="内核工程的创建"><a href="#内核工程的创建" class="headerlink" title="内核工程的创建"></a>内核工程的创建</h2><p>创建kernel文件夹与init子文件夹，创建好相应的头文件等，然后从loader跳转到kernel工程中来，将kernel代码放在第100扇区的位置，然后在loader中跳转到0x100000的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">load_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 从第100个扇区开始，大小是500KB，放到1Mb以上的内存位置，因为是保护模式，可以使用1MB以上的内存空间</span></span><br><span class="line">    read_disk(<span class="number">100</span>, <span class="number">500</span>, (<span class="type">uint8_t</span> *)SYS_KERNEL_LOAD_ADDR); </span><br><span class="line">    <span class="comment">// kernel的跳转代码</span></span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))SYS_KERNEL_LOAD_ADDR)();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向内核传递启动信息"><a href="#向内核传递启动信息" class="headerlink" title="向内核传递启动信息"></a>向内核传递启动信息</h2><p>定义一个kernel_init函数，并且传入启动信息，这里涉及到了一些调用函数的函数栈的变化。</p>
<p>举一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">(<span class="type">boot_info_t</span> * boot_info)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    test(a, b);</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在32位系统下，调用上述函数时，就会是这样的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">(<span class="type">boot_info_t</span> *boot_info)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 函数开头：建立栈帧</span></span><br><span class="line">    push %ebp        <span class="comment">// 保存调用者（父函数）的 ebp</span></span><br><span class="line">    mov %esp, %ebp   <span class="comment">// 让 kernel_init 的 ebp 指向当前栈顶（刚压入的旧 ebp 位置）。</span></span><br><span class="line">    sub $<span class="number">0x10</span>, %esp  <span class="comment">// 分配 16 字节空间给 kernel_init 的局部变量（a、b 等）。</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*栈帧状态：</span></span><br><span class="line"><span class="comment">        栈底（高地址） →  旧ebp（父函数的ebp）  </span></span><br><span class="line"><span class="comment">                        返回地址（父函数调用kernel_init的返回地址，图里未画全）  </span></span><br><span class="line"><span class="comment">                        局部变量空间（16字节，未初始化）  </span></span><br><span class="line"><span class="comment">		栈顶（低地址） ←  kernel_init的esp（sub $0x10后，esp指向这里）  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 2. 定义局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>; </span><br><span class="line">    <span class="comment">// 对应汇编：</span></span><br><span class="line">    <span class="comment">// movl $0x1, -0x4(%ebp)  → a = 1（存在 ebp-4）</span></span><br><span class="line">    <span class="comment">// movl $0x2, -0x8(%ebp)  → b = 2（存在 ebp-8）</span></span><br><span class="line">    <span class="comment">/*栈帧状态：</span></span><br><span class="line"><span class="comment">        栈底 →  旧ebp（父函数）  </span></span><br><span class="line"><span class="comment">                返回地址（父函数）  </span></span><br><span class="line"><span class="comment">                局部变量a=1（ebp-4）  </span></span><br><span class="line"><span class="comment">                局部变量b=2（ebp-8）  </span></span><br><span class="line"><span class="comment">                剩余局部变量空间（8字节，图里简化了）  </span></span><br><span class="line"><span class="comment">        栈顶 ←  kernel_init的esp  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 调用 test(a, b)</span></span><br><span class="line">    test(a, b); </span><br><span class="line">    <span class="comment">// 对应汇编：</span></span><br><span class="line">    <span class="comment">// push -0x8(%ebp)  → 压入 b（从右往左传参）</span></span><br><span class="line">    <span class="comment">// push -0x4(%ebp)  → 压入 a</span></span><br><span class="line">    <span class="comment">// call 1000c &lt;test&gt; → 压入返回地址</span></span><br><span class="line">    <span class="comment">/*栈帧状态：</span></span><br><span class="line"><span class="comment">    	栈底 →  旧ebp（父函数）  </span></span><br><span class="line"><span class="comment">                返回地址（父函数）  </span></span><br><span class="line"><span class="comment">                局部变量a=1  </span></span><br><span class="line"><span class="comment">                局部变量b=2  </span></span><br><span class="line"><span class="comment">                参数b=2（刚压入的）  </span></span><br><span class="line"><span class="comment">                参数a=1（刚压入的）  </span></span><br><span class="line"><span class="comment">                返回地址（kernel_init → test的返回地址）  </span></span><br><span class="line"><span class="comment">		栈顶 ←  kernel_init的esp（call后，esp指向这里）  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 死循环（省略细节）</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 函数开头：建立栈帧</span></span><br><span class="line">    push %ebp        <span class="comment">// 保存旧ebp（kernel_init的ebp）</span></span><br><span class="line">    mov %esp, %ebp   <span class="comment">// 新ebp = 旧esp</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 计算返回值 a + b</span></span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">    <span class="comment">// 对应汇编：</span></span><br><span class="line">    <span class="comment">// mov 0x8(%ebp), %edx  → a = ebp+8</span></span><br><span class="line">    <span class="comment">// mov 0xc(%ebp), %eax  → b = ebp+c</span></span><br><span class="line">    <span class="comment">// add %edx, %eax       → 返回值 = a + b</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 函数结尾：销毁栈帧</span></span><br><span class="line">    pop %ebp         <span class="comment">// 恢复旧ebp（kernel_init的ebp）</span></span><br><span class="line">    ret              <span class="comment">// 弹出返回地址，回到kernel_init</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*test栈帧状态：</span></span><br><span class="line"><span class="comment">    	栈底 →  旧ebp（父函数）  </span></span><br><span class="line"><span class="comment">                返回地址（父函数）  </span></span><br><span class="line"><span class="comment">                局部变量a=1  </span></span><br><span class="line"><span class="comment">                局部变量b=2  </span></span><br><span class="line"><span class="comment">                参数b=2  </span></span><br><span class="line"><span class="comment">                参数a=1  </span></span><br><span class="line"><span class="comment">                返回地址（kernel_init → test）  </span></span><br><span class="line"><span class="comment">                旧ebp（kernel_init的ebp）  → test的ebp指向这里！  </span></span><br><span class="line"><span class="comment">		栈顶 ←  test的esp（push %ebp后，esp指向这里）  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>将以上栈帧变化反映到项目中就是将loader中读取到的相关配置信息（比如存储内存容量信息的结构体boot_info）传递给内核，采取的就是调用函数的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    # 第一种方法</span><br><span class="line">    # push %ebp</span><br><span class="line">    # mov %esp, %ebp</span><br><span class="line">    # mov 0x8(%ebp), %eax</span><br><span class="line">    # push %eax</span><br><span class="line"></span><br><span class="line">    # 第二种方法</span><br><span class="line">    # mov 4(%esp), %eax</span><br><span class="line">    # push %eax</span><br><span class="line"></span><br><span class="line">    # 第三种方法</span><br><span class="line">    push 4(%esp)</span><br><span class="line"></span><br><span class="line">    # kernel_init(boot_info)</span><br><span class="line">    call kernel_init</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    	流程相当于：</span><br><span class="line">    	从start的栈中取出参数boot_info并放入eax寄存器中 --&gt; eax寄存器入栈 --&gt; 执行call指令（调用函数）</span><br><span class="line">    */</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="代码-数据段与链接脚本"><a href="#代码-数据段与链接脚本" class="headerlink" title="代码/数据段与链接脚本"></a>代码/数据段与链接脚本</h2><p>GCC工具链默认以<code>.text, .rodata, .data, .bss</code>存储代码和数据。具体来说是：</p>
<p><code>.text: 存储编译后可执行代码（机器指令），如函数体、条件判断、循环逻辑等</code></p>
<p><code>.rodata: 存储程序中声明的只读数据</code> </p>
<p><code>.data: 存储程序中已初始化的全局变量和静态变量</code></p>
<p><code>.bss: 存储程序中未初始化的全局变量和静态变量（初始化为0）</code></p>
<p>也可以自定义链接脚本（lds文件），此时的Cmakelist.txt的配置需要修改成自定义的链接脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x100000; // 起始地址，这里可以修改为别的地址</span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text) // 将所有的目标文件的.text文件都放到一个.text文件中，下同</span><br><span class="line">	&#125; </span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata)</span><br><span class="line">	&#125;</span><br><span class="line">	.data : &#123;</span><br><span class="line">		*(.data)</span><br><span class="line">	&#125;</span><br><span class="line">	.bss : &#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加载内核映像文件"><a href="#加载内核映像文件" class="headerlink" title="加载内核映像文件"></a>加载内核映像文件</h2><p>linux的可执行文件通常为.elf结尾的文件格式，该文件中包含了上面提到的<code>.text, .rodata, .data, .bss</code>隔断的信息，通常解析该文件，找到program header table，并从该表中读取出相应的代码、数据段等相关信息，并将代码和数据加载到对应的内存中，完成整个加载过程。</p>
<p>文件具体的格式就不需要很细致的了解了，具体的加载过程如下：</p>
<ul>
<li>初步检查elf header的合法性（检查开头的格式）</li>
<li>通过elf header-&gt;e_phoff定位到programe header table，遍历elf header-&gt;e_phnum次，加载各个段<ul>
<li>从文件位置p_offset处读取filesz大小的数据，写入到内存中paddr的位置处</li>
<li>如果p_filesz &lt; p_memsz，则将部分内存清零（bss区初始化）</li>
</ul>
</li>
<li>取elf header-&gt;e_entry，跳转到该地址运行。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">reload_elf_file</span> <span class="params">(<span class="type">uint8_t</span> * file_buffer)</span> &#123;</span><br><span class="line">    Elf32_Ehdr * elf_hdr = (Elf32_Ehdr *)file_buffer;</span><br><span class="line">    <span class="comment">/*检查传入的文件是否是elf文件*/</span></span><br><span class="line">    <span class="keyword">if</span> ((elf_hdr-&gt;e_ident[<span class="number">0</span>] != <span class="number">0x7F</span>) || (elf_hdr-&gt;e_ident[<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>) ||</span><br><span class="line">        (elf_hdr-&gt;e_ident[<span class="number">2</span>] != <span class="string">&#x27;L&#x27;</span>) ||(elf_hdr-&gt;e_ident[<span class="number">3</span>] != <span class="string">&#x27;F&#x27;</span>) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从文件中加载程序头，将内容拷贝到相应的位置，提取相应的数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; elf_hdr-&gt;e_phnum; i++) &#123;</span><br><span class="line">        Elf32_Phdr * phdr = (Elf32_Phdr *)(file_buffer + elf_hdr-&gt;e_phoff) + i;</span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">uint8_t</span> * src = file_buffer + phdr-&gt;p_offset;  <span class="comment">//起始地址</span></span><br><span class="line">        <span class="type">uint8_t</span> * dst = file_buffer + phdr-&gt;p_paddr;  <span class="comment">//目的地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制操作，传输text和rodata段是没问题的，但是在elf文件中data和bss段是存放在一起的，没办法通过这种方式读取</span></span><br><span class="line">        <span class="comment">// 并且bss段存放未初始化的数据，也就是全零，只需要知道全零的区域有多大就够了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dst++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*获取结束地址*/</span></span><br><span class="line">        dst = (<span class="type">uint8_t</span> *)phdr-&gt;p_paddr + phdr-&gt;p_filesz;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// memsz和filesz不相等时，后续要填0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; phdr-&gt;p_memsz - phdr-&gt;p_filesz; j++) &#123;</span><br><span class="line">            *dst++ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elf_hdr-&gt;e_entry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*最终从磁盘上加载内核的代码如下*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    read_disk(<span class="number">100</span>, <span class="number">500</span>, (<span class="type">uint8_t</span> *)SYS_KERNEL_LOAD_ADDR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*用于解析在1Mb内存处存放的elf文件，提取代码和数据，放在64Kb（0x10000）开始的位置*/</span></span><br><span class="line">    reload_elf_file((<span class="type">uint8_t</span> *)SYS_KERNEL_LOAD_ADDR); </span><br><span class="line">    <span class="comment">/*跳转到kernel入口处的地址，与1Mb地址0x100000注意区分，那里是放置kernel.lef文件的地址*/</span></span><br><span class="line">    <span class="type">uint32_t</span> kernel_entry = reload_elf_file((<span class="type">uint8_t</span> *)SYS_KERNEL_LOAD_ADDR);</span><br><span class="line">    <span class="keyword">if</span>(kernel_entry == <span class="number">0</span>) &#123;  <span class="comment">//获取错误直接死机</span></span><br><span class="line">        die(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">boot_info_t</span> *))kernel_entry)(&amp; boot_info);  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        
<blockquote class="copyright">
    <p><strong>本文链接 : </strong><a class="permalink" href="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader%E4%B8%8Ekernel%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/">https://github.com/Nxhhhh/Nxhhhh.github.io/2025/06/25/loader与kernel功能的实现/</a></p>
    <p><strong>This article is available under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a> License</strong></p>
</blockquote>


    </article>
    
    <section id="comments">
        
    </section>


    

</main>


<aside style="" id="sidebar" class="aside aside-fixture">
    <div class="toc-sidebar">
        <nav id="toc" class="article-toc">
            <h3 class="toc-title">文章目录</h3>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B"><span class="toc-number">1.</span> <span class="toc-text">显示字符串和内存检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.</span> <span class="toc-text">显示字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F%E6%A3%80%E6%B5%8B"><span class="toc-number">1.2.</span> <span class="toc-text">内存容量检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">切换保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">实模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">保护模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E8%87%B3%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">切换至保护模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AF%BB%E5%8F%96"><span class="toc-number">3.</span> <span class="toc-text">磁盘读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.</span> <span class="toc-text">内核工程的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E5%86%85%E6%A0%B8%E4%BC%A0%E9%80%92%E5%90%AF%E5%8A%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">5.</span> <span class="toc-text">向内核传递启动信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D"><span class="toc-number">5.1.</span> <span class="toc-text">实操</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-%E6%95%B0%E6%8D%AE%E6%AE%B5%E4%B8%8E%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC"><span class="toc-number">6.</span> <span class="toc-text">代码&#x2F;数据段与链接脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">加载内核映像文件</span></a></li></ol>
        </nav>
    </div>
</aside>





        </section>
        <footer class="hidden lg:block fixed bottom-0 left-0 sm:w-1/12 lg:w-1/6 bg-gray-100 z-40">
    
    
</footer>

        <div id="mask" class="hidden mask fixed inset-0 bg-gray-900 opacity-75 z-40"></div>
        <div id="search-view-container" class="hidden shadow-xl"></div>
        
<script src="/js/dom-event.min.js"></script>



<script src="/js/local-search.min.js"></script>



    <script src="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/js/lightgallery.min.js"></script>
    
<script src="/js/light-gallery.min.js"></script>






    </body>
</html>
