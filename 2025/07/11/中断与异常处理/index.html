<!DOCTYPE html>
<html  lang="zh-CN" >
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <title>中断与异常处理 | 小牛学习日记</title>
    <meta name="description" content="中断与异常处理加载出内核后，后续的代码基本就是对内核的设计，首先就是对中断和异常处理的设计。 创建GDT表及其表项x86架构（IA32 模式 ）支持两种存储模式，分段式存储和分页式存储。  分段：先通过分段机制，把逻辑地址（由段选择器和偏移量组成 ）转换为线性地址。利用 全局描述符表（GDT）、局部描述符表（LDT ）等，依据段选择器找到对应的段描述符，算出线性地址 。这是 x86 内存管理的基础">
<meta property="og:type" content="article">
<meta property="og:title" content="中断与异常处理">
<meta property="og:url" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/index.html">
<meta property="og:site_name" content="小牛学习日记">
<meta property="og:description" content="中断与异常处理加载出内核后，后续的代码基本就是对内核的设计，首先就是对中断和异常处理的设计。 创建GDT表及其表项x86架构（IA32 模式 ）支持两种存储模式，分段式存储和分页式存储。  分段：先通过分段机制，把逻辑地址（由段选择器和偏移量组成 ）转换为线性地址。利用 全局描述符表（GDT）、局部描述符表（LDT ）等，依据段选择器找到对应的段描述符，算出线性地址 。这是 x86 内存管理的基础">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/2.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/1.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/3.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/4.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/5.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/6.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/7.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/idt%E5%8A%A0%E8%BD%BD%E5%90%8E%EF%BC%8C%E9%A6%96%E5%9C%B0%E5%9D%80%E8%83%BD%E5%AF%B9%E4%B8%8A.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/8.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/9.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/10.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/11.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/12.png">
<meta property="og:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/13.png">
<meta property="article:published_time" content="2025-07-11T09:01:41.000Z">
<meta property="article:modified_time" content="2025-07-11T09:04:23.634Z">
<meta property="article:author" content="Xinhang Niu">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="x86操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/2.png">

    
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

    
<link rel="stylesheet" href="/css/common.min.css">



    
        <link href="//cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" rel="stylesheet">
    
    
    
    
        <link href="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/css/lightgallery.min.css" rel="stylesheet">
    
    
    
<link rel="stylesheet" href="/css/iconfont.min.css">

    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

    <body>
        <header class="header header-fixture">
    <div class="profile-search-wrap flex sm:block">
        
        
        <div class="profile sm:text-center md:px-1 lg:px-3 sm:pb-4 sm:pt-6">
            <a id="avatar" role="link" href="" class="inline-block lg:w-16 lg:h-16 w-8 h-8 m-2" target="_blank" rel="noopener" rel="noreferrer" >
                <img src="/image/2.png" class="rounded-full" alt="avatar">
            </a>
            <h2 id="name" class="hidden lg:block">Niuxinhang</h2>
            <h3 id="title" class="hidden lg:block">小牛的学习日记</h3>
            
        </div>
        
        
<div class="search flex-1 flex lg:inline-block sm:hidden lg:px-4 lg:mt-2 lg:mb-4 lg:w-full">
    <form id="search-form" class="my-auto flex-1 lg:border lg:border-solid lg:border-gray-200">
        <div class="input-group table bg-gray-100 lg:bg-white w-full">
            <input id="search-input" type="text" placeholder="搜索" class="inline-block w-full bg-gray-100 lg:bg-white p-1">
            <span class="table-cell">
                <button name="search tigger button" disabled>
                    <i class="iconfont icon-search m-2"></i>
                </button>
            </span>
        </div>
    </form>
        
<div id="content-json" data-placeholder="搜索" class="invisible hidden">/content.json</div>
<script id="search-teamplate" type="text/html" data-path="/content.json">
    <div>
        <div class="search-header bg-gray-400">
            <input id="actual-search-input" model="keyword" ref="input" class="inline-block w-full h-10 px-2 py-1" placeholder="搜索" type="text">
        </div>
        <div class="search-result bg-gray-200">
            {{#each searchPosts}}
            <a href="/{{ path }}" class="result-item block px-2 pb-3 mb-1 pt-1 hover:bg-indigo-100">
                <i class="iconfont icon-file"></i>
                <h1 class="result-title inline font-medium text-lg">
                    {{{ title.replace(new RegExp(keyword, 'gi'), function(match) { return '<mark>' + match + '</mark>'; }) }}}
                </h1>
                <!-- 只显示标题，隐藏内容 -->
            </a>
            {{/each}}
        </div>
    </div>
</script>

</div>


        <button name="menu toogle button" id="menu-toggle-btn" class="block sm:hidden p-3" role="button" aria-expanded="false">
            <i class="iconfont icon-hamburger"></i>
        </button>
    </div>
    <nav id="menu-nav" class="hidden sm:flex flex-col">
        
        
            <div class="menu-item menu-home" role="menuitem">
                <a href="/.">
                    <i class="iconfont icon-home" aria-hidden="true"></i>
                    <span class="menu-title">首页</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-archives" role="menuitem">
                <a href="/archives">
                    <i class="iconfont icon-archive" aria-hidden="true"></i>
                    <span class="menu-title">归档</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-categories" role="menuitem">
                <a href="/categories">
                    <i class="iconfont icon-folder" aria-hidden="true"></i>
                    <span class="menu-title">分类</span>
                </a>
            </div>
        
        
            <div class="menu-item menu-tags" role="menuitem">
                <a href="/tags">
                    <i class="iconfont icon-tag" aria-hidden="true"></i>
                    <span class="menu-title">标签</span>
                </a>
            </div>
        
        

    </nav>
</header>

        <section class="main-section">
            
    <main class="flex-1 px-4 py-14 md:px-5 lg:px-8 lg:py-4 relative min-h-screen">
    

    <article class="content article article-archives article-type-list" itemscope="">
        <header class="article-header">
            
    
        <h1 class="article-title text-lg" itemprop="name">
            中断与异常处理
        </h1>
    



            <p class="article-meta mb-3 text-xs">
                <span class="article-date">
    <i class="iconfont icon-calendar-check"></i>
	<a href="/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-date">
	  <time datetime="2025-07-11T09:01:41.000Z" itemprop="datePublished">7月 11</time>
	</a>
</span>

                
    <span class="article-category">
    <i class="iconfont icon-folder"></i>
    <a class="article-category-link" href="/categories/x86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">x86操作系统</a>
  </span>


                
    <span class="article-tags">
    <i class="iconfont icon-tag"></i>
    <a class="article-tag-none-link" href="/tags/Linux/" rel="tag">Linux</a>, <a class="article-tag-none-link" href="/tags/x86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">x86操作系统</a>
  </span>


                <span class="_partial/post-comment"><i class="icon icon-comment"></i>
                    <a href="/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/#comments" class="article-comment-link">
                        评论
                    </a>
                </span>
                
    
        <span class="post-wordcount" itemprop="wordCount">字数统计: 5.1k(字)</span>
    
    
        <span class="post-readcount" itemprop="timeRequired">阅读时长: 20(分)</span>
    


            </p>
        </header>
        <div class="marked-body article-body">
            <h1 id="中断与异常处理"><a href="#中断与异常处理" class="headerlink" title="中断与异常处理"></a>中断与异常处理</h1><p>加载出内核后，后续的代码基本就是对内核的设计，首先就是对中断和异常处理的设计。</p>
<h2 id="创建GDT表及其表项"><a href="#创建GDT表及其表项" class="headerlink" title="创建GDT表及其表项"></a>创建GDT表及其表项</h2><p>x86架构（IA32 模式 ）支持两种存储模式，分段式存储和分页式存储。</p>
<ul>
<li><p><strong>分段</strong>：先通过分段机制，把逻辑地址（由段选择器和偏移量组成 ）转换为线性地址。利用 全局描述符表（GDT）、局部描述符表（LDT ）等，依据段选择器找到对应的段描述符，算出线性地址 。这是 x86 内存管理的基础，用于划分内存段、设置访问权限等。</p>
<ul>
<li>分段机制：<ol>
<li>将线性地址空间转变为多个段（segments）。</li>
<li>每个段带有相关的保护机制</li>
<li>有多种类型的段：数据、代码、门、tss</li>
<li>使用的地址为逻辑地址，即段选择子（指向GDT或LDT中的段描述符）+偏移</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>分页</strong>：可选启用，若启用，线性地址会经分页机制转换为物理地址。通过页目录（Page Directory ）、页表（Page Table ）等结构，把线性地址按页（如 4KB 页 ）拆分，映射到物理内存页，可实现虚拟内存、内存共享、内存保护细化等，还能隐藏物理内存细节，让程序使用连续虚拟地址，实际对应物理内存可离散。</p>
<ul>
<li>分页机制<ol>
<li>将线性地址转换为物理地址</li>
<li>通过虚拟内存机制，用磁盘空间扩展物理内存的容量</li>
<li>按需加载等功能</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>这里主要关注分段式存储中的GDT表。</p>
<p>GDT是x86架构下（尤其是保护模式）用于内存管理和保护的数据结构，本质是一个数组，每个元素叫做<strong>段描述符</strong>，占八个字节，段描述符控制者个隔断的起始地址、大小和访问属性（当前指令具体访问哪个段则由段寄存器决定），包含：</p>
<p><img src="2.png" alt="段描述符内容"></p>
<h3 id="Seg-Desc-（通用段描述符）"><a href="#Seg-Desc-（通用段描述符）" class="headerlink" title="Seg. Desc.（通用段描述符）"></a><code>Seg. Desc.</code>（通用段描述符）</h3><ul>
<li><strong>作用</strong>：描述最基础的内存段，比如 <strong>代码段（Code Segment）、数据段（Data Segment）、栈段（Stack Segment）</strong> 。</li>
<li><strong>内容</strong>：存了段的<strong>基地址（Base）、段界限（Limit）、访问权限（如只读 / 可写、特权级）</strong> 等。程序里的 <code>CS</code>（代码段寄存器）、<code>DS</code>（数据段寄存器）、<code>SS</code>（栈段寄存器），最终都会通过这类描述符找到实际内存位置。</li>
</ul>
<h3 id="TSS-Desc-（任务状态段描述符）"><a href="#TSS-Desc-（任务状态段描述符）" class="headerlink" title="TSS Desc.（任务状态段描述符）"></a><code>TSS Desc.</code>（任务状态段描述符）</h3><ul>
<li><strong>TSS </strong>：TSS（Task State Segment）是一块内存区域，存着<strong>任务的上下文</strong>（比如寄存器值、栈指针、特权级），切换任务时，CPU 会自动从 TSS 恢复 / 保存现场。</li>
<li><strong><code>TSS Desc.</code> 作用</strong>：把 TSS 当普通内存段 “描述” 起来，让 CPU 能找到它的基地址、大小、权限。图里多个 <code>TSS Desc.</code>，对应多任务场景下不同任务的 TSS。</li>
</ul>
<h3 id="LDT-Desc-（局部描述符表描述符）"><a href="#LDT-Desc-（局部描述符表描述符）" class="headerlink" title="LDT Desc.（局部描述符表描述符）"></a><code>LDT Desc.</code>（局部描述符表描述符）</h3><ul>
<li>**LDT ：LDT（Local Descriptor Table）是 “局部版 GDT”，一个任务（进程）可以有自己的 LDT，存专属的段描述符（比如用户态程序的私有代码段、数据段 ）。</li>
<li><strong><code>LDT Desc.</code> 作用</strong>：把 LDT 本身当一个特殊段，用 <code>LDT Desc.</code> 描述它的位置、大小、权限，让 CPU 能找到并访问这个任务的 LDT。</li>
</ul>
<p><img src="1.png" alt="image0344"></p>
<p>创建一个GDT表结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">segment_desc_t</span>  /*定义<span class="title">GDT</span>表结构体*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit15_0;  <span class="comment">/*段界限*/</span></span><br><span class="line">    <span class="type">uint16_t</span> base15_0; <span class="comment">/*基地址*/</span></span><br><span class="line">    <span class="type">uint8_t</span> base23_16;</span><br><span class="line">    <span class="type">uint16_t</span> attr; <span class="comment">/*属性*/</span></span><br><span class="line">    <span class="type">uint8_t</span> base31_24;</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">segment_desc_t</span>;</span><br></pre></td></tr></table></figure>
<p>初始化GDT表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化GDT表中的固定表项*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">segment_desc_set</span><span class="params">(<span class="type">int</span> selector, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint16_t</span> attr)</span> &#123;</span><br><span class="line">    <span class="type">segment_desc_t</span> * desc = gdt_table + selector / <span class="keyword">sizeof</span>(segment_desc_set); <span class="comment">/*左移三位，也就是除以8*/</span></span><br><span class="line">    desc-&gt;limit15_0 = limit &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    desc-&gt;attr = attr | (((limit&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    desc-&gt;base15_0 = base &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    desc-&gt;base23_16 = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    desc-&gt;base15_0 = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对GDT表进行初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; GDT_TABLE_SIZE; i++) &#123;  <span class="comment">/*暂时清零*/</span></span><br><span class="line">        segment_desc_set(i * <span class="keyword">sizeof</span>(segment_desc_set), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分段模型"><a href="#分段模型" class="headerlink" title="分段模型"></a>分段模型</h2><h3 id="多段模型（Multi-Segment-Model）"><a href="#多段模型（Multi-Segment-Model）" class="headerlink" title="多段模型（Multi - Segment Model）"></a>多段模型（Multi - Segment Model）</h3><p>把内存拆成多个独立的段，每个段都有自己的基地址、长度、访问权限，不同类型的段分工明确：CS 指向代码段（存程序指令 ）、SS 指向栈段（存函数调用的临时数据 ）、DS/ES 等指向数据段（存变量 ） 。</p>
<p><img src="3.png" alt="3"></p>
<h3 id="平坦模型"><a href="#平坦模型" class="headerlink" title="平坦模型"></a>平坦模型</h3><p>他是多段模型的简化版，把整个内存（或线性地址空间）当成一整块连续的区域使用。</p>
<p>只使用了两个段：代码段和数据段。段基是地址均为0，limit大小为4GB（32位系统），这样逻辑地址的偏移量直接对应线性地址，段选择子也就失去实际意义。</p>
<p><img src="4.png" width="60%" alt></p>
<h3 id="逻辑地址转换到线性地址的过程"><a href="#逻辑地址转换到线性地址的过程" class="headerlink" title="逻辑地址转换到线性地址的过程"></a>逻辑地址转换到线性地址的过程</h3><ol>
<li>从段寄存器获取段选择子</li>
<li>根据选择子在GDT表中获取基地址</li>
<li>线性地址=基地址+偏移量，如果无分页机制，则直接为物理地址</li>
</ol>
<p><img src="5.png" alt="5">CC</p>
<h2 id="重新加载GDT表"><a href="#重新加载GDT表" class="headerlink" title="重新加载GDT表"></a>重新加载GDT表</h2><p>在loader_16中有设置过一个GDT表，没有解释每个值的意义，现在了解了GDT表项的含义，在kernel中重新加载GDT表，用到的模式就是平坦模式，只需要初始化两个段，数据段和代码段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 全部清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GDT_TABLE_SIZE; i++) &#123;</span><br><span class="line">        segment_desc_set(i &lt;&lt; <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据段</span></span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_DS, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA</span><br><span class="line">                     | SEG_TYPE_RW | SEG_D | SEG_G);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能用非一致代码段，以便通过调用门更改当前任务的CPL执行关键的资源访问操作</span></span><br><span class="line">    segment_desc_set(KERNEL_SELECTOR_CS, <span class="number">0x00000000</span>, <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE</span><br><span class="line">                     | SEG_TYPE_RW | SEG_D | SEG_G);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载gdt</span></span><br><span class="line">    lgdt((<span class="type">uint32_t</span>)gdt_table, <span class="keyword">sizeof</span>(gdt_table));</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 给出一些宏定义的意义</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SEG_G           (1 &lt;&lt; 15)  <span class="comment">/* 粒度标志(Granularity)：0=Limit单位为字节，1=Limit单位为4KB页 */</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEG_D           (1 &lt;&lt; 14)  <span class="comment">/* 默认操作数大小(Default Operation Size)：</span></span></span><br><span class="line"><span class="comment"><span class="meta">                           * 代码段：0=16位，1=32位（64位系统中为48位）</span></span></span><br><span class="line"><span class="comment"><span class="meta">                           * 栈段：0=16位栈指针，1=32位栈指针(ESP/EBP) */</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEG_P_PRESENT   (1 &lt;&lt; 7)  <span class="comment">/* 段存在标志(Present)：1=段在内存中，0=段不在内存（访问时触发异常） */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEG_DPL0        (0 &lt;&lt; 5)  <span class="comment">/* 描述符特权级(DPL)：0=最高特权级（内核模式） */</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEG_DPL3        (3 &lt;&lt; 5)  <span class="comment">/* 描述符特权级(DPL)：3=最低特权级（用户模式） */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEG_S_SYSTEM    (0 &lt;&lt; 4)  <span class="comment">/* 描述符类型标志(S)：0=系统段（如TSS、LDT） */</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEG_S_NORMAL    (1 &lt;&lt; 4)  <span class="comment">/* 描述符类型标志(S)：1=普通段（代码段/数据段） */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEG_TYPE_CODE   (1 &lt;&lt; 3)  <span class="comment">/* 段类型标志(Type字段)：C=1表示代码段（需配合S=1使用） */</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEG_TYPE_DATA   (0 &lt;&lt; 3)  <span class="comment">/* 段类型标志(Type字段)：C=0表示数据段（需配合S=1使用） */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SEG_TYPE_RW     (1 &lt;&lt; 1)  <span class="comment">/* 读写权限标志(Type字段)：</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                    * 数据段：R/W=1表示可写（W标志）</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                    * 代码段：R/W=1表示可读（R标志） */</span></span></span><br></pre></td></tr></table></figure>
<p>后面可以在GDT表中增加一些特殊的描述符：门描述符（用于控制程序流程的跳转），包括中断门、陷阱门、任务门。</p>
<h2 id="异常与中断"><a href="#异常与中断" class="headerlink" title="异常与中断"></a>异常与中断</h2><p>在程序运行的过程中，有可能会发生各种异常事件，CPU需要跳转到相应的程序对这些事件进行处理。门描述符就是处理异常和中断的中间层。</p>
<h3 id="异常（Exception）"><a href="#异常（Exception）" class="headerlink" title="异常（Exception）"></a>异常（Exception）</h3><ul>
<li><strong>定义</strong>：由 CPU 内部事件触发的同步事件，与当前执行的指令直接相关。</li>
<li>触发原因：<ul>
<li><strong>错误（Fault）</strong>：如缺页异常（Page Fault）、除零错误。</li>
<li><strong>陷阱（Trap）</strong>：如系统调用（通过<code>int</code>指令主动触发）。</li>
<li><strong>终止（Abort）</strong>：如硬件故障、无法恢复的错误。</li>
</ul>
</li>
<li>特点：<ul>
<li><strong>同步性</strong>：与指令执行严格同步，==发生在指令执行期间==。</li>
<li><strong>可预测性</strong>：通常由程序逻辑或硬件状态引发（如访问非法内存）。</li>
</ul>
</li>
</ul>
<h3 id="中断（Interrupt）"><a href="#中断（Interrupt）" class="headerlink" title="中断（Interrupt）"></a>中断（Interrupt）</h3><ul>
<li><strong>定义</strong>：由 CPU 外部设备（如键盘、网卡）或内部定时器触发的异步事件。</li>
<li>触发原因：<ul>
<li><strong>硬件中断</strong>：外设（如鼠标、硬盘）通过中断控制器（如 8259A、IOAPIC）向 CPU 发送信号。</li>
<li><strong>软件中断</strong>：通过特定指令（如 x86 的<code>INT n</code>）触发，常用于系统调用。</li>
</ul>
</li>
<li>特点：<ul>
<li><strong>异步性</strong>：==与当前指令执行无关==，可能随时发生，由外部事件引起。</li>
<li><strong>突发性</strong>：由外部设备状态变化引发（如按键按下、数据到达）。</li>
</ul>
</li>
</ul>
<h3 id="门描述符"><a href="#门描述符" class="headerlink" title="门描述符"></a>门描述符</h3><p>门描述符是异常 / 中断处理的<strong>中间层</strong>，存储在IDT（中断描述符表）中负责：</p>
<ol>
<li><strong>地址映射</strong>：将中断向量号映射到具体的处理程序地址。</li>
<li><strong>权限控制</strong>：限制哪些特权级的代码可以触发该异常 / 中断。</li>
<li><strong>上下文切换</strong>：自动处理特权级切换（如从用户态到内核态）和堆栈切换。</li>
</ol>
<p>当 CPU 接收到异常或中断信号时，执行以下步骤：</p>
<ol>
<li><strong>获取向量号</strong>：<ul>
<li>异常：由 CPU 自动生成（如除零错误对应向量号 0）。</li>
<li>中断：通过中断控制器（如 IOAPIC）获取向量号（如键盘中断对应 0x21）。</li>
</ul>
</li>
<li><strong>查找门描述符</strong>：<ul>
<li>向量号作为索引，从 IDT 中找到对应的门描述符（例如，向量号 0 对应 IDT [0]）。</li>
</ul>
</li>
<li><strong>验证权限</strong>：<ul>
<li>比较当前特权级（CPL）与门描述符的 DPL（描述符特权级）：<ul>
<li>若 <code>CPL ≤ DPL</code>，允许访问；否则触发一般保护故障（#GP）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>执行处理程序</strong>：<ul>
<li>根据门描述符中的<strong>段选择子</strong>和<strong>偏移量</strong>，跳转到处理程序。</li>
<li>对于中断门和陷阱门，自动保存当前上下文（如 EFLAGS、CS、EIP）。</li>
</ul>
</li>
</ol>
<h2 id="中断门描述符与IDT表"><a href="#中断门描述符与IDT表" class="headerlink" title="中断门描述符与IDT表"></a>中断门描述符与IDT表</h2><p>IDT表配置类似于GDT表，由一个寄存器指向：IDTR寄存器，内部存放门描述符。</p>
<p>门描述符只存放了基地址和界限信息。</p>
<p><img src="6.png" alt="6"></p>
<p>本项目主要实现中断门描述符的功能，其中interrupt gate中segment selector指定了代码段的选择子，offset指定了偏移。即二者结合，指定了各表项对应的异常/中断的处理程序的首地址。</p>
<p><img src="7.png" alt="7"></p>
<p>地址生成如下：</p>
<ol>
<li>根据向量号取IDT中的对应表项，</li>
<li>从IDT表项取选择子</li>
<li>用选择子从GDT表中查找段的首地址，</li>
<li>将段首地址+IDT表项中的偏移量，生成处理程序的首地址</li>
<li>跳转至首地址运行。</li>
</ol>
<p>首先与GDT表类似，将IDT表初始化为全零，后续会将具体的异常中断处理程序与IDT表项进行关联。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 初始化为全<span class="number">0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; IDE_TABLE_NR; i++) &#123;</span><br><span class="line">        gate_desc_set(idt_table + i,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));  <span class="comment">//重新加载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lidt</span><span class="params">(<span class="type">uint32_t</span> start, <span class="type">uint32_t</span> size)</span> &#123;  <span class="comment">//与lgdt十分相似</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">uint16_t</span> limit;</span><br><span class="line">		<span class="type">uint16_t</span> start15_0;</span><br><span class="line">		<span class="type">uint16_t</span> start31_16;</span><br><span class="line">	&#125; idt;</span><br><span class="line"></span><br><span class="line">	idt.start31_16 = start &gt;&gt; <span class="number">16</span>;</span><br><span class="line">	idt.start15_0 = start &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">	idt.limit = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(<span class="string">&quot;lidt %[g]&quot;</span>::[g]<span class="string">&quot;m&quot;</span>(idt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化并加载成功后，IDT表的首地址与qemu显示的寄存器信息一致：</p>
<p><img src="idt加载后，首地址能对上.png" alt="idt加载后，首地址能对上"></p>
<p>下面就是为所有异常配置缺省的处理程序，采用平坦模型，所有段的起始地址都为0，通过offset来找到对应处理程序的地址：</p>
<p><img src="8.png" alt="8"></p>
<h3 id="发生除零异常："><a href="#发生除零异常：" class="headerlink" title="发生除零异常："></a>发生除零异常：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span> / <span class="number">0</span>;  <span class="comment">// 除零触发异常</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_default_handler</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;&#125;  <span class="comment">//死机处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_unknown</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	do_default_handler(<span class="string">&quot;Unknown exception.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 中断和异常初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_init</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; IDT_TABLE_NR; i++) &#123;</span><br><span class="line">    	gate_desc_set(idt_table + i, KERNEL_SELECTOR_CS, (<span class="type">uint32_t</span>) exception_handler_unknown,  <span class="comment">/* 这个函数使用汇编语言编写，因为部分关键操作必须使用特定汇编指令（如cli关中断、sti开中断、iret中断返回），这些指令无对应的 C 语言关键字，需通过汇编内嵌或独立汇编文件实现。 */</span></span><br><span class="line">                  GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);</span><br><span class="line">	&#125;</span><br><span class="line">	lidt((<span class="type">uint32_t</span>)idt_table, <span class="keyword">sizeof</span>(idt_table));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exception_handler_unknown:</span><br><span class="line">	<span class="comment">// 保存所有寄存器</span></span><br><span class="line">	pusha</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	push %fs</span><br><span class="line">	push %gs</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用中断处理函数</span></span><br><span class="line">	call do_handler_unknown</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复保存的寄存器</span></span><br><span class="line">	pop %gs</span><br><span class="line">	pop %fs</span><br><span class="line">	pop %es</span><br><span class="line">	pop %ds</span><br><span class="line">	popa</span><br><span class="line">	iret</span><br></pre></td></tr></table></figure>
<h3 id="解析异常栈信息"><a href="#解析异常栈信息" class="headerlink" title="解析异常栈信息"></a>解析异常栈信息</h3><p>这里主要实现具体在哪个位置触发了异常，异常发生时，会有一部分信息被自动压入栈中，包括<code>EFLAGS、CS、EIP和错误码</code>：</p>
<p><img src="9.png" alt="9"></p>
<p>并且在发生异常后我们通过代码也主动保存了一部分信息，最终我们保存的信息如下：</p>
<p><img src="10.png" alt="10"></p>
<p> 但是可以看出来如果将这些信息全部作为参数传入函数中处理，参数会变得非常长，因此可以看作为结构体，将该结构体的指针也就是ESP寄存器，将结构体指针作为参数传入会更加简洁。</p>
<h3 id="利用宏重用异常处理代码"><a href="#利用宏重用异常处理代码" class="headerlink" title="利用宏重用异常处理代码"></a>利用宏重用异常处理代码</h3><p>x86架构保护模式下的异常与中断表定义了非常多的宏，如果针对这些异常分别添加处理函数，就需要复制多次类似的汇编代码编写的处理程序，而这些处理程序的区别只在调用的对应c代码，因此利用gcc工具链中汇编代码中的宏功能，实现类似C语言中的define功能，从而达到重用代码的目的。</p>
<p>如果要定义宏，需要使用.macro和.endm伪指令。其基本示例如下：</p>
<blockquote>
<p>.macro  宏的名称 参数0, 参数1….<br>汇编代码<br>.endm</p>
</blockquote>
<p> 其中参数是可选的，也可给参数一个缺省值，例如：</p>
<ul>
<li>.macro comm   — 定义一个comm宏，不需要参数</li>
<li>.macro plus1 p, p1 — 定义一个plus1宏，带参数p和p1</li>
<li>.macro plus1 p p1 — 定义一个plus1宏，带 参数p和p1(用空格分隔)</li>
<li>.macro reserve_str p1=0 p2 — 定义一个reserve宏，带p1和p2参数，其中p1的缺省值为0</li>
</ul>
<p>在宏的内部，==可以通过\参数名的方式去引用参数== ，例如：</p>
<blockquote>
<pre><code>   .macro  sum from=0, to=5
    .long   \from
    .if     \to-\from
    sum     &quot;(\from+1)&quot;,\to
    .endif
    .endm
</code></pre></blockquote>
<p>具体实现为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">.macro exception_handler name num with_error_code</span><br><span class="line">	    .extern do_handler_\name</span><br><span class="line">		.global exception_handler_\name</span><br><span class="line">	exception_handler_\name:</span><br><span class="line">		// 如果没有错误码，压入一个缺省值</span><br><span class="line">		// 这样堆栈就和有错误码的情形一样了</span><br><span class="line">		.if \with_error_code == 0</span><br><span class="line">			push $0</span><br><span class="line">		.endif</span><br><span class="line"></span><br><span class="line">		// 压入异常号</span><br><span class="line">		push $\num</span><br><span class="line"></span><br><span class="line">		// 保存所有寄存器</span><br><span class="line">		pushal</span><br><span class="line">		push %ds</span><br><span class="line">		push %es</span><br><span class="line">		push %fs</span><br><span class="line">		push %gs</span><br><span class="line"></span><br><span class="line">		// 调用中断处理函数</span><br><span class="line">		push %esp</span><br><span class="line">		call do_handler_\name</span><br><span class="line">		add $(1*4), %esp		// 丢掉esp</span><br><span class="line"></span><br><span class="line">		// 恢复保存的寄存器</span><br><span class="line">		pop %gs</span><br><span class="line">		pop %fs</span><br><span class="line">		pop %es</span><br><span class="line">		pop %ds</span><br><span class="line">		popal</span><br><span class="line"></span><br><span class="line">		// 跳过压入的异常号和错误码</span><br><span class="line">		add $(2*4), %esp</span><br><span class="line">		iret</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">exception_handler unknown, -1, 0</span><br><span class="line">exception_handler divider, 0, 0</span><br><span class="line">exception_handler Debug, 1, 0</span><br><span class="line">exception_handler NMI, 2, 0</span><br><span class="line">exception_handler breakpoint, 3, 0</span><br><span class="line">exception_handler overflow, 4, 0</span><br><span class="line">exception_handler bound_range, 5, 0</span><br><span class="line">exception_handler invalid_opcode, 6, 0</span><br><span class="line">exception_handler device_unavailable, 7, 0</span><br><span class="line">exception_handler double_fault, 8, 1</span><br><span class="line">exception_handler invalid_tss, 10, 1</span><br><span class="line">exception_handler segment_not_present, 11, 1</span><br><span class="line">exception_handler stack_segment_fault, 12, 1</span><br><span class="line">exception_handler general_protection, 13, 1</span><br><span class="line">exception_handler page_fault, 14, 1</span><br><span class="line">exception_handler fpu_error, 16, 0</span><br><span class="line">exception_handler alignment_check, 17, 1</span><br><span class="line">exception_handler machine_check, 18, 0</span><br><span class="line">exception_handler smd_exception, 19, 0</span><br><span class="line">exception_handler virtual_exception, 20, 0</span><br><span class="line"></span><br><span class="line">// 硬件中断</span><br><span class="line">exception_handler timer, 0x20, 0</span><br></pre></td></tr></table></figure>
<p>发生异常后，会根据错误码等跳转到相应的handler函数，并且使CPU暂停执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_default_handler</span> <span class="params">(<span class="type">exception_frame_t</span> * frame, <span class="type">const</span> <span class="type">char</span> * message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;hlt();&#125;  <span class="comment">//暂停，使用内联函数实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_unknown</span> <span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Unknown exception.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_divider</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Device Error.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_Debug</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Debug Exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_NMI</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;NMI Interrupt.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_breakpoint</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Breakpoint.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_overflow</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Overflow.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_bound_range</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;BOUND Range Exceeded.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_invalid_opcode</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Invalid Opcode.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_device_unavailable</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Device Not Available.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_double_fault</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Double Fault.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_invalid_tss</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Invalid TSS&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_segment_not_present</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Segment Not Present.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_stack_segment_fault</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Stack-Segment Fault.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_general_protection</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;General Protection.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_page_fault</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Page Fault.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_fpu_error</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;X87 FPU Floating Point Error.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_alignment_check</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Alignment Check.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_machine_check</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Machine Check.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_smd_exception</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;SIMD Floating Point Exception.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_handler_virtual_exception</span><span class="params">(<span class="type">exception_frame_t</span> * frame)</span> &#123;</span><br><span class="line">	do_default_handler(frame, <span class="string">&quot;Virtualization Exception.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化中断控制器"><a href="#初始化中断控制器" class="headerlink" title="初始化中断控制器"></a>初始化中断控制器</h2><p>早期x86使用8259芯片来管理终端，使用两块8259级联来支持15种中断，随着多核处理器的发展，8259被APIC所取代</p>
<p><img src="11.png" width="40%" alt></p>
<p>这里具体的硬件实现不需要关注，只需要关注相应的寄存器的配置。在对寄存器初始化时，需要分配对上述中的master和slave进行初始化。其中master对应的端口起始地址为0x20，slave对应的端口起始地址为0xA0。芯片的手册中给出了初始化流程和相应的寄存器格式说明。</p>
<p><img src="12.png" width="40%" alt></p>
<p>8259的工作模式较为复杂，这里只做了非常简单的配置，不考虑中断嵌套、优先级等问题。具体配置如下：</p>
<ul>
<li>主片：边缘触发，级联、起始中断序号为0x20，IRQ2上有从片，普通全嵌套、非缓冲、非自动结束、8086模式</li>
<li>从片：边缘触发，级联、起始中断序号为0x28，连接到主片的IRQ2上，普通全嵌套、非缓冲、非自动结束、8086模式</li>
</ul>
<p>后续要使用定时器，因此需要做中断的开关函数。</p>
<h2 id="启动定时器并开中断"><a href="#启动定时器并开中断" class="headerlink" title="启动定时器并开中断"></a>启动定时器并开中断</h2><h3 id="中断的打开与关闭"><a href="#中断的打开与关闭" class="headerlink" title="中断的打开与关闭"></a>中断的打开与关闭</h3><p>中断的打开和关闭受制于两种配置，一个是8259A内部的IMR寄存器，还有一个EFLAGS的IF标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_disable_global</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="comment">//关闭全局中断位</span></span><br><span class="line">	cli();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_enable_global</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="comment">//开启全局中断位</span></span><br><span class="line">	sti();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_enable</span><span class="params">(<span class="type">int</span> irq_num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(irq_num &lt; IRQ_PIC_START) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将IRQ编号转换为相对于PIC芯片的内部偏移量</span></span><br><span class="line">	<span class="comment">// IRQ_PIC_START通常为0x20（32），是8259 PIC在x86中断向量表中的起始位置	</span></span><br><span class="line">	irq_num -= IRQ_PIC_START;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断IRQ属于第一块还是第二块8259 PIC</span></span><br><span class="line">	<span class="keyword">if</span> (irq_num &lt; <span class="number">8</span>) &#123; <span class="comment">// 第一块8259 PIC（主控制器），负责IRQ0-7</span></span><br><span class="line">		<span class="comment">// 1. 读取当前主PIC的中断屏蔽寄存器（IMR）</span></span><br><span class="line">		<span class="comment">// 2. 清除对应IRQ位（使用位运算 ~(1 &lt;&lt; irq_num)）以启用该IRQ</span></span><br><span class="line">		<span class="comment">// 3. 将修改后的屏蔽字写回主PIC的IMR端口（0x21）</span></span><br><span class="line">		<span class="type">uint8_t</span> mask = inb(PIC0_IMR) &amp; ~(<span class="number">1</span> &lt;&lt; irq_num);</span><br><span class="line">		outb(PIC0_IMR, mask);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 第二块8259 PIC（从控制器），负责IRQ8-15</span></span><br><span class="line">		<span class="comment">// 1. 计算IRQ在从PIC中的相对编号（0-7）</span></span><br><span class="line">		<span class="comment">// 2. 读取当前从PIC的中断屏蔽寄存器（IMR）</span></span><br><span class="line">		<span class="comment">// 3. 清除对应IRQ位以启用该IRQ</span></span><br><span class="line">		<span class="comment">// 4. 将修改后的屏蔽字写回从PIC的IMR端口（0xA1）</span></span><br><span class="line">		irq_num -= <span class="number">8</span>; <span class="comment">// 转换为从PIC的内部偏移量</span></span><br><span class="line">		<span class="type">uint8_t</span> mask = inb(PIC1_IMR) &amp; ~(<span class="number">1</span> &lt;&lt; irq_num);</span><br><span class="line">		outb(PIC1_IMR, mask);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_disable</span><span class="params">(<span class="type">int</span> irq_num)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(irq_num &lt; IRQ_PIC_START) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	irq_num -= IRQ_PIC_START;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (irq_num &lt; <span class="number">8</span>) &#123;</span><br><span class="line">		<span class="type">uint8_t</span> mask = inb(PIC0_IMR) | ~(<span class="number">1</span> &lt;&lt; irq_num);</span><br><span class="line">		outb(PIC0_IMR, mask);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">uint8_t</span> mask = inb(PIC1_IMR) | ~(<span class="number">1</span> &lt;&lt; irq_num);</span><br><span class="line">		outb(PIC1_IMR, mask);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>定时器负责提供精准的时间基准和周期性中断，用于维护系统时间、计算进程执行时间片、实现睡眠等延时函数。x86系统中使用的定时器芯片是8253。</p>
<p>8253是一颗带有3个内部计数器的定时器的芯片，用于为计算机提供相关的定时和计数功能。其中，我们主要关心定时器/计数器0，因其余两个一般用于其它用途。<br>定时器0可单独计数，其输入的时钟频率为1.193182 MHz。在每个时钟节拍的作用下，进行递减计数。当减至0时，通过8259的IRQ0向CPU发出中断请求，CPU将进入中断服务程序运行。</p>
<p> <img src="13.png" alt="13"></p>
<p>为实现对8253进行配置，可通过如下端口进行设置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">端口地址</th>
<th style="text-align:center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x40</td>
<td style="text-align:center">定时器0数据端口</td>
</tr>
<tr>
<td style="text-align:center">0x41</td>
<td style="text-align:center">定时器1数据端口</td>
</tr>
<tr>
<td style="text-align:center">0x42</td>
<td style="text-align:center">定时器2数据端口</td>
</tr>
<tr>
<td style="text-align:center">0x43</td>
<td style="text-align:center">模式和命令端口</td>
</tr>
</tbody>
</table>
</div>
<p>具体实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算PIT的重装载值：将毫秒转换为PIT计数值</span></span><br><span class="line"><span class="comment">// PIT_OSC_FREQ = 1193180Hz (PIT的基准时钟频率)</span></span><br><span class="line"><span class="comment">// OS_TICK_MS = 期望的中断周期(毫秒)，例如10ms = 100Hz</span></span><br><span class="line"><span class="comment">// 公式：reload_count = (1193180 * 10ms) / 1000 = 11932 (约等于10ms)</span></span><br><span class="line"><span class="type">uint32_t</span> reload_count = (PIT_OSC_FREQ * OS_TICK_MS) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置PIT通道0为模式3(方波发生器) */</span></span><br><span class="line"><span class="comment">// PIT_CHANNEL = 0x00 (选择通道0)</span></span><br><span class="line"><span class="comment">// PIT_LOAD_LOHI = 0x30 (先写低字节，再写高字节)</span></span><br><span class="line"><span class="comment">// PIT_MODE3 = 0x06 (模式3：方波输出，用于周期性中断)</span></span><br><span class="line">outb(PIT_COMMAND_MODE_PORT, PIT_CHANNEL | PIT_LOAD_LOHI | PIT_MODE3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入16位计数值的低8位</span></span><br><span class="line">outb(PIT_CHANNEL_DATA_PORT, reload_count &amp; <span class="number">0xFF</span>);</span><br><span class="line"><span class="comment">// 写入16位计数值的高8位</span></span><br><span class="line">outb(PIT_CHANNEL_DATA_PORT, (reload_count &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册定时器中断处理函数</span></span><br><span class="line"><span class="comment">// IRQ0_TIMER = 0x20 (PIT通道0对应的中断向量号)</span></span><br><span class="line"><span class="comment">// exception_handler_time = 自定义的中断处理函数</span></span><br><span class="line">irq_install(IRQ0_TIMER, (<span class="type">irq_handler_t</span>)exception_handler_time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用PIT通道0的中断</span></span><br><span class="line"><span class="comment">// 通过清除8259A PIC的IMR(中断屏蔽寄存器)对应位来启用IRQ0</span></span><br><span class="line">irq_enable(IRQ0_TIMER);</span><br></pre></td></tr></table></figure>
<p>定时器的中断会在以后一些延时函数、进程调度等地方用到。</p>
<p>以上就是中断与异常处理部分的记录。</p>

        </div>
        
<blockquote class="copyright">
    <p><strong>本文链接 : </strong><a class="permalink" href="https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">https://github.com/Nxhhhh/Nxhhhh.github.io/2025/07/11/中断与异常处理/</a></p>
    <p><strong>This article is available under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a> License</strong></p>
</blockquote>


    </article>
    
    <section id="comments">
        
    </section>


    

</main>


<aside style="" id="sidebar" class="aside aside-fixture">
    <div class="toc-sidebar">
        <nav id="toc" class="article-toc">
            <h3 class="toc-title">文章目录</h3>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">中断与异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAGDT%E8%A1%A8%E5%8F%8A%E5%85%B6%E8%A1%A8%E9%A1%B9"><span class="toc-number">1.1.</span> <span class="toc-text">创建GDT表及其表项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Seg-Desc-%EF%BC%88%E9%80%9A%E7%94%A8%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">Seg. Desc.（通用段描述符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TSS-Desc-%EF%BC%88%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">TSS Desc.（任务状态段描述符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LDT-Desc-%EF%BC%88%E5%B1%80%E9%83%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">LDT Desc.（局部描述符表描述符）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">分段模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%AE%B5%E6%A8%A1%E5%9E%8B%EF%BC%88Multi-Segment-Model%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">多段模型（Multi - Segment Model）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">平坦模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%88%B0%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">逻辑地址转换到线性地址的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BDGDT%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">重新加载GDT表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">1.4.</span> <span class="toc-text">异常与中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%EF%BC%88Exception%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">异常（Exception）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%EF%BC%88Interrupt%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">中断（Interrupt）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">门描述符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8EIDT%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">中断门描述符与IDT表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E7%94%9F%E9%99%A4%E9%9B%B6%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-number">1.5.1.</span> <span class="toc-text">发生除零异常：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%BC%82%E5%B8%B8%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.</span> <span class="toc-text">解析异常栈信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%AE%8F%E9%87%8D%E7%94%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.3.</span> <span class="toc-text">利用宏重用异常处理代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">初始化中断控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B9%B6%E5%BC%80%E4%B8%AD%E6%96%AD"><span class="toc-number">1.7.</span> <span class="toc-text">启动定时器并开中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">1.7.1.</span> <span class="toc-text">中断的打开与关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">定时器</span></a></li></ol></li></ol></li></ol>
        </nav>
    </div>
</aside>





        </section>
        <footer class="hidden lg:block fixed bottom-0 left-0 sm:w-1/12 lg:w-1/6 bg-gray-100 z-40">
    
    
</footer>

        <div id="mask" class="hidden mask fixed inset-0 bg-gray-900 opacity-75 z-40"></div>
        <div id="search-view-container" class="hidden shadow-xl"></div>
        
<script src="/js/dom-event.min.js"></script>



<script src="/js/local-search.min.js"></script>



    <script src="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/js/lightgallery.min.js"></script>
    
<script src="/js/light-gallery.min.js"></script>






    </body>
</html>
